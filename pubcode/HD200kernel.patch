diff -Naur linux-2.6.25.8/Makefile linux-2.6.25.8-clean/Makefile
--- linux-2.6.25.8/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/Makefile	2008-09-22 22:02:15.000000000 -0400
@@ -190,8 +190,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= mips
+CROSS_COMPILE	?= mipsel-unknown-linux-gnu-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff -Naur linux-2.6.25.8/README.0000.shared.patch linux-2.6.25.8-clean/README.0000.shared.patch
--- linux-2.6.25.8/README.0000.shared.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.0000.shared.patch	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,19 @@
+Feature:
+-------
+Common patch
+
+Prerequisite patch numbers:
+--------------------------
+None
+
+Primary author:
+--------------
+YH Lin & Emmanuel Michon
+
+Related to which chip version?
+-----------------------------
+Tango2 ES6/RevA or above.
+
+(linux patches) which CONFIG_... are provided:
+---------------------------------------------
+*** TBD
diff -Naur linux-2.6.25.8/README.1000.tangox.patch linux-2.6.25.8-clean/README.1000.tangox.patch
--- linux-2.6.25.8/README.1000.tangox.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.1000.tangox.patch	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,18 @@
+Feature:
+--------
+Core support for SMP86xx chips.
+
+Prerequisite patch numbers:
+---------------------------
+0000
+
+Primary author:
+---------------
+External (YH Lin)
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
diff -Naur linux-2.6.25.8/README.1003.mbus.patch linux-2.6.25.8-clean/README.1003.mbus.patch
--- linux-2.6.25.8/README.1003.mbus.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.1003.mbus.patch	2008-06-26 14:59:52.000000000 -0400
@@ -0,0 +1,19 @@
+Feature:
+--------
+MBUS and SBOX support for SMP86xx
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+
+Primary author:
+---------------
+(External) YH Lin
+
+Related to which chip version SMP86xx xx=?
+------------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
diff -Naur linux-2.6.25.8/README.1004.ide.patch linux-2.6.25.8-clean/README.1004.ide.patch
--- linux-2.6.25.8/README.1004.ide.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.1004.ide.patch	2008-06-26 14:59:56.000000000 -0400
@@ -0,0 +1,21 @@
+Feature:
+--------
+Bus Mastering IDE and PB IDE controllers support for SMP863xx.
+Some common fixes for block device operations are included as well.
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+1003
+
+Primary author:
+---------------
+External (Craig Qu/YH Lin)
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
diff -Naur linux-2.6.25.8/README.1005.tango2enet.patch linux-2.6.25.8-clean/README.1005.tango2enet.patch
--- linux-2.6.25.8/README.1005.tango2enet.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.1005.tango2enet.patch	2008-06-26 15:00:17.000000000 -0400
@@ -0,0 +1,19 @@
+Feature:
+--------
+Builtin ethernet controller support for SMP863x
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+
+Primary author:
+---------------
+External (Craig Qu)
+
+Related to which chip version SMP86xx xx=?
+------------------------------------------
+Tango2 ES6/RevA or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
diff -Naur linux-2.6.25.8/README.1006.usb.patch linux-2.6.25.8-clean/README.1006.usb.patch
--- linux-2.6.25.8/README.1006.usb.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.1006.usb.patch	2008-06-26 15:01:02.000000000 -0400
@@ -0,0 +1,19 @@
+Feature:
+--------
+Support for SMP86xx builtin EHCI/OHCI USB controllers.
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+
+Primary author:
+---------------
+Craig Qu
+
+Related to which chip version SMP86xx xx=?
+------------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
diff -Naur linux-2.6.25.8/README.1007.mtd.patch linux-2.6.25.8-clean/README.1007.mtd.patch
--- linux-2.6.25.8/README.1007.mtd.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.1007.mtd.patch	2008-06-27 15:45:17.000000000 -0400
@@ -0,0 +1,19 @@
+Feature:
+--------
+Customization of MTD layer for SMP863x/SMP865x
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+
+Primary author:
+---------------
+YH Lin
+
+Related to which chip version SMP86xx xx=?
+------------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
diff -Naur linux-2.6.25.8/README.1008.ir.patch linux-2.6.25.8-clean/README.1008.ir.patch
--- linux-2.6.25.8/README.1008.ir.patch	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/README.1008.ir.patch	2008-06-27 16:08:10.000000000 -0400
@@ -0,0 +1,19 @@
+Feature:
+--------
+Support for SMP86xx InfraRed (IR) controller.
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+
+Primary author:
+---------------
+YH Lin
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
diff -Naur linux-2.6.25.8/arch/mips/Kconfig linux-2.6.25.8-clean/arch/mips/Kconfig
--- linux-2.6.25.8/arch/mips/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/Kconfig	2008-06-26 14:59:44.000000000 -0400
@@ -599,6 +599,45 @@
 	  Technology and now in turn merged with Fujitsu.  Say Y here to
 	  support this machine type.
 
+config TANGO2
+	bool "Support for SigmaDesigns Tango2 board"
+	select TANGOX
+	select TANGO2_SMP863X
+	select CEVT_R4K
+	select CSRC_R4K
+ 	select CRYPTO_SHA1
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select IRQ_CPU
+	select OWN_DMA
+	select DMA_TANGOX
+	select DMA_NONCOHERENT
+	help
+	  Add support for Sigma Designs SMP863x board. Say Y here to
+	  support this machine type.
+
+config TANGO3
+	bool "Support for SigmaDesigns Tango3 board"
+	select TANGOX
+	select TANGO3_SMP865X
+ 	select CRYPTO_SHA1
+ 	select CRYPTO_SHA256
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select IRQ_CPU
+	select OWN_DMA
+	select DMA_TANGOX
+	select DMA_NONCOHERENT
+	help
+	  Add support for Sigma Designs SMP86xx board. Say Y here to
+	  support this machine type.
+
 config TOSHIBA_JMR3927
 	bool "Toshiba JMR-TX3927 board"
 	select CEVT_TXX9
@@ -690,6 +729,7 @@
 source "arch/mips/pmc-sierra/Kconfig"
 source "arch/mips/sgi-ip27/Kconfig"
 source "arch/mips/sibyte/Kconfig"
+source "arch/mips/tangox/Kconfig"
 source "arch/mips/tx4927/Kconfig"
 source "arch/mips/tx4938/Kconfig"
 source "arch/mips/vr41xx/Kconfig"
@@ -797,6 +837,13 @@
 config DMA_IP27
 	bool
 
+config TANGOX
+	bool 
+
+config DMA_TANGOX
+	bool
+	select DMA_NEED_PCI_MAP_STATE
+
 config DMA_NONCOHERENT
 	bool
 	select DMA_NEED_PCI_MAP_STATE
@@ -987,6 +1034,8 @@
 	default "4" if MACH_DECSTATION
 	default "7" if SGI_IP27 || SGI_IP28 || SNI_RM
 	default "4" if PMC_MSP4200_EVAL
+	default "4" if TANGO2
+	default "5" if TANGO3
 	default "5"
 
 config HAVE_STD_PC_SERIAL_PORT
diff -Naur linux-2.6.25.8/arch/mips/Makefile linux-2.6.25.8-clean/arch/mips/Makefile
--- linux-2.6.25.8/arch/mips/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/Makefile	2008-06-26 14:59:44.000000000 -0400
@@ -593,6 +593,82 @@
 cflags-$(CONFIG_TOSHIBA_RBTX4938) += -Iinclude/asm-mips/mach-tx49xx
 load-$(CONFIG_TOSHIBA_RBTX4938) += 0xffffffff80100000
 
+ifdef CONFIG_TANGO2
+#
+# Tango2 board
+#
+include include/asm-mips/tango2/emhwlib_registers_tango2.inc
+include include/asm-mips/tango2/emhwlib_dram_tango2.inc
+else
+ifdef CONFIG_TANGO3
+#
+# Tango3 board
+#
+include include/asm-mips/tango3/emhwlib_registers_tango3.inc
+include include/asm-mips/tango3/emhwlib_dram_tango3.inc
+endif
+endif
+
+ifdef CONFIG_TANGO2
+ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+CERT_ID=000c
+CERT_TYPE=8634_ES4_prod
+else
+CERT_ID=000b
+CERT_TYPE=8634_ES4_dev
+endif
+else
+ifdef CONFIG_TANGO3
+ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+# Not yet defined for prod chip
+CERT_ID=000c
+CERT_TYPE=8644_ES1_prod
+else
+CERT_ID=0001
+CERT_TYPE=8644_ES1_dev
+endif
+endif
+endif
+
+internal_hex = 0x$(shell printf "%x" $$(($(1))))
+
+core-$(CONFIG_TANGOX)		+= arch/mips/tangox/
+
+ifdef CONFIG_TANGO2
+cflags-$(CONFIG_TANGO2)		+= -Iinclude/asm-mips/mach-tango2
+load-$(CONFIG_TANGO2)		:= $(call internal_hex,0x80000000+	\
+					$(MEM_BASE_dram_controller_0_alias)+	\
+					$(FM_linuxmips__ftext))
+#ifdef RMCFLAGS
+#cflags-$(CONFIG_TANGO2)		+= $(RMCFLAGS)
+#else
+cflags-$(CONFIG_TANGO2)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2
+cflags-$(CONFIG_TANGO2_ES1)	+= -DEM86XX_REVISION=1
+cflags-$(CONFIG_TANGO2_ES2)	+= -DEM86XX_REVISION=2
+cflags-$(CONFIG_TANGO2_ES3)	+= -DEM86XX_REVISION=3
+cflags-$(CONFIG_TANGO2_ES4)	+= -DEM86XX_REVISION=4
+cflags-$(CONFIG_TANGO2_ES5)	+= -DEM86XX_REVISION=5
+cflags-$(CONFIG_TANGO2_ES6)	+= -DEM86XX_REVISION=6
+cflags-$(CONFIG_TANGO2_SD)	+= -DEM86XX_REVISION=6
+#endif
+else
+ifdef CONFIG_TANGO3
+KERNEL_START_ADDRESS		:= $(CPU_remap2_address)
+cflags-$(CONFIG_TANGO3)		+= -Iinclude/asm-mips/mach-tango3
+load-$(CONFIG_TANGO3)		:= $(call internal_hex,0x80000000+	\
+					$(KERNEL_START_ADDRESS))
+#ifdef RMCFLAGS
+#cflags-$(CONFIG_TANGO3)		+= $(RMCFLAGS)
+#else
+cflags-$(CONFIG_TANGO3)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO3
+cflags-$(CONFIG_TANGO3_ES1)	+= -DEM86XX_REVISION=1
+cflags-$(CONFIG_TANGO3_ES2)	+= -DEM86XX_REVISION=2
+cflags-$(CONFIG_TANGO3_ES3)	+= -DEM86XX_REVISION=3
+#endif
+cflags-$(CONFIG_TANGO3)		+= -DCPU_REMAP_SPACE=$(KERNEL_START_ADDRESS)
+endif
+endif
+
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
@@ -606,6 +682,7 @@
 JIFFIES			= jiffies_64
 endif
 
+
 #
 # Automatically detect the build format. By default we choose
 # the elf format according to the load address.
@@ -678,6 +755,14 @@
 vmlinux.32: vmlinux
 	$(OBJCOPY) -O $(32bit-bfd) $(OBJCOPYFLAGS) $< $@
 
+
+CLEAN_FILES += arch/mips/boot/vmlinux.gz \
+		arch/mips/boot/*.bin \
+		arch/mips/boot/*.xload \
+		arch/mips/boot/*.zbf \
+		arch/mips/boot/zbimage-linux-* 
+
+
 #
 # The 64-bit ELF tools are pretty broken so at this time we generate 64-bit
 # ELF files from 32-bit files by conversion.
@@ -685,7 +770,11 @@
 vmlinux.64: vmlinux
 	$(OBJCOPY) -O $(64bit-bfd) $(OBJCOPYFLAGS) $< $@
 
-makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1)
+ifdef CONFIG_TANGOX
+makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1) loadaddr=$(2) certtype=$(3) certid=$(4)
+else
+makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1) 
+endif
 
 all:	$(all-y)
 
diff -Naur linux-2.6.25.8/arch/mips/boot/build_cpu_xload.bash linux-2.6.25.8-clean/arch/mips/boot/build_cpu_xload.bash
--- linux-2.6.25.8/arch/mips/boot/build_cpu_xload.bash	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/boot/build_cpu_xload.bash	2008-09-17 16:31:34.000000000 -0400
@@ -0,0 +1,40 @@
+#!/bin/bash
+set -e
+#
+if [ $# != 3 ]; then 
+    cat <<EOF
+
+Syntax: $0 cpupkg 000b ES4_dev
+
+The cpupkg came with .zbf extension. You have to specify cpu binary xtask to wrap, 
+the certificate id you plan to use, and the chip revision (ES1_dev or ES4_dev) .
+also make sure that the scripts below are accessible and in your PATH variable
+EOF
+    exit -1 
+fi
+#
+if [ -z "$XSDK_ROOT" ]; then echo "*** You need to define the XSDK_ROOT variable ***"; exit -1; fi
+#
+CPUPKG=$1
+CERTID=$2
+REV=$3
+TMPADDR=0x13000000
+
+CPUPKG_BIN=${CPUPKG}.zbf
+CPUPKG_SIG=${CPUPKG}.8634_${REV}_${CERTID}.bin
+XLOAD_BIN=${CPUPKG}_${REV}.xload
+XRPC_BIN=xrpc_xload_${CPUPKG}_${REV}.bin
+PRIVATE_KEY=$XSDK_ROOT/dummy_private_keys/8634_${REV}_${CERTID}_keyboth.pem
+
+echo Using $CERT_BIN
+
+# aes128 pad!
+zeropad.bash $CPUPKG_BIN 16
+SIZE=`wc -c $CPUPKG_BIN | awk '{print $1}'`
+
+echo CPUPKG Image Map : size=$SIZE
+
+openssl sha1 -sign $PRIVATE_KEY < $CPUPKG_BIN | revbytes.pl > $CPUPKG_SIG
+mkxload.bash $XSDK_ROOT $REV $CERTID $CPUPKG_BIN $CPUPKG_SIG  $XLOAD_BIN
+buildxrpc.bash XRPC_CALLERID_IGNORED XRPC_ID_XLOAD $SIZE $TMPADDR 2 3 4 $XLOAD_BIN $XRPC_BIN
+
diff -Naur linux-2.6.25.8/arch/mips/boot/build_xload.bash linux-2.6.25.8-clean/arch/mips/boot/build_xload.bash
--- linux-2.6.25.8/arch/mips/boot/build_xload.bash	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/boot/build_xload.bash	2008-06-27 14:25:21.000000000 -0400
@@ -0,0 +1,30 @@
+#!/bin/bash
+if [ -z "$XSDK_ROOT" ]; then 
+	echo "*** define your XSDK_ROOT please ***"
+	exit -1
+fi
+#
+
+ZBOOT=vmlinux
+CERTID=000a
+REV=ES4_prod
+ADDR=0x13000000
+
+ZBOOT_BIN=${ZBOOT}.zbf
+ZBOOT_SIG=${ZBOOT}.8634_${REV}_${CERTID}.bin
+XLOAD_BIN=${ZBOOT}_${REV}.xload
+XRPC_BIN=xrpc_xload_${ZBOOT}_${REV}.bin
+PRIVATE_KEY=$XSDK_ROOT/dummy_private_keys/8634_${REV}_${CERTID}_keyboth.pem
+
+echo Using $CERT_BIN
+
+# aes128 pad!
+zeropad.bash $ZBOOT_BIN 16
+SIZE=`wc -c $ZBOOT_BIN | awk '{print $1}'`
+
+echo ZBOOT Image Map : size=$SIZE
+
+openssl sha1 -sign $PRIVATE_KEY < $ZBOOT_BIN | revbytes.pl > $ZBOOT_SIG
+mkxload.bash $XSDK_ROOT $REV $CERTID $ZBOOT_BIN $ZBOOT_SIG  $XLOAD_BIN
+buildxrpc.bash XRPC_CALLERID_IGNORED XRPC_ID_XLOAD $SIZE $ADDR 2 3 4 $XLOAD_BIN $XRPC_BIN
+
diff -Naur linux-2.6.25.8/arch/mips/boot/buildenczbf.sh linux-2.6.25.8-clean/arch/mips/boot/buildenczbf.sh
--- linux-2.6.25.8/arch/mips/boot/buildenczbf.sh	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/boot/buildenczbf.sh	2009-01-19 13:36:42.000000000 -0500
@@ -0,0 +1,6 @@
+#!/bin/sh
+lzma -c -z vmlinux.bin > vmlinux.bin.lz
+tobin.bash `sha1sum -b vmlinux.bin.lz | awk '{ print $1 }'` > vmlinux_sha1.zbf
+sh build_cpu_xload.bash vmlinux_sha1 000a ES4_prod
+cat xrpc_xload_vmlinux_sha1_ES4_prod.bin vmlinux.bin.lz > vmlinux_enc.bin
+genzbf -l 0x90020000 -s 0x90020000 -e `stat --format=%s xrpc_xload_vmlinux_sha1_ES4_prod.bin` -a lzexf -o vmlinux_enc.zbf vmlinux_enc.bin
diff -Naur linux-2.6.25.8/arch/mips/boot/buildzbf.sh linux-2.6.25.8-clean/arch/mips/boot/buildzbf.sh
--- linux-2.6.25.8/arch/mips/boot/buildzbf.sh	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/boot/buildzbf.sh	2008-06-27 14:25:16.000000000 -0400
@@ -0,0 +1,3 @@
+#!/bin/sh
+gzip -c vmlinux.bin > vmlinux.bin.gz
+genzbf -l 0x90020000 -s 0x90020000 -a lxzf -o vmlinux.zbf vmlinux.bin.gz
diff -Naur linux-2.6.25.8/arch/mips/boot/devbuildenczbf.sh linux-2.6.25.8-clean/arch/mips/boot/devbuildenczbf.sh
--- linux-2.6.25.8/arch/mips/boot/devbuildenczbf.sh	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/boot/devbuildenczbf.sh	2008-10-31 17:57:44.000000000 -0400
@@ -0,0 +1,6 @@
+#!/bin/sh
+gzip -c vmlinux.bin > vmlinux.bin.gz
+tobin.bash `sha1sum -b vmlinux.bin.gz | awk '{ print $1 }'` > vmlinux_sha1.zbf
+sh build_cpu_xload.bash vmlinux_sha1 000b ES4_dev
+cat xrpc_xload_vmlinux_sha1_ES4_dev.bin vmlinux.bin.gz > vmlinux_enc.bin
+genzbf -l 0x90020000 -s 0x90020000 -e `stat --format=%s xrpc_xload_vmlinux_sha1_ES4_dev.bin` -a lzef -o devvmlinux_enc.zbf vmlinux_enc.bin
diff -Naur linux-2.6.25.8/arch/mips/boot/test.sh linux-2.6.25.8-clean/arch/mips/boot/test.sh
--- linux-2.6.25.8/arch/mips/boot/test.sh	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/boot/test.sh	2009-04-06 20:16:26.000000000 -0400
@@ -0,0 +1,6 @@
+#!/bin/sh
+./buildenczbf.sh
+cp vmlinux_enc.zbf /sage/smp86xx/build_mips/romfs/99vmlinux_enc.zbf
+cd /sage/smp86xx/build_mips/
+genromfs -d romfs -f 8634test.romfs
+cp 8634test.romfs /tftproot/
diff -Naur linux-2.6.25.8/arch/mips/configs/tango2_defconfig linux-2.6.25.8-clean/arch/mips/configs/tango2_defconfig
--- linux-2.6.25.8/arch/mips/configs/tango2_defconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/configs/tango2_defconfig	2008-06-27 16:08:09.000000000 -0400
@@ -0,0 +1,896 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Tue Mar  6 10:24:42 2007
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+CONFIG_TANGO2=y
+# CONFIG_TANGO3 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_TANGO2_SMP863X=y
+# CONFIG_TANGO2_ES1 is not set
+# CONFIG_TANGO2_ES2 is not set
+# CONFIG_TANGO2_ES3 is not set
+# CONFIG_TANGO2_ES4 is not set
+# CONFIG_TANGO2_ES5 is not set
+CONFIG_TANGO2_ES6=y
+
+#
+# 
+#
+CONFIG_TANGOX_HZ_VALUE=1000
+CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
+# CONFIG_TANGOX_IGNORE_CMDLINE is not set
+# CONFIG_TANGOX_PROM_CONSOLE is not set
+# CONFIG_TANGOX_FIXED_FREQUENCIES is not set
+# CONFIG_TANGOX_USE_CPU_CLOCK is not set
+# CONFIG_TANGOX_UART_USE_SYSCLK is not set
+CONFIG_TANGOX_USE_TLB_REMAP_DRAM1=y
+
+#
+# 
+#
+CONFIG_TANGOX_XENV_READ=y
+# CONFIG_TANGOX_XENV_DUMP is not set
+CONFIG_TANGOX_XENV_READ_SAFE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_TANGOX=y
+CONFIG_DMA_TANGOX=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_OWN_DMA=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
+CONFIG_MIPS_L1_CACHE_SHIFT=4
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+CONFIG_CPU_MIPS32_R2=y
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE="/tmp/CR/CR-26/"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+# CONFIG_SHMEM is not set
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=y
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="console=ttyS0"
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.25.8/arch/mips/configs/tango3_defconfig linux-2.6.25.8-clean/arch/mips/configs/tango3_defconfig
--- linux-2.6.25.8/arch/mips/configs/tango3_defconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/configs/tango3_defconfig	2008-06-27 16:08:09.000000000 -0400
@@ -0,0 +1,891 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15
+# Mon Oct 23 14:23:16 2006
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANGO2 is not set
+CONFIG_TANGO3=y
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_TANGO3_SMP865X=y
+CONFIG_TANGO3_ES1=y
+
+#
+# 
+#
+# CONFIG_TANGO3_DISABLE_HWFPU is not set
+CONFIG_TANGOX_HZ_VALUE=1000
+CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
+# CONFIG_TANGOX_IGNORE_CMDLINE is not set
+# CONFIG_TANGOX_PROM_CONSOLE is not set
+# CONFIG_TANGOX_FIXED_FREQUENCIES is not set
+# CONFIG_TANGOX_USE_CPU_CLOCK is not set
+# CONFIG_TANGOX_UART_USE_SYSCLK is not set
+
+#
+# 
+#
+CONFIG_TANGOX_XENV_READ=y
+# CONFIG_TANGOX_XENV_DUMP is not set
+CONFIG_TANGOX_XENV_READ_SAFE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_TANGOX=y
+CONFIG_DMA_TANGOX=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_OWN_DMA=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+CONFIG_CPU_MIPS32_R2=y
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE="/tmp/CR/CR-26/"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+# CONFIG_SHMEM is not set
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=y
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="console=ttyS0"
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.25.8/arch/mips/kernel/cpu-probe.c linux-2.6.25.8-clean/arch/mips/kernel/cpu-probe.c
--- linux-2.6.25.8/arch/mips/kernel/cpu-probe.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/kernel/cpu-probe.c	2008-06-26 14:59:44.000000000 -0400
@@ -613,7 +613,9 @@
 	if (config1 & MIPS_CONF1_EP)
 		c->options |= MIPS_CPU_EJTAG;
 	if (config1 & MIPS_CONF1_FP) {
+#ifndef CONFIG_TANGO3_DISABLE_HWFPU
 		c->options |= MIPS_CPU_FPU;
+#endif
 		c->options |= MIPS_CPU_32FPR;
 	}
 	if (cpu_has_tlb)
diff -Naur linux-2.6.25.8/arch/mips/kernel/head.S linux-2.6.25.8-clean/arch/mips/kernel/head.S
--- linux-2.6.25.8/arch/mips/kernel/head.S	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/kernel/head.S	2008-06-26 14:59:44.000000000 -0400
@@ -130,7 +130,7 @@
 
 EXPORT(_stext)
 
-#ifdef CONFIG_BOOT_RAW
+#if defined(CONFIG_BOOT_RAW) || defined (CONFIG_TANGOX)
 	/*
 	 * Give us a fighting chance of running if execution beings at the
 	 * kernel load address.  This is needed because this platform does
diff -Naur linux-2.6.25.8/arch/mips/kernel/mips_ksyms.c linux-2.6.25.8-clean/arch/mips/kernel/mips_ksyms.c
--- linux-2.6.25.8/arch/mips/kernel/mips_ksyms.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/kernel/mips_ksyms.c	2008-09-30 16:59:44.000000000 -0400
@@ -28,7 +28,7 @@
  * String functions
  */
 EXPORT_SYMBOL(memset);
-EXPORT_SYMBOL(memcpy);
+//EXPORT_SYMBOL(memcpy);
 EXPORT_SYMBOL(memmove);
 
 EXPORT_SYMBOL(kernel_thread);
diff -Naur linux-2.6.25.8/arch/mips/kernel/setup.c linux-2.6.25.8-clean/arch/mips/kernel/setup.c
--- linux-2.6.25.8/arch/mips/kernel/setup.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/kernel/setup.c	2008-06-26 14:59:44.000000000 -0400
@@ -32,6 +32,21 @@
 #include <asm/smp-ops.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/memcfg.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/memcfg.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/hardware.h>
+
+#include "../tangox/xenv.h"
+#include "../tangox/xenvkeys.h"
+#endif
+
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);
@@ -446,6 +461,13 @@
  */
 
 static int usermem __initdata = 0;
+#ifdef CONFIG_TANGOX
+	extern unsigned long em8xxx_kmem_start;
+	extern unsigned long em8xxx_kmem_size;
+#ifdef CONFIG_TANGO3
+	extern unsigned long max_remap_size;
+#endif
+#endif
 
 static int __init early_parse_mem(char *p)
 {
@@ -460,12 +482,46 @@
 		boot_mem_map.nr_map = 0;
 		usermem = 1;
  	}
+#ifdef CONFIG_TANGOX
+	start = CPHYSADDR(em8xxx_kmem_start);
+#else
 	start = 0;
+#endif
 	size = memparse(p, &p);
 	if (*p == '@')
 		start = memparse(p + 1, &p);
 
+#ifdef CONFIG_TANGOX
+	if (start == CPHYSADDR(em8xxx_kmem_start)) {
+		unsigned long em8xxx_kmem_end;
+#ifdef CONFIG_TANGO3
+		em8xxx_kmem_size = ((mem_size + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+
+		if (em8xxx_kmem_size > max_remap_size)
+			em8xxx_kmem_size = max_remap_size;
+
+		add_memory_region(start, em8xxx_kmem_size, BOOT_MEM_RAM);
+		em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(CPU_REMAP_SPACE);
+
+		/* Update information into LR_XENV2_RW */
+		xenv_set((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_KERNEL_END, &em8xxx_kmem_end, 0, sizeof(em8xxx_kmem_end)); 
+#else
+		memcfg_t *m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+
+		em8xxx_kmem_size = ((size + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+		add_memory_region(start, em8xxx_kmem_size, BOOT_MEM_RAM);
+
+		em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(MEM_BASE_dram_controller_0_alias);
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+#endif
+	} else {
+		/* We just add this blindly as the alignment can be wrong, use it as own risk */
+		add_memory_region(start, size, BOOT_MEM_RAM);
+	}
+#else
 	add_memory_region(start, size, BOOT_MEM_RAM);
+#endif
 	return 0;
 }
 early_param("mem", early_parse_mem);
diff -Naur linux-2.6.25.8/arch/mips/kernel/traps.c linux-2.6.25.8-clean/arch/mips/kernel/traps.c
--- linux-2.6.25.8/arch/mips/kernel/traps.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/kernel/traps.c	2008-06-26 14:59:44.000000000 -0400
@@ -43,6 +43,17 @@
 #include <asm/types.h>
 #include <asm/stacktrace.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango3/hardware.h>
+#endif
+
+
 extern asmlinkage void handle_int(void);
 extern asmlinkage void handle_tlbm(void);
 extern asmlinkage void handle_tlbl(void);
@@ -1342,6 +1353,15 @@
 	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
+#ifdef CONFIG_TANGOX
+#ifdef CONFIG_TANGO3
+	ebase = KSEG0ADDR(CPU_REMAP_SPACE);
+#else
+	ebase = KSEG0ADDR(MEM_BASE_dram_controller_0_alias + FM_RESERVED);
+#endif
+	write_c0_ebase(ebase);
+#endif
+
 #ifdef CONFIG_CPU_MIPSR2
 	if (cpu_has_mips_r2) {
 		unsigned int enable = 0x0000000f;
@@ -1386,7 +1406,10 @@
 		cp0_compare_irq = CP0_LEGACY_COMPARE_IRQ;
 		cp0_perfcount_irq = -1;
 	}
-
+    printk("cp0_compare : %d cp0_perf : %d intctl : %08X\n",cp0_compare_irq, cp0_perfcount_irq, read_c0_intctl());
+#ifdef CONFIG_TANGOX
+	cp0_compare_irq = 7;
+#endif
 #ifdef CONFIG_MIPS_MT_SMTC
 	}
 #endif /* CONFIG_MIPS_MT_SMTC */
@@ -1567,6 +1590,15 @@
 
 	set_except_vector(26, handle_dsp);
 
+#ifdef CONFIG_TANGOX
+	if (cpu_has_vce)
+		/* Special exception: R4[04]00 uses also the divec space. */
+		memcpy((void *)(ebase + 0x180), &except_vec3_r4000, 0x100);
+	else if (cpu_has_4kex)
+		memcpy((void *)(ebase + 0x180), &except_vec3_generic, 0x80);
+	else
+		memcpy((void *)(ebase + 0x080), &except_vec3_generic, 0x80);
+#else
 	if (cpu_has_vce)
 		/* Special exception: R4[04]00 uses also the divec space. */
 		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_r4000, 0x100);
@@ -1574,6 +1606,7 @@
 		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
 	else
 		memcpy((void *)(CAC_BASE + 0x080), &except_vec3_generic, 0x80);
+#endif
 
 	signal_init();
 #ifdef CONFIG_MIPS32_COMPAT
diff -Naur linux-2.6.25.8/arch/mips/lib/memcpy.S linux-2.6.25.8-clean/arch/mips/lib/memcpy.S
--- linux-2.6.25.8/arch/mips/lib/memcpy.S	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/arch/mips/lib/memcpy.S	2008-09-30 13:01:19.000000000 -0400
@@ -189,7 +189,7 @@
  * memcpy sets v0 to dst.
  */
 	.align	5
-LEAF(memcpy)					/* a0=dst a1=src a2=len */
+LEAF(memcpy2)					/* a0=dst a1=src a2=len */
 	move	v0, dst				/* return value */
 .L__memcpy:
 FEXPORT(__copy_user)
@@ -428,7 +428,7 @@
 .Ldone:
 	jr	ra
 	 nop
-	END(memcpy)
+	END(memcpy2)
 
 .Ll_exc_copy:
 	/*
diff -Naur linux-2.6.25.8/arch/mips/tangox/Kconfig linux-2.6.25.8-clean/arch/mips/tangox/Kconfig
--- linux-2.6.25.8/arch/mips/tangox/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/Kconfig	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,296 @@
+
+#
+# environnent selection
+#
+
+config TANGO2_SMP863X
+	bool
+
+config TANGO3_SMP865X
+	bool
+
+#
+# chip revision selection
+#
+choice
+	prompt "SMP863x chip revision"
+	depends on TANGO2_SMP863X
+	default TANGO2_ES6
+
+config TANGO2_ES1
+	bool "ES1"
+
+config TANGO2_ES2
+	bool "ES2"
+
+config TANGO2_ES3
+	bool "ES3"
+
+config TANGO2_ES4
+	bool "ES4"
+
+config TANGO2_ES5
+	bool "ES5"
+
+config TANGO2_ES6
+	bool "ES6+"
+
+config TANGO2_SD
+	bool "SD revision (SMP8632/SMP8710)"
+
+endchoice
+
+choice
+	prompt "SMP865x chip revision"
+	depends on TANGO3_SMP865X
+	default TANGO3_ES1
+
+config TANGO3_ES1
+	bool "ES1"
+
+config TANGO3_ES2
+	bool "ES2"
+
+config TANGO3_ES3
+	bool "ES3"
+
+endchoice
+
+config TANGO3_DISABLE_HWFPU
+	bool "Disable HW FPU"
+	depends on TANGO3_SMP865X && TANGO3
+	default n
+	help
+	 Disable HW FPU, and use SW FPU emulation.
+
+config TANGOX_HZ_VALUE
+	int "customized HZ value"
+	depends on TANGOX
+	default 100 if TANGO2_SD || TANGO3
+	default 1000 if !(TANGO2_SD || TANGO3)
+	help
+	 For TangoX, the HZ value can be customized, normally it's between 100-1000.
+
+config TANGOX_SYSTEMRAM_ACTUALSIZE
+	int "System RAM size (in MB)"
+	depends on TANGO2_SMP863X || TANGO3_SMP865X
+	default 64
+	help
+	 This is the default amount of RAM available to the Linux kernel. It can be
+	 override with "mem=" command line option.
+
+
+config TANGOX_IGNORE_CMDLINE
+	bool "Ignore YAMON, XENV & memcfg command line"
+	depends on TANGO2_SMP863X || TANGO3_SMP865X
+	default n
+	help
+	 If you say  yes, boot command line from  YAMON, XENV & memcfg
+	 will be ignored. You can then use CONFIG_CMDLINE to force the
+	 kernel command line.
+
+
+config TANGOX_PROM_CONSOLE
+	bool "Register an early console"
+	depends on TANGO2_SMP863X || TANGO3_SMP865X
+	default n
+	help
+	 If you say yes, an light console will be available very early
+	 in the  boot process,  this is useful  if the  kernel crashes
+	 before reaching  the main console  code. The console  will be
+	 automatically replaced by the normal one after.
+	 ### NOTE: This console can only do output ###
+
+config TANGOX_FIXED_FREQUENCIES
+	bool "Specified fixed frequencies"
+	depends on TANGO2_SMP863X || TANGO3_SMP865X
+	default n if TANGO2_SMP863X
+	default y if TANGO3_SMP865X
+	help
+	 To specify, statically, the frequencies for CPU, System, and Base.
+	 Normally this is only used in experimental purpose where PLL may be
+	 set differently (typical for simulation or FPGA).
+
+config TANGOX_BASE_FREQUENCY
+	int "Base Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 27000000
+	help
+	 Base frequency (corresponding to XTAL in).
+
+config TANGOX_CPU_FREQUENCY
+	int "CPU Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 300000000
+	help
+	 CPU frequency.
+
+config TANGOX_SYS_FREQUENCY
+	int "System Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 200000000
+	help
+	 System frequency.
+
+config TANGOX_USE_CPU_CLOCK
+	bool "Use internal cpu clock for system timer"
+	depends on TANGO2_SMP863X || TANGO3_SMP865X
+	default y
+	help
+	 If you say  yes here, the mips timer  interrupt (IP7) will be
+	 used as the  Linux timer interrupt. Timer0 can  be used as an
+	 alternative.
+
+config TANGOX_UART_USE_SYSCLK
+	bool "Use system clock for UART"
+	depends on TANGO2_SMP863X || TANGO3_SMP865X
+	default y
+	help
+	 If you  say yes here, the UART  clock will be  derivated from the
+	 board  system clock. If  you say  no, the  CPU clock  is used
+	 instead.
+
+config TANGOX_USE_TLB_REMAP_DRAM1
+	bool "Use TLB to access DRAM1"
+	depends on TANGO2_SMP863X 
+	default n
+	help
+	 If  you say yes  here, kernel  access to  DRAM1 will  be done
+	 using TLB implementation. gbus() funcs will use an ioremapped
+	 address to access this area of memory. If you say no, special
+	 CPU remap registers are used instead.
+
+#
+# XENV stuffs
+#
+
+config TANGOX_XENV_READ
+	bool "Read config from XENV"
+	depends on TANGO2_SMP863X || TANGO3_SMP865X
+	help
+	 If you  say yes  here, board configuration  (enabled devices,
+	 pci irq routing,  ...) will be read from  xenv space.
+
+config TANGOX_XENV_DUMP
+	bool "Dump XENV content at boot"
+	depends on TANGOX_XENV_READ
+	default n
+
+config TANGOX_XENV_READ_SAFE
+	bool "Don't boot if XENV invalid"
+	depends on TANGOX_XENV_READ
+	help
+	 If you say yes here and XENV content is invalid, linux wont boot.
+
+menu "XENV failsafe/override values"
+	depends on (TANGO2_SMP863X || TANGO3_SMP865X) && (!TANGOX_XENV_READ_SAFE)
+
+config TANGOX_XENV_DEF_CS0_SIZE
+	hex "CS0 size (flash0)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS1_SIZE
+	hex "CS1 size (flash1)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS2_SIZE
+	hex "CS2 size (flash2)"
+	default 0x400000
+
+config TANGOX_XENV_DEF_CS3_SIZE
+	hex "CS3 size (flash3)"
+	default 0x0
+
+config TANGOX_XENV_DEF_UART0
+	bool "UART0 enabled"
+	default y
+
+config TANGOX_XENV_DEF_UART1
+	bool "UART1 enabled"
+	default y
+
+config TANGOX_XENV_DEF_BAUDRATE
+	int "Default baudrate"
+	default 115200
+
+config TANGOX_XENV_DEF_CONSOLE_UART_PORT
+	int "Console UART port"
+	default 0
+
+config TANGOX_XENV_DEF_ENET
+	bool "Ethernet enabled"
+	default n
+
+config TANGOX_XENV_DEF_FIP
+	bool "FIP enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CM
+	bool "I2CM enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CS
+	bool "I2CS enabled"
+	default n
+
+config TANGOX_XENV_DEF_BMIDE
+	bool "BM IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_ISAIDE
+	bool "ISA IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_IR
+	bool "IR enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCIHOST
+	bool "PCI Host enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1
+	bool "PCI device 1 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1_IRQ
+	hex "PCI device 1 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID1
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID2
+	bool "PCI device 2 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID2_IRQ
+	hex "PCI device 2 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID2
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID3
+	bool "PCI device 3 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID3_IRQ
+	hex "PCI device 3 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID3
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID4
+	bool "PCI device 4 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID4_IRQ
+	hex "PCI device 4 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID4
+	default 0x0
+
+config TANGOX_XENV_DEF_USB
+	bool "USB enabled"
+	default n
+
+endmenu
diff -Naur linux-2.6.25.8/arch/mips/tangox/Makefile linux-2.6.25.8-clean/arch/mips/tangox/Makefile
--- linux-2.6.25.8/arch/mips/tangox/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/Makefile	2008-06-27 10:36:51.000000000 -0400
@@ -0,0 +1,16 @@
+#
+# Makefile for SigmaDesigns Tango2/Tango3 board
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y += irq.o setup.o prom.o gbus.o xenv_config.o delay.o platform.o
+
+obj-$(CONFIG_TANGOX_PROM_CONSOLE) += console.o
+
+obj-$(CONFIG_TANGOX_XENV_READ) += sha.o xenv.o
+
+obj-y += mbus.o
+
diff -Naur linux-2.6.25.8/arch/mips/tangox/console.c linux-2.6.25.8-clean/arch/mips/tangox/console.c
--- linux-2.6.25.8/arch/mips/tangox/console.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/console.c	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,114 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * simple  uart support for  tango2/tango3 board,  register an  early console
+ * that make boot problem easier to debug.
+ *
+ * this uart init code comes from zboot
+ */
+
+#include <linux/init.h>
+#include <linux/console.h>
+
+
+
+#include "setup.h"
+
+extern int tangox_uart_console_port(void);
+
+/*
+ * helpers to access uart0/uart1 register
+ */
+#define RD_UART_REG32(r)	\
+	(tangox_uart_console_port() ? \
+		gbus_readl(REG_BASE_cpu_block + CPU_UART1_base + (r)) : \
+		gbus_readl(REG_BASE_cpu_block + CPU_UART0_base + (r)))
+
+#define WR_UART_REG32(r, v)	\
+	(tangox_uart_console_port() ? \
+		gbus_writel(REG_BASE_cpu_block + CPU_UART1_base + (r), (v)) : \
+		gbus_writel(REG_BASE_cpu_block + CPU_UART0_base + (r), (v)))
+
+/*
+ * print given char to uart0/uart1
+ */
+static void __init prom_putc(char c)
+{
+	/* if '\n', then print '\r' also */
+	if (c == '\n') {
+		prom_putc('\r');
+	}
+
+	while ((RD_UART_REG32(CPU_UART_LSR) & 0x20) == 0);
+	WR_UART_REG32(CPU_UART_THR, (unsigned long)c);
+	while ((RD_UART_REG32(CPU_UART_LSR) & 0x20) == 0);
+}
+
+/*
+ * print given string to uart0/uart1
+ */
+void __init prom_puts(const char *s)
+{
+	while (*s)
+		prom_putc(*s++);
+}
+
+/*
+ * initialize uart0/uart1 with given parameters
+ */
+static void __init uart_init(int baud, int fifo)
+{
+	WR_UART_REG32(CPU_UART_IER, 0x0);
+	WR_UART_REG32(CPU_UART_FCR, (fifo ? 0x1f : 0x0));
+	WR_UART_REG32(CPU_UART_LCR, 0x3);
+
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	WR_UART_REG32(CPU_UART_CLKSEL, 0x0);
+	WR_UART_REG32(CPU_UART_CLKDIV, ((tangox_get_sysclock() / baud) >> 4) + 1);
+#else
+	WR_UART_REG32(CPU_UART_CLKSEL, 0x1);
+	WR_UART_REG32(CPU_UART_CLKDIV, ((TANGOX_BASE_FREQUENCY / baud) >> 4) + 1);
+#endif
+}
+
+/*
+ * kernel console write callback
+ */
+static void __init prom_console_write(struct console *con, const char *s,
+				      unsigned int c)
+{
+	while(c>0)
+	{
+		prom_putc(*s++);
+		c--;
+	}
+}
+
+static struct console promcons __initdata = {
+	.name   = "prom",
+	.write  = prom_console_write,
+	.flags  = CON_PRINTBUFFER | CON_BOOT,
+	.index  = -1,
+};
+
+/*
+ * init uart0/uart1 and register a console that will use our prom console
+ * callbacks
+ */
+extern int tangox_uart_baudrate(int uart);
+
+void __init prom_console_register(void)
+{
+	uart_init(tangox_uart_baudrate(tangox_uart_console_port()), 0);
+	register_console(&promcons);
+
+	/* hello world ! */
+	printk(KERN_INFO "prom console registered\n");
+}
+
diff -Naur linux-2.6.25.8/arch/mips/tangox/delay.c linux-2.6.25.8-clean/arch/mips/tangox/delay.c
--- linux-2.6.25.8/arch/mips/tangox/delay.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/delay.c	2008-08-27 20:49:06.000000000 -0400
@@ -0,0 +1,57 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * arch/mips/tangox/delay.c
+ *
+ * Copyright (C) 2003-2007 Sigma Designs, Inc.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+
+#include "setup.h"
+
+static inline unsigned long tangox_getxtal(void)
+{
+	return(gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt));
+}
+
+/* This is the replacement of Linux's udelay. */
+void tangox_udelay(unsigned usec)
+{
+	/* SYS_xtal_in_cnt is a counter running off 27MHz, so 1 usec
+           is roughly equivalent to 27 increase of count */
+	unsigned long start = tangox_getxtal();
+	unsigned long end = start + (usec * 27);
+
+    if (end > start)
+        while (tangox_getxtal() < end && tangox_getxtal() > start);
+    else {
+    /* Handle overflow condition */
+        while (! (tangox_getxtal() > end && tangox_getxtal() < start));
+    }
+}
+
+void tangox_syncwith_xtal(unsigned long *mark, unsigned usec)
+{
+	unsigned long end = *mark + (usec * 27);
+	if (end > *mark)
+		/* Handle overflow condition */
+		while (tangox_getxtal() > *mark);
+	while (tangox_getxtal() < end);
+	*mark = end;
+}
+
+EXPORT_SYMBOL(tangox_udelay);
+
diff -Naur linux-2.6.25.8/arch/mips/tangox/gbus.c linux-2.6.25.8-clean/arch/mips/tangox/gbus.c
--- linux-2.6.25.8/arch/mips/tangox/gbus.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/gbus.c	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,280 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * export gbus symbol to modules
+ */
+
+#include <linux/module.h>
+#include <asm/system.h>
+
+#include "setup.h"
+
+#define TMP_REMAPPED_REG   CPU_remap1
+#define TMP_REMAPPED_BASE  CPU_remap1_address
+#define TMP_REMAPPED_SIZE  0x00010000
+#define TMP_REMAPPED_MASK  ~(TMP_REMAPPED_SIZE-1)
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+unsigned long em86xx_tlb_dram1_map_base;
+unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+static RMuint32 set_remap(RMuint32 remap_reg, RMuint32 value)
+{
+	RMuint32 orig = *((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg));
+	if (orig != value) {
+		*((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg)) = value;
+		iob();
+	}
+	return(orig);
+}
+
+#ifdef CONFIG_TANGO3
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	extern unsigned long phy_remap, max_remap_size;							\
+	if (byte_address < CPU_remap2_address)								\
+		return *((volatile RMuint##size *)KSEG1ADDR(byte_address)); 				\
+	else if ((byte_address >= phy_remap) && (byte_address < (phy_remap + max_remap_size)))		\
+		return *((volatile RMuint##size *)KSEG1ADDR(CPU_REMAP_SPACE + (byte_address - phy_remap))); 	\
+	else {												\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);			\
+		tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 				\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+		set_remap(TMP_REMAPPED_REG, remap);							\
+		local_irq_restore(flags);								\
+		return(tmp);										\
+	}												\
+}
+
+BUILD_GBUS_READ_OP(32);
+BUILD_GBUS_READ_OP(16);
+BUILD_GBUS_READ_OP(8);
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	extern unsigned long phy_remap, max_remap_size;							\
+	if (byte_address < CPU_remap2_address)								\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data;				\
+	else if ((byte_address >= phy_remap) && (byte_address < (phy_remap + max_remap_size)))		\
+		*((volatile RMuint##size *)KSEG1ADDR(CPU_REMAP_SPACE + (byte_address - phy_remap))) = data;	\
+	else {												\
+		unsigned long flags;									\
+		local_irq_save(flags); /* Ensure remap won't be changed */				\
+		/* Use CPU_remapx to temporarily map the address */					\
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);			\
+		*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 				\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+		__sync();										\
+		set_remap(TMP_REMAPPED_REG, remap);							\
+		local_irq_restore(flags);								\
+	}												\
+	iob();												\
+}
+
+BUILD_GBUS_WRITE_OP(32);
+BUILD_GBUS_WRITE_OP(16);
+BUILD_GBUS_WRITE_OP(8);
+
+#else /* CONFIG_TANGO3 */
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address)
+{
+	RMuint32 remap;
+	RMuint32 tmp;
+
+	if (byte_address < (MEM_BASE_dram_controller_0_alias + 0x10000000))
+		return gbus_read_dram_uint32(pgbus, byte_address);
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))
+			return gbus_read_dram_uint32(pgbus, byte_address);
+		else {
+			printk("accessing non-existed DRAM1 area 0x%08lx\n", byte_address);
+			return(0);
+		}
+#else
+		return gbus_read_dram_uint32(pgbus, byte_address);
+#endif
+	else {
+		unsigned long flags;
+		local_irq_save(flags); // Ensure remap won't be changed 
+		// Use CPU_remapx to temporarily map the address
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);
+		tmp = *((volatile RMuint32 *)KSEG1ADDR(TMP_REMAPPED_BASE + (byte_address & (TMP_REMAPPED_SIZE-1))));
+		set_remap(TMP_REMAPPED_REG, remap);
+		local_irq_restore(flags);
+		return(tmp);
+	}
+}
+
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address)
+{
+	RMuint32 remap;
+	RMuint16 tmp;
+
+	if (byte_address < (MEM_BASE_dram_controller_0_alias + 0x10000000))
+		return gbus_read_dram_uint16(pgbus, byte_address);
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))
+			return gbus_read_dram_uint16(pgbus, byte_address);
+		else {
+			printk("accessing non-existed DRAM1 area 0x%08lx\n", byte_address);
+			return(0);
+		}
+#else
+		return gbus_read_dram_uint16(pgbus, byte_address);
+#endif
+	else {
+		unsigned long flags;
+		local_irq_save(flags); // Ensure remap won't be changed 
+		// Use CPU_remapx to temporarily map the address
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);
+		tmp = *((volatile RMuint16 *)KSEG1ADDR(TMP_REMAPPED_BASE + (byte_address & (TMP_REMAPPED_SIZE-1))));
+		set_remap(TMP_REMAPPED_REG, remap);
+		local_irq_restore(flags);
+		return(tmp & 0xffff);
+	}
+}
+
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address)
+{
+	RMuint32 remap;
+	RMuint8 tmp;
+
+	if (byte_address < (MEM_BASE_dram_controller_0_alias + 0x10000000))
+		return gbus_read_dram_uint8(pgbus, byte_address);
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))
+			return gbus_read_dram_uint8(pgbus, byte_address);
+		else {
+			printk("accessing non-existed DRAM1 area 0x%08lx\n", byte_address);
+			return(0);
+		}
+#else
+		return gbus_read_dram_uint8(pgbus, byte_address);
+#endif
+	else {
+		unsigned long flags;
+		local_irq_save(flags); // Ensure remap won't be changed 
+		// Use CPU_remapx to temporarily map the address
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);
+		tmp = *((volatile RMuint8 *)KSEG1ADDR(TMP_REMAPPED_BASE + (byte_address & (TMP_REMAPPED_SIZE-1))));
+		set_remap(TMP_REMAPPED_REG, remap);
+		local_irq_restore(flags);
+		return(tmp & 0xff);
+	}
+}
+
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data)
+{
+	RMuint32 remap;
+
+	if (byte_address < (MEM_BASE_dram_controller_0_alias + 0x10000000))
+		gbus_write_dram_uint32(pgbus, byte_address, data);
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))
+			gbus_write_dram_uint32(pgbus, byte_address, data);
+		else 
+			printk("accessing non-existed DRAM1 area 0x%08lx.\n", byte_address);
+#else
+		gbus_write_dram_uint32(pgbus, byte_address, data);
+#endif
+	else {
+		unsigned long flags;
+		local_irq_save(flags); // Ensure remap won't be changed 
+		// Use CPU_remapx to temporarily map the address
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);
+		*((volatile RMuint32 *)KSEG1ADDR(TMP_REMAPPED_BASE + (byte_address & (TMP_REMAPPED_SIZE-1)))) = data;
+		set_remap(TMP_REMAPPED_REG, remap);
+		local_irq_restore(flags);
+	}
+	__sync();
+}
+
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data)
+{
+	RMuint32 remap;
+
+	if (byte_address < (MEM_BASE_dram_controller_0_alias + 0x10000000))
+		gbus_write_dram_uint16(pgbus, byte_address, data);
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))
+			gbus_write_dram_uint16(pgbus, byte_address, data);
+		else 
+			printk("accessing non-existed DRAM1 area 0x%08lx.\n", byte_address);
+#else
+		gbus_write_dram_uint16(pgbus, byte_address, data);
+#endif
+	else {
+		unsigned long flags;
+		local_irq_save(flags); // Ensure remap won't be changed 
+		// Use CPU_remapx to temporarily map the address
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);
+		*((volatile RMuint16 *)KSEG1ADDR(TMP_REMAPPED_BASE + (byte_address & (TMP_REMAPPED_SIZE-1)))) = (data & 0xffff);
+		set_remap(TMP_REMAPPED_REG, remap);
+		local_irq_restore(flags);
+	}
+	__sync();
+}
+
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data)
+{
+	RMuint32 remap;
+
+	if (byte_address < (MEM_BASE_dram_controller_0_alias + 0x10000000))
+		gbus_write_dram_uint8(pgbus, byte_address, data);
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))
+			gbus_write_dram_uint8(pgbus, byte_address, data);
+		else 
+			printk("accessing non-existed DRAM1 area 0x%08lx.\n", byte_address);
+#else
+		gbus_write_dram_uint8(pgbus, byte_address, data);
+#endif
+	else {
+		unsigned long flags;
+		local_irq_save(flags); // Ensure remap won't be changed 
+		// Use CPU_remapx to temporarily map the address
+		remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);
+		*((volatile RMuint8 *)KSEG1ADDR(TMP_REMAPPED_BASE + (byte_address & (TMP_REMAPPED_SIZE-1)))) = (data & 0xff);
+		set_remap(TMP_REMAPPED_REG, remap);
+		local_irq_restore(flags);
+	}
+	__sync();
+}
+
+#endif /* CONFIG_TANGO3 */
+
+EXPORT_SYMBOL(gbus_read_uint32);
+EXPORT_SYMBOL(gbus_write_uint32);
+EXPORT_SYMBOL(gbus_read_uint16);
+EXPORT_SYMBOL(gbus_write_uint16);
+EXPORT_SYMBOL(gbus_read_uint8);
+EXPORT_SYMBOL(gbus_write_uint8);
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_base);
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_size);
+#endif
+
diff -Naur linux-2.6.25.8/arch/mips/tangox/irq.c linux-2.6.25.8-clean/arch/mips/tangox/irq.c
--- linux-2.6.25.8/arch/mips/tangox/irq.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/irq.c	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,490 @@
+/*
+ * Copyright (C) 2007 Sigma Designs, inc.
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * arch_init_irq for tango2/tango3.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq_cpu.h>
+
+#include "setup.h"
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)	\
+		gbus_readl(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		gbus_writel(REG_BASE_cpu_block + (r), (v))
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+static inline u64 get_irq_status(void)
+{
+	return((((u64)RD_CPU_REG32(CPU_irq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_irq_status)));
+}
+static inline u64 get_fiq_status(void)
+{
+	return((((u64)RD_CPU_REG32(CPU_fiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_fiq_status)));
+}
+static inline u64 get_iiq_status(void)
+{
+	return((((u64)RD_CPU_REG32(CPU_iiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_iiq_status)));
+}
+#else
+static inline u32 get_irq_status(void)
+{
+	return((u32)RD_CPU_REG32(CPU_irq_status));
+}
+static inline u32 get_fiq_status(void)
+{
+	return((u32)RD_CPU_REG32(CPU_fiq_status));
+}
+static inline u32 get_iiq_status(void)
+{
+	return((u32)RD_CPU_REG32(CPU_iiq_status));
+}
+#endif
+
+/*
+ * dispatch routine called from tangoxIRQ.S
+ */
+extern void spurious_interrupt(void);
+void tangox_dispatch(int ipline)
+{
+	int x;
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	u64 status;
+#else
+	u32 status;
+#endif
+
+	switch (ipline) {
+	case 2:
+		if ((status = get_irq_status()) == 0) {
+			spurious_interrupt();
+			return;
+		} else {
+			do {
+				for (x = 0; status != 0; x++, status >>= 1) {
+					if ((status & 0x1) != 0) {
+						do_IRQ(IRQ_CONTROLLER_IRQ_BASE + x);
+						break;
+					}
+				}
+			} while ((status = get_irq_status()) != 0);
+		}
+		break;
+
+	case 3:
+		if ((status = get_fiq_status()) == 0) {
+			spurious_interrupt();
+			return;
+		} else {
+			/* We need to mask out irq, fiq > irq */
+			u32 sr_old = read_c0_status();
+			u32 sr_new = sr_old & (~STATUSF_IP2);
+
+			write_c0_status(sr_new);
+			do {
+				for (x = 0; status != 0; x++, status >>= 1) {
+					if ((status & 0x1) != 0) {
+						do_IRQ(FIQ_CONTROLLER_IRQ_BASE + x);
+						break;
+					}
+				}
+			} while ((status = get_fiq_status()) != 0);
+			write_c0_status(sr_old);
+		}
+		break;
+
+	case 4:
+		if ((status = get_iiq_status()) == 0) {
+			spurious_interrupt();
+			return;
+		} else {
+			/* We need to mask out fiq/irq, iiq > fiq > irq */
+			u32 sr_old = read_c0_status();
+			u32 sr_new = sr_old & (~(STATUSF_IP2|STATUSF_IP3));
+
+			write_c0_status(sr_new);
+			do {
+				for (x = 0; status != 0; x++, status >>= 1) {
+					if ((status & 0x1) != 0) {
+						do_IRQ(IIQ_CONTROLLER_IRQ_BASE + x);
+						break;
+					}
+				}
+			} while ((status = get_iiq_status()) != 0);
+			write_c0_status(sr_old);
+		}
+		break;
+
+	case 7:
+		do_IRQ(7);
+		return;
+
+	default:
+		printk("spurious irq: ipline: %d\n", ipline);
+		spurious_interrupt();
+		return;
+	}
+}
+
+/*
+ * our hw_irq_controller cb
+ */
+static inline void tangox_irq_enable(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_irq_enableset_hi, 1 << (bit - 32));
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_irq_enableset, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_fiq_enable(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_fiq_enableset_hi, 1 << (bit - 32));
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_fiq_enableset, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_iiq_enable(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_iiq_enableset_hi, 1 << (bit - 32));
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_iiq_enableset, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_irq_disable(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_irq_enableclr_hi, 1 << (bit - 32));
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_irq_enableclr, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_fiq_disable(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_fiq_enableclr_hi, 1 << (bit - 32));
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_fiq_enableclr, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static inline void tangox_iiq_disable(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	local_irq_save(flags);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_iiq_enableclr_hi, 1 << (bit - 32));
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_iiq_enableclr, 1 << bit);
+	local_irq_restore(flags);
+}
+
+static unsigned int tangox_irq_startup(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+		tangox_irq_enable(x);
+		return 0;
+	}
+#endif
+
+	WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+
+	tangox_irq_enable(x);
+
+	return 0;
+}
+
+static unsigned int tangox_fiq_startup(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+		tangox_fiq_enable(x);
+		return 0;
+	}
+#endif
+
+	WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+
+	tangox_fiq_enable(x);
+
+	return 0;
+}
+
+static unsigned int tangox_iiq_startup(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+		tangox_iiq_enable(x);
+		return 0;
+	}
+#endif
+
+	WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+
+	tangox_iiq_enable(x);
+
+	return 0;
+}
+
+#define	tangox_irq_shutdown tangox_irq_disable
+#define	tangox_fiq_shutdown tangox_fiq_disable
+#define	tangox_iiq_shutdown tangox_iiq_disable
+
+static void tangox_irq_ack(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+
+	tangox_irq_disable(x);
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+}
+
+static void tangox_fiq_ack(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_fiq_disable(x);
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+}
+
+static void tangox_iiq_ack(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_iiq_disable(x);
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+		return;
+	}
+#endif
+	WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+}
+
+static void tangox_irq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_irq_enable(x);
+}
+
+static void tangox_fiq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_fiq_enable(x);
+}
+
+static void tangox_iiq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_iiq_enable(x);
+}
+
+/*
+ * our hw_irq_controller
+ */
+static struct irq_chip tangox_irq_controller = {
+	.typename = "tangox_irq",
+	.ack = tangox_irq_ack,
+	.mask = tangox_irq_disable,
+	.mask_ack = tangox_irq_ack,
+	.unmask = tangox_irq_enable,
+	.end = tangox_irq_end,
+};
+
+static struct irq_chip tangox_fiq_controller = {
+	.typename = "tangox_fiq",
+	.ack = tangox_fiq_ack,
+	.mask = tangox_fiq_disable,
+	.mask_ack = tangox_fiq_ack,
+	.unmask = tangox_fiq_enable,
+	.end = tangox_fiq_end,
+};
+
+static struct irq_chip tangox_iiq_controller = {
+	.typename = "tangox_iiq",
+	.ack = tangox_iiq_ack,
+	.mask = tangox_iiq_disable,
+	.mask_ack = tangox_iiq_ack,
+	.unmask = tangox_iiq_enable,
+	.end = tangox_iiq_end,
+};
+
+static struct irqaction irq_cascade = {
+	no_action, 0, { { 0, } }, "cascade", NULL, NULL
+};
+
+void __init arch_init_irq(void)
+{
+	unsigned long x;
+	unsigned long rise = 0;
+	unsigned long fall = 0;
+	unsigned long edge_trig = 0;
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	unsigned long rise_hi = 0;
+	unsigned long fall_hi = 0;
+	unsigned long edge_trig_hi = 0;
+#endif
+
+	/* this hooks except_vec0 to tangox assembly routine */
+	//set_except_vector(0, tangoxIRQ);
+
+	/* irq_desc entries 0..7 */
+	mips_cpu_irq_init();
+
+	for (x = IRQ_CONTROLLER_IRQ_BASE; x < IRQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		set_irq_chip(x, &tangox_irq_controller);
+	}
+
+	for (x = FIQ_CONTROLLER_IRQ_BASE; x < FIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		set_irq_chip(x, &tangox_fiq_controller);
+	}
+
+	for (x = IIQ_CONTROLLER_IRQ_BASE; x < IIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		set_irq_chip(x, &tangox_iiq_controller);
+	}
+
+	setup_irq(MIPS_CPU_IRQ_BASE + 2, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 3, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 4, &irq_cascade);
+
+	WR_CPU_REG32(CPU_irq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr, 0xffffffff);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	WR_CPU_REG32(CPU_irq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr_hi, 0xffffffff);
+#endif
+
+	rise = RD_CPU_REG32(CPU_edge_config_rise);
+	fall = RD_CPU_REG32(CPU_edge_config_fall);
+	edge_trig = rise ^ fall;
+	WR_CPU_REG32(CPU_edge_rawstat, edge_trig);
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	rise_hi = RD_CPU_REG32(CPU_edge_config_rise_hi);
+	fall_hi = RD_CPU_REG32(CPU_edge_config_fall_hi);
+	edge_trig_hi = rise_hi ^ fall_hi;
+	WR_CPU_REG32(CPU_edge_rawstat_hi, edge_trig_hi);
+#endif
+
+	return;
+}
+
+asmlinkage void plat_irq_dispatch()
+{
+	unsigned int pending = read_c0_status() & read_c0_cause();
+	if (pending & STATUSF_IP7)			/* cpu timer */
+		do_IRQ(7);
+	else if (pending & STATUSF_IP6)			/* cpu timer */
+		tangox_dispatch(6);
+	else if (pending & STATUSF_IP5)			/* cpu timer */
+		tangox_dispatch(5);
+	else if (pending & STATUSF_IP4)			/* cpu timer */
+		tangox_dispatch(4);
+	else if (pending & STATUSF_IP3)			/* cpu timer */
+		tangox_dispatch(3);
+	else if (pending & STATUSF_IP2)			/* cpu timer */
+		tangox_dispatch(2);
+	else if (pending & STATUSF_IP1)			/* cpu timer */
+		tangox_dispatch(1);
+	else if (pending & STATUSF_IP0)			/* cpu timer */
+		tangox_dispatch(0);
+	else
+		spurious_interrupt();
+}
diff -Naur linux-2.6.25.8/arch/mips/tangox/mbus.c linux-2.6.25.8-clean/arch/mips/tangox/mbus.c
--- linux-2.6.25.8/arch/mips/tangox/mbus.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/mbus.c	2009-01-19 15:28:01.000000000 -0500
@@ -0,0 +1,1373 @@
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/* Modified version by Jean-Francois Thibert <jeanfrancois@sagetv.com>
+- Added copy from userspace optimisations using mbus
+- Added copy to userspace optimisations using mbus
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/r4kcache.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+
+#include "setup.h"
+
+#if !defined(CONFIG_TANGO2) && !defined(CONFIG_TANGO3)
+#error Undefined Sigma's chip!!!
+#endif
+
+#ifdef CONFIG_TANGO3
+#warning TANGO3 TODO IRQ assignment for W2/R2!!
+/* Temporary as no W2/R2 IRQ assigned yet. */
+#define LOG2_CPU_HOST_MBUS_W2_INT	62
+#define LOG2_CPU_HOST_MBUS_R2_INT	63
+
+/* Uncomment this only if W1/R1 can be used (typically not) */
+// #define WITH_MBUS_W1R1
+
+#endif /* CONFIG_TANGO3 */
+
+/*
+ * computed in prom.c
+ */
+extern unsigned long em8xxx_kmem_start;
+extern unsigned long em8xxx_kmem_size;
+
+long long em86_stats[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+static int usedma=0;
+
+/*
+ * switchbox stuffs
+ *
+ * We keep  track of  current mapping using  this globals  rather than
+ * reading hardware registers each time.
+ */
+static unsigned int g_sbox_map[SBOX_MAX];
+
+static inline void sbox_update_route(void)
+{
+	int i;
+#ifdef CONFIG_TANGO3
+	u64 data = 0; /* to cover two 32 bits registers */
+#else
+	unsigned int data = 0;
+#endif
+
+	for (i = SBOX_MAX - 1; i >= 0; --i)
+		data = (data << 4) | g_sbox_map[i];
+
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data & 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, (data >> 32) & 0xffffffff);
+#else
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data);
+#endif
+}
+
+static void sbox_reset(void)
+{
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xff00ff00);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfdfdfdfd);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfd00fd00);
+#endif
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01010101);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01000100);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d7d7d7d);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d007d00);
+#endif
+}
+
+static void sbox_setup(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/* W0 initially disconnected */
+	g_sbox_map[SBOX_MBUS_W0] = 0xf;
+
+#if defined(CONFIG_TANGO3) && defined(WITH_MBUS_W1R1)
+	g_sbox_map[SBOX_MBUS_W1] = 0xf;
+#else
+	/* Leave W1 alone */
+	g_sbox_map[SBOX_MBUS_W1] = 0;
+#endif
+
+	g_sbox_map[SBOX_PCIMASTER] = 0xf;
+	g_sbox_map[SBOX_PCISLAVE] = SBOX_PCISLAVE + 1; /* Loopback */
+	g_sbox_map[SBOX_SATA1] = 0xf;
+	g_sbox_map[SBOX_IDEDVD] = 0xf;
+	g_sbox_map[SBOX_IDEFLASH] = 0xf;
+#ifdef CONFIG_TANGO3
+	g_sbox_map[SBOX_SATA2] = 0xf;
+	g_sbox_map[SBOX_MBUS_W2] = 0xf;
+#else
+	g_sbox_map[SBOX_UNUSED1] = 0xf;
+#endif
+
+	sbox_update_route();
+	wmb();
+
+	local_irq_restore(flags);
+}
+
+/*
+ * Connect given interface to R?/W? channel
+ */
+#ifdef CONFIG_TANGO3
+static int sbox_connect(int iface, int *channel, int any)
+#else
+static int sbox_connect(int iface)
+#endif
+{
+	unsigned long flags;
+	int res = 0;
+#ifdef CONFIG_TANGO3
+	int chan = 0;
+#endif
+
+	local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) {
+		*channel = 0; /* connected to W0/R0 */
+		goto done;
+#ifdef WITH_MBUS_W1R1
+	} else if (g_sbox_map[SBOX_MBUS_W1] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W1 + 1)) {
+		*channel = 1; /* connected to W1/R1 */
+		goto done;
+#endif
+	} else if (g_sbox_map[SBOX_MBUS_W2] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W2 + 1)) {
+		*channel = 2; /* connected to W2/R2 */
+		goto done;
+	}
+
+	if (g_sbox_map[iface] != 0xf) { /* connect to something else already */
+		res = 1;
+		goto done;
+	}
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf) {
+		chan++; /* try next */
+#ifdef WITH_MBUS_W1R1
+		if (g_sbox_map[SBOX_MBUS_W1] != 0xf) {
+#endif
+			if (any == 0) {
+#warning TO BE FIX in TANGO3 H/W!! (W2/R2 allocation)
+				res = 1; /* TANGO3 TODO: allocate W2/R2 once IRQ is available */
+				goto done;
+			}
+			chan++; /* try next */
+			if (g_sbox_map[SBOX_MBUS_W2] != 0xf)  {
+				res = 1; /* Both W0/W2 not available, and optional (W1 as well) */
+				goto done;
+			}
+#ifdef WITH_MBUS_W1R1
+		}
+#endif
+	}
+#else
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) 
+		goto done;
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf || g_sbox_map[iface] != 0xf) {
+		res = 1;
+		goto done;
+	}
+#endif /* CONFIG_TANGO3 */
+
+#ifdef CONFIG_TANGO3
+	switch(chan) {
+		case 0: g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W0 + 1; /* W0/R0 */
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: g_sbox_map[SBOX_MBUS_W1] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W1 + 1; /* W1/R1 */
+			break;
+#endif
+		case 2: g_sbox_map[SBOX_MBUS_W2] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W2 + 1; /* W2/R2 */
+			break;
+
+		default: BUG();
+			break;
+	}
+	*channel = chan;
+#else
+	g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+	g_sbox_map[iface] = SBOX_MBUS_W0 + 1;
+#endif
+	sbox_update_route();
+	wmb();
+
+done:
+	local_irq_restore(flags);
+
+	return res;
+}
+
+#ifdef CONFIG_TANGO3
+static void sbox_disconnect(int iface, int channel)
+#else
+static void sbox_disconnect(int iface)
+#endif
+{
+	unsigned long flags;
+
+	if (iface >= 0) {
+		local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+		switch(channel) {
+			case 0: g_sbox_map[SBOX_MBUS_W0] = 0xf;
+				break;
+#ifdef WITH_MBUS_W1R1
+			case 1: g_sbox_map[SBOX_MBUS_W1] = 0xf;
+				break;
+#endif
+			case 2: g_sbox_map[SBOX_MBUS_W2] = 0xf;
+				break;
+
+			default: BUG();
+				break;
+		}
+#else
+		g_sbox_map[SBOX_MBUS_W0] = 0xf;
+#endif
+		g_sbox_map[iface] = 0xf;
+		sbox_update_route();
+		wmb();
+
+		local_irq_restore(flags);
+	}
+}
+
+static void sbox_init(void)
+{
+	sbox_setup();
+	sbox_reset();
+	// JFT, I wish we had more information on how those registers stuff work...
+	// Note :Is this early enough for all cases or we need a special enable flag?
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fe4, 0x0700); // Unreset dbk channels
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3dcc, 0x8000); // dbk loopback
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fdc, 0x0003); // switchbox->WMV9
+    usedma=1;
+}
+
+
+/*
+ * mbus stuffs
+ *
+ * to  avoid   requesting/freeing  irq   each  time,  we   keep  given
+ * handler/args  for each  dma  request and  call  it in  our own  irq
+ * handler.
+ */
+#define MBUS_LINEAR_MAX		(0x2000 - 1)
+
+#ifdef CONFIG_TANGO3
+static mbus_irq_handler_t g_mbus_intr_handler[6];
+static void *g_mbus_intr_handler_arg[6];
+#else
+static mbus_irq_handler_t g_mbus_intr_handler[4];
+static void *g_mbus_intr_handler_arg[4];
+#endif
+
+/*
+ * alloc_dma, need to be called before setup, will try to connect
+ * needed sbox.
+ */
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int any)
+{
+	int x;
+
+#ifdef CONFIG_TANGO3
+	int channel = 0;
+
+	if (sbox_connect(sbox, &channel, any) != 0)
+		return -1;
+
+	switch(channel) {
+		case 0: { 	/* Using W0/R0 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W0_ADD + (x * 0x40);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: { 	/* Using W1/R1 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W1_ADD + (x * 0x40);
+			}
+			break;
+#endif
+		case 2: { 	/* Using W2/R2 pair */
+				x = (fromdev ? 0 : 1);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W2_ADD + (x * 0x40);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	if (sbox_connect(sbox) != 0)
+		return -1;
+
+	x = (fromdev ? 0 : 2);
+	if (pirq)
+		*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+	if (pregbase)
+		*pregbase = REG_BASE_host_interface + MIF_W0_ADD + x * 0x40;
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_TANGO3
+/* Convert MBUS register address to channel index */
+static inline int mbus_idx2channel(unsigned int regbase)
+{
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	static const int channel[6] = { 0, 1, 0, 1, 2, 2 };
+	return(channel[idx]);
+}
+#endif
+
+/*
+ * free_dma,  need to  be called  after  transfer is  done to  release
+ * switchbox.
+ */
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox)
+{
+	unsigned long flags;
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	local_irq_save(flags);
+	g_mbus_intr_handler[idx] = NULL;
+	wmb();
+	local_irq_restore(flags);
+
+#ifdef CONFIG_TANGO3
+	sbox_disconnect(sbox, mbus_idx2channel(regbase)); 
+#else
+	sbox_disconnect(sbox);
+#endif
+}
+
+/*
+ * irq handler for mbus interrupt
+ */
+static irqreturn_t mbus_intr(int irq, void *devinfo)
+{
+	int idx = irq - (LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE);
+
+#ifdef CONFIG_TANGO3
+	if (idx >= 4)
+		idx = irq - (LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE) + 4;
+#endif
+	if (g_mbus_intr_handler[idx]) {
+		mbus_irq_handler_t f;
+
+		f = g_mbus_intr_handler[idx];
+		g_mbus_intr_handler[idx] = NULL;
+		wmb();
+		f(irq, g_mbus_intr_handler_arg[idx]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * check if mbus is in use for given regbase
+ */
+static inline int mbus_inuse(unsigned int regbase)
+{
+	return (gbus_readl(regbase + MIF_cmd_offset) & 0x7) != 0;
+}
+
+/*
+ * setup mbus  register to start  a linear transfer (count  bytes from
+ * addr, where count < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_linear(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (linear): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, count);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x1);
+}
+
+/*
+ * setup mbus  register to start  a double transfer (count  bytes from
+ * addr and count2 bytes from addr2, where count < MBUS_LINEAR_MAX and
+ * count2 < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_double(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int addr2,
+					 unsigned int count2,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address 0x%08x\n", addr);
+	if ((addr2 < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr2 >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address2 0x%08x\n", addr2);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (count2 << 16) | count);
+	gbus_writel(regbase + MIF_add2_skip_offset, addr2);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x2);
+}
+
+/*
+ * setup mbus  register to start  a rectangle transfer (horiz  * lines
+ * bytes  from  addr,  where  horiz  <  MBUS_LINEAR_MAX  and  lines  <
+ * MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_rectangle(unsigned int regbase,
+					    unsigned int addr,
+					    unsigned int horiz,
+					    unsigned int lines,
+					    unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (rectangle): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (lines << 16) | horiz);
+	gbus_writel(regbase + MIF_add2_skip_offset, horiz);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x3);
+}
+
+/*
+ * register mbus interrupt if not done
+ */
+#ifdef CONFIG_TANGO3
+static inline void mbus_register_intr(int channel)
+#else
+static inline void mbus_register_intr(void)
+#endif
+{
+#ifdef CONFIG_TANGO3
+	static int done[3] = { 0, 0, 0 };
+
+	switch(channel) {
+		case 0: {	/* Use W0/R0 then */
+				if (done[0])
+					return;
+				done[0] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: {	/* Use W1/R1 instead */
+				if (done[1])
+					return;
+				done[1] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r1", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w1", NULL);
+			}
+			break;
+#endif
+		case 2: {	/* Use W2/R2 instead */
+				if (done[2])
+					return;
+				done[2] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r2", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w2", NULL);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	static int done = 0;
+
+	if (done)
+		return;
+	done = 1;
+	/*
+	 * register irq handler for R0/W0 only (R1/W1 are not used for
+	 * the moment)
+	 */
+	request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+
+	request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+
+#endif
+}
+
+/*
+ * setup void transaction 
+ */
+void em86xx_mbus_setup_dma_void(unsigned int regbase)
+{
+	while (mbus_inuse(regbase) != 0)
+		;
+	gbus_writel(regbase + MIF_cmd_offset, 4);
+}
+
+/*
+ * start  a   mbus  dma,   use  this  after   a  sucessfull   call  to
+ * em86xx_mbus_alloc_dma
+ */
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr,
+			  unsigned int count, mbus_irq_handler_t handler,
+			  void *arg, unsigned int tflags)
+{
+	unsigned long flags;
+	unsigned int horiz, lines, sz;
+	unsigned int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	/*
+	 * make sure no one uses the mbus before
+	 */
+	if (unlikely(mbus_inuse(regbase))) {
+		printk(KERN_ERR "MBUS: error previous command is pending\n");
+		return 1;
+	}
+
+	/*
+	 * "register" given handler if any
+	 */
+	if (handler) {
+#ifdef CONFIG_TANGO3
+		mbus_register_intr(mbus_idx2channel(regbase));
+#else
+		mbus_register_intr();
+#endif
+		local_irq_save(flags);
+		g_mbus_intr_handler[idx] = handler;
+		g_mbus_intr_handler_arg[idx] = arg;
+		wmb();
+		local_irq_restore(flags);
+	}
+
+	/*
+	 * decide which dma function to use depending on count
+	 */
+	if (count <= MBUS_LINEAR_MAX) {
+		mbus_setup_dma_linear(regbase, addr, count, tflags);
+		return 0;
+	}
+
+	if (count <= (MBUS_LINEAR_MAX * 2)) {
+		mbus_setup_dma_double(regbase, addr, MBUS_LINEAR_MAX,
+				      addr + MBUS_LINEAR_MAX,
+				      count - MBUS_LINEAR_MAX, tflags);
+		return 0;
+	}
+
+	/*
+	 * we need to use rectangle, compute  horiz & lines
+	 * values to use
+	 */
+	for (idx = 0, horiz = 1, sz = count; (idx < 10) && ((sz & 0x01) == 0); ++idx, horiz <<= 1, sz >>= 1)
+		;
+	lines = count >> idx;
+	if ((horiz > MBUS_LINEAR_MAX) || (lines > MBUS_LINEAR_MAX)) {
+		printk(KERN_ERR "MBUS: can't handle rectangle transfer "
+		       "of %d bytes (h: %d, v: %d)\n", count, horiz, lines);
+		BUG();
+	}
+	mbus_setup_dma_rectangle(regbase, addr, horiz, lines, tflags);
+
+	return 0;
+}
+
+/*
+ * Bit 0/8: MBUS_R0_SBOX
+ * Bit 1/9: MBUS_R1_SBOX
+ * Bit 2/10: PCI_MASTER_SBOX
+ * Bit 3/11: PCI_SLAVE_SBOX
+ * Bit 4/12: SATA1_SBOX
+ * Bit 5/13: IDE_ISA_SBOX
+ * Bit 6/14: IDE_DVD_SBOX
+ * Bit 7/15: SATA2_SBOX (Tango3)
+ * Bit 16/24: SBOX_MBUS_W0
+ * Bit 17/25: SBOX_MBUS_W1
+ * Bit 18/26: SBOX_PCI_MASTER
+ * Bit 19/27: SBOX_PCI_SLAVE
+ * Bit 20/28: SBOX_SATA1
+ * Bit 21/29: SBOX_ISA
+ * Bit 22/30: SBOX_DVD
+ * Bit 23/31: SBOX_SATA2 (Tango3)
+ *
+ * Bit 32/40: MBUS_R2_SBOX (Tango3)
+ * Bit 48/50: SBOX_MBUS_W2 (Tango3)
+ */
+#ifdef CONFIG_TANGO3
+static const u64 sbox_reset_vals[4][6] = {
+	{ 0x0000000001011010ULL, 0x0000000002021010ULL, 0x0000000010100101ULL, 0x0000000010100202ULL, 0x0101000000001010ULL, 0x0000010110100000ULL },
+	{ 0x0000000001012020ULL, 0x0000000002022020ULL, 0x0000000020200101ULL, 0x0000000020200202ULL, 0x0101000000002020ULL, 0x0000010120200000ULL },
+	{ 0x0000000001014040ULL, 0x0000000002024040ULL, 0x0000000040400101ULL, 0x0000000040400202ULL, 0x0101000000004040ULL, 0x0000010140400000ULL },
+	{ 0x0000000001018080ULL, 0x0000000002028080ULL, 0x0000000080800101ULL, 0x0000000080800202ULL, 0x0101000000008080ULL, 0x0000010180800000ULL },
+};
+#else
+static const unsigned int sbox_reset_vals[2][4] = {
+	{ 0x01012020, 0x02022020, 0x20200101, 0x20200202 },
+	{ 0x01014040, 0x02024040, 0x40400101, 0x40400202 }
+};
+#endif
+
+/*
+ * clear MBUS transaction for given regbase/sbox
+ */
+static void mbus_reset(unsigned int regbase, int sbox)
+{
+	int midx;
+	int sidx;
+
+#ifdef CONFIG_TANGO3
+	unsigned int rl, rh;
+
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_SATA1;
+
+	if (((midx < 0) || (midx > 5)) || ((sidx < 0) || (sidx > 3))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+	rl = sbox_reset_vals[sidx][midx] & 0xffffffff;
+	rh = (sbox_reset_vals[sidx][midx] >> 32) & 0xffffffff;
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh);
+	iob();
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl & 0xff00ff00);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh & 0xff00ff00);
+	iob();
+#else
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_IDEFLASH;
+
+	if (((midx < 0) || (midx > 3)) || ((sidx < 0) || (sidx > 2))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx]);
+	iob();
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx] & 0xff00ff00);
+	iob();
+#endif
+}
+
+/* Fancy version of memcpy, both dst and src need to be physical address */
+/* The channels have to be allocated already */
+int mbus_memcpy(unsigned int regbase, unsigned int dst, unsigned int src, unsigned int size)
+{
+	/* Save the old SBOX route */
+	unsigned int sbox_route;
+	unsigned int w_base;
+	unsigned int r_base;
+	int channel = 0;
+/* 
+ * TRANSFER defines 4 bits, bit 0: followed by void (1) or not (0),
+ * bit 1: tiled buffer or not (tango3 only).
+ * bit 3-2: 0 = 8 bit, 1 = 16 bit, 2 = 32 bit (tango3 only).
+ */
+#ifdef CONFIG_TANGO3
+#define TRANSFER    0x1 /* or 0x9 for 32 bit transfer */
+#else
+#define TRANSFER    0x1
+#endif
+
+#ifdef CONFIG_TANGO3
+	channel = mbus_idx2channel(regbase);
+
+	if (channel == 0) /* W0/R0 channels are used */
+#endif
+	{
+		w_base = REG_BASE_host_interface + MIF_W0_ADD;
+		r_base = REG_BASE_host_interface + MIF_R0_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xffffff0f;
+
+		/* Hook up W0/R0 and left W1/R1 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff01);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W0 */
+			printk("MBUS: need to reset W0 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	else if (channel == 1) { /* W1/R1 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W1_ADD;
+		r_base = REG_BASE_host_interface + MIF_R1_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xfffffff0;
+
+		/* Hook up W1/R1 and left W0/R0 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff20);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W1 */
+			printk("MBUS: need to reset W1 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#endif
+	else { /* channel == 2: W2/R2 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W2_ADD;
+		r_base = REG_BASE_host_interface + MIF_R2_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE2);
+
+		/* Hook up W2/R2 */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, 0xfffffff9);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W2 */
+			printk("MBUS: need to reset W2 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+	}
+#endif
+
+	return(size);
+}
+
+/*
+ * busy wait  for current mbus transfer  to finish, will  not wait for
+ * more than 20 ms. 0 is ok, 1 timeout, 2 for timeout + reset error.
+ */
+#define MBUS_TIMEOUT	20000
+
+int em86xx_mbus_wait(unsigned int regbase, int sbox)
+{
+	int timeout;
+
+	/* wait for mbus to be released */
+	timeout = 0;
+	do {
+		if (!mbus_inuse(regbase))
+			break;
+		udelay(1);
+		timeout++;
+	} while (timeout < MBUS_TIMEOUT);
+
+	if (timeout < MBUS_TIMEOUT ) {
+		/* ok */
+		if (sbox == SBOX_IDEFLASH){
+                        int i;
+			unsigned int pb_count = 0;
+
+			pb_count = gbus_readl(REG_BASE_host_interface + 
+					       PB_automode_control) & 0xffff;
+
+                        for (i = 0; pb_count && (i < MBUS_TIMEOUT); i++){
+                                udelay(1);
+				pb_count = gbus_readl(REG_BASE_host_interface +
+					       PB_automode_control) & 0xffff;
+			}
+
+                        if (i < MBUS_TIMEOUT) 
+				return 0;
+
+		} else
+			return 0;
+	}
+
+	/* timeout, let's dump some registers ! */
+        if (sbox == SBOX_IDEFLASH) {
+  		printk("MBUS timeout : MBUS CMD = %ld, PB Automode = %08x\n",
+                	(unsigned long)gbus_readl(regbase + MIF_cmd_offset) & 0x7,
+                	(unsigned int)gbus_readl(REG_BASE_host_interface + PB_automode_control));
+        } else {
+		printk("MBUS timeout : MBUS CMD = %08lx\n",
+			gbus_readl(regbase + MIF_cmd_offset) & 0x7);
+	}
+
+	printk("MBUS registers : %08lx %08lx %08lx %08lx\n",
+	       gbus_readl(regbase + MIF_add_offset),
+	       gbus_readl(regbase + MIF_cnt_offset),
+	       gbus_readl(regbase + MIF_add2_skip_offset),
+	       gbus_readl(regbase + MIF_cmd_offset));
+
+	printk(KERN_ERR "MBUS fails, resetting %d ..\n", sbox);
+	mbus_reset(regbase, sbox);
+
+	/* If not able to reset, return  1, so the DMA can be disabled
+	   accordingly  */
+	return mbus_inuse(regbase) ? 0 : 1;
+}
+
+int em86xx_mbus_init(void)
+{
+	static int done = 0;
+
+	if (done)
+		return 0;
+	done = 1;
+
+	/* reset sbox to default values */
+	sbox_init();
+
+	/* Give better MBUS bandwidth for Wx/Rx channel */
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_system_block + MARB_mid01_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid21_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid03_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid23_cfg, 0x12005);
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x12005);
+#endif
+#else
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x11f1f);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x11f1f);
+#endif
+
+	return 0;
+}
+
+// JFT, *** WARNING ***  CODE BELOW IS ONLY VALID IN SPECIFIC CASES
+
+#define offset_into_page(x) ((x) & (PAGE_SIZE - 1))
+
+static inline unsigned long tangox_getxtal(void)
+{
+	return(gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt));
+}
+
+// Reduce gbus usage
+static int wait_mpegdma()
+{
+    int i,j=0;
+    while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0)
+    {
+        for(i=0;i<512;i++) { j++; }
+    }
+    return j;
+}
+
+// At this point the memory copy is linear in physical space
+static int mpeg_dma_transfer_to_user(unsigned int dma_to, unsigned int virt_to, unsigned int dma_from, int len)
+{
+        int byte=0;
+        while(len>0)
+        {
+            int blockcount = len>0x1FFF ? 1 : 1;
+            int curlen=len>0x1FFF ? (blockcount*0x1FFF) : len;
+            // if(len>=16384) curlen=16384;
+
+            // printk(KERN_ERR "mbus transfer %X to %x len %X\n", dma_from+byte, dma_to, curlen);
+            blast_dcache_range(dma_from+byte, dma_from+byte+curlen);
+            blast_inv_dcache_range(virt_to+byte, virt_to+byte+curlen);
+
+            wait_mpegdma();
+
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to) & 0x3fff0000) >> 16);
+            if(curlen>0x1FFF)
+            {
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, 0x1FFF);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, blockcount);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad0, 0x1FFF);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad4, 0);
+                if((len-curlen)==0)
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x7);
+                else
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x3);
+            }
+            else
+            {
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, len>0x1FFF ? 0x1FFF : len);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+
+                if((len-curlen)==0)
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+                else
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x1);
+            }
+            // Start VDEC0_MBUS_R2 
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from+byte) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from+byte) & 0x3fff0000) >> 16);
+            if(curlen>0x1FFF)
+            {
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, 0x1FFF);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, blockcount);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b10, 0x1FFF);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b14, 0);
+                if((len-curlen)==0)
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x7);
+                else
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x3);
+            }
+            else
+            {
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, len>0x1FFF ? 0x1FFF : len);
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+                if((len-curlen)==0)
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+                else
+                    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x1);
+            }
+            dma_to += curlen;
+            byte += curlen;
+            len-= curlen;
+        }
+        return byte;
+}
+
+extern void *memcpy2(void *__to, __const__ void *__from, size_t __n);
+void *memcpy(void *__to, __const__ void *__from, size_t __n)
+{
+    unsigned long virt_to = (unsigned long) __to;
+    unsigned long virt_from = (unsigned long) __from;
+    dma_addr_t dma_from;
+    dma_addr_t dma_to;
+    int len=__n;
+    int flag;
+    unsigned long t1,t2;
+
+
+    // JFT, We could probably handle more cases
+    if(__n<512 || !usedma || virt_from < 0x90000000 || virt_to < 0x90000000 ||
+        virt_from>=0xA0000000 || virt_to >=0xA0000000)
+    {
+        em86_stats[10]+=__n;
+        return memcpy2(__to, __from, __n);
+    }
+
+    t1=tangox_getxtal();
+
+
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // JFT, If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__n)&0xF) flush_dcache_line((virt_to+__n)&~0xF);
+
+    dma_from=virt_from;
+    dma_to=virt_to;
+
+    raw_local_irq_save(flag);
+    while(len>0)
+    {
+        int curlen= len>0x1FFF ? 0x1FFF : len;
+        blast_dcache_range(dma_from, dma_from+curlen);
+        blast_inv_dcache_range(dma_to, dma_to+curlen);
+        wait_mpegdma();
+
+//            printk(KERN_ERR "mbus transfer %X to %x len %X\n", dma_from+byte, dma_to, len>0x1FFF ? 0x1FFF : len);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to) & 0xffff);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to) & 0x3fff0000) >> 16);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, curlen);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+        if((len-curlen)==0)
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+        else
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x1);
+        // Start VDEC0_MBUS_R2 
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from) & 0xffff);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from) & 0x3fff0000) >> 16);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, curlen);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+        if((len-curlen)==0)
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+        else
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x1);
+        dma_to += curlen;
+        dma_from += curlen;
+        len-= curlen;
+    }
+    wait_mpegdma();
+    t2=tangox_getxtal();
+    em86_stats[12]+=__n;
+    em86_stats[13]+=(t2-t1);
+    raw_local_irq_restore(flag);
+    return __to;
+}
+
+size_t __invoke_copy_to_user_dma(void __user * __cu_to, const void * __cu_from, long __cu_len)
+{
+    unsigned long virt_to = (unsigned long) __cu_to;
+    unsigned long virt_from = (unsigned long) __cu_from;
+    dma_addr_t dma_from;
+    int byte;
+    unsigned long _n;
+    int flag;
+    unsigned long t1,t2;
+
+    // JFT, note: this is very common case so make it first
+    if(__cu_len<512)
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+
+    if(virt_to >= 0x80000000)
+    {
+        memcpy(__cu_to, __cu_from, __cu_len);
+        return 0;
+    }
+
+    if(__cu_len<512 || !usedma || virt_from >= 0xC0000000 || virt_to >= 0x80000000)
+    {
+        em86_stats[14]+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    if(!(virt_addr_valid(__cu_from)) ||
+        !(virt_addr_valid(__cu_from + __cu_len)))
+    {
+        em86_stats[14]+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    // Verify all pages exist
+    for(byte = 0; byte < __cu_len; byte+=PAGE_SIZE)
+    {
+        __put_user_check(0, (unsigned char *) (virt_to+byte), 1);
+    }
+    __put_user_check(0, (unsigned char *) (virt_to+__cu_len-1), 1);
+
+    t1=tangox_getxtal();
+
+    // If the virt_to is not aligned we need to flush the data before it
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__cu_len)&0xF) flush_dcache_line((virt_to+__cu_len)&~0xF);
+
+    dma_from = virt_from;
+
+    // printk(KERN_ERR "dma transfer %X to %x len %X\n", __cu_from, __cu_to , __cu_len);
+
+    raw_local_irq_save(flag);
+
+    for (byte = 0, _n = __cu_len; byte < __cu_len;) 
+    {
+        int len = min(PAGE_SIZE - offset_into_page(virt_to + byte), _n);
+        pgd_t *pgd;
+        pud_t *pud;
+        pmd_t *pmd;
+        pte_t *pte;
+        unsigned long pg_addr;
+        unsigned long dma_to;
+
+        pg_addr = (virt_to+byte) & PAGE_MASK; /* address of start page */
+
+        if (pg_addr > TASK_SIZE)
+            pgd = pgd_offset_k(pg_addr);
+        else
+            pgd = pgd_offset_gate(current->mm, pg_addr);
+        BUG_ON(pgd_none(*pgd));
+        pud = pud_offset(pgd, pg_addr);
+        BUG_ON(pud_none(*pud));
+        pmd = pmd_offset(pud, pg_addr);
+        if (pmd_none(*pmd)) 
+        {
+            printk(KERN_ERR "pmd_none\n");
+            wait_mpegdma();
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        pte = pte_offset_map(pmd, pg_addr);
+        if (pte_none(*pte)) {
+            pte_unmap(pte);
+            printk(KERN_ERR "pte_none\n");
+            wait_mpegdma();
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        dma_to= (pte_val(*pte) & PAGE_MASK) + offset_into_page(virt_to + byte);
+        pte_unmap(pte);
+
+
+        if(dma_to<0x10000000 || dma_to>=0x30000000)
+        {
+            wait_mpegdma();
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            printk(KERN_ERR "invalid copy to user %08X\n",dma_to);
+            goto unpin;
+        }
+        _n -= len;
+
+        byte+=mpeg_dma_transfer_to_user(dma_to, virt_to+byte, dma_from+byte, len);
+    }
+    wait_mpegdma();
+//	do_gettimeofday(&tv);
+//	t2=tv.tv_sec*1000000LL+tv.tv_usec;
+    raw_local_irq_restore(flag);
+//    em86dma_time+=(t2-t1);
+//    em86dma_csum_time+=(t2-t3);
+    em86_stats[0]+=__cu_len;
+    em86_stats[2]+=1;
+    t2=tangox_getxtal();
+    em86_stats[1]+=(t2-t1);
+unpin:
+    return _n;
+}
+
+size_t __invoke_copy_from_user_dma(void * __cu_to, const void __user * __cu_from, long __cu_len)
+{
+    unsigned long virt_to = (unsigned long) __cu_to;
+    unsigned long virt_from = (unsigned long) __cu_from;
+    dma_addr_t dma_to;
+    int byte;
+    unsigned long _n;
+    int flag;
+    unsigned long t1,t2;
+    unsigned char val;
+
+
+    // JFT, this is very common case so make it first
+    if(__cu_len<512) 
+        return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+
+    // printk(KERN_ERR "dma transfer %X to %x len %X\n", __cu_from, __cu_to , __cu_len);
+
+    if(virt_from >= 0x80000000)
+    {
+        memcpy(__cu_to, __cu_from, __cu_len);
+        return 0;
+    }
+
+    if(__cu_len<512 || !usedma || virt_to >= 0xC0000000)
+    {
+        em86_stats[16]+=__cu_len;
+        return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    if(!(virt_addr_valid(__cu_to)) ||
+        !(virt_addr_valid(__cu_to + __cu_len)))
+    {
+        em86_stats[16]+=__cu_len;
+        return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    // Verify all pages exist
+    for(byte = 0; byte < __cu_len; byte+=PAGE_SIZE)
+    {
+        __get_user_check(val, (unsigned char *) (virt_from+byte), 1);
+    }
+    __get_user_check(val, (unsigned char *) (virt_from+__cu_len-1), 1);
+
+    t1=tangox_getxtal();
+
+    // If the virt_to is not aligned we need to flush the data before it
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__cu_len)&0xF) flush_dcache_line((virt_to+__cu_len)&~0xF);
+
+    dma_to = virt_to;
+
+
+    raw_local_irq_save(flag);
+
+    for (byte = 0, _n = __cu_len; byte < __cu_len;) 
+    {
+        int len = min(PAGE_SIZE - offset_into_page(virt_from + byte), _n);
+        pgd_t *pgd;
+        pud_t *pud;
+        pmd_t *pmd;
+        pte_t *pte;
+        unsigned long pg_addr;
+        unsigned long dma_from;
+
+        pg_addr = (virt_from+byte) & PAGE_MASK; /* address of start page */
+
+        if (pg_addr > TASK_SIZE)
+            pgd = pgd_offset_k(pg_addr);
+        else
+            pgd = pgd_offset_gate(current->mm, pg_addr);
+        BUG_ON(pgd_none(*pgd));
+        pud = pud_offset(pgd, pg_addr);
+        BUG_ON(pud_none(*pud));
+        pmd = pmd_offset(pud, pg_addr);
+        if (pmd_none(*pmd)) 
+        {
+            printk(KERN_ERR "pmd_none\n");
+            wait_mpegdma();
+            em86_stats[16]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        pte = pte_offset_map(pmd, pg_addr);
+        if (pte_none(*pte)) {
+            pte_unmap(pte);
+            printk(KERN_ERR "pte_none\n");
+            wait_mpegdma();
+            em86_stats[16]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        dma_from= (pte_val(*pte) & PAGE_MASK) + offset_into_page(virt_from + byte);
+        pte_unmap(pte);
+
+
+        if(dma_from<0x10000000 || dma_from>=0x30000000)
+        {
+            wait_mpegdma();
+            em86_stats[16]+=__cu_len;
+            raw_local_irq_restore(flag);
+            printk(KERN_ERR "invalid copy from user %08X\n",dma_from);
+            goto unpin;
+        }
+        _n -= len;
+
+        while(len>0)
+        {
+            int curlen=len>0x1FFF ? 0x1FFF : len;
+
+            // printk(KERN_ERR "mbus transfer %X to %x len %X\n", dma_from+byte, dma_to, curlen);
+            
+            blast_dcache_range(virt_from+byte, virt_from+byte+curlen);
+            blast_inv_dcache_range(dma_to+byte, dma_to+byte+curlen);
+
+            wait_mpegdma();
+    
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to+byte) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to+byte) & 0x3fff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+            if((curlen-len)==0)
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+            else
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x1);
+            // Start VDEC0_MBUS_R2 
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from) & 0x3fff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+            if((curlen-len)==0)
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+            else
+                gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x1);
+            dma_from += curlen;
+            byte += curlen;
+            len-= curlen;
+        }
+    }
+    wait_mpegdma();
+//	do_gettimeofday(&tv);
+//	t2=tv.tv_sec*1000000LL+tv.tv_usec;
+    raw_local_irq_restore(flag);
+//    em86dma_time+=(t2-t1);
+//    em86dma_csum_time+=(t2-t3);
+    em86_stats[18]+=__cu_len;
+//    em86_stats[2]+=1;
+    t2=tangox_getxtal();
+    em86_stats[19]+=(t2-t1);
+unpin:
+    return _n;
+}
+
+EXPORT_SYMBOL(em86xx_mbus_alloc_dma);
+EXPORT_SYMBOL(em86xx_mbus_free_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma_void);
+EXPORT_SYMBOL(em86xx_mbus_wait);
+EXPORT_SYMBOL(em86xx_mbus_init);
+EXPORT_SYMBOL(mbus_setup_dma_linear);
+EXPORT_SYMBOL(mbus_setup_dma_double);
+EXPORT_SYMBOL(mbus_setup_dma_rectangle);
+EXPORT_SYMBOL(mbus_memcpy);
+
+EXPORT_SYMBOL(em86_stats);
+EXPORT_SYMBOL(memcpy);
+EXPORT_SYMBOL(__invoke_copy_to_user_dma);
+EXPORT_SYMBOL(__invoke_copy_from_user_dma);
diff -Naur linux-2.6.25.8/arch/mips/tangox/mbus.c.dma1 linux-2.6.25.8-clean/arch/mips/tangox/mbus.c.dma1
--- linux-2.6.25.8/arch/mips/tangox/mbus.c.dma1	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/mbus.c.dma1	2008-09-23 16:45:43.000000000 -0400
@@ -0,0 +1,1058 @@
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/r4kcache.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+
+#include "setup.h"
+
+#if !defined(CONFIG_TANGO2) && !defined(CONFIG_TANGO3)
+#error Undefined Sigma's chip!!!
+#endif
+
+#ifdef CONFIG_TANGO3
+#warning TANGO3 TODO IRQ assignment for W2/R2!!
+/* Temporary as no W2/R2 IRQ assigned yet. */
+#define LOG2_CPU_HOST_MBUS_W2_INT	62
+#define LOG2_CPU_HOST_MBUS_R2_INT	63
+
+/* Uncomment this only if W1/R1 can be used (typically not) */
+// #define WITH_MBUS_W1R1
+
+#endif /* CONFIG_TANGO3 */
+
+/*
+ * computed in prom.c
+ */
+extern unsigned long em8xxx_kmem_start;
+extern unsigned long em8xxx_kmem_size;
+
+long long em86dma_notdma_bytes=0;
+long long em86dma_bytes=0;
+long long em86dma_time=0;
+long long em86dma_csum_bytes=0;
+long long em86dma_csum_time=0;
+
+static int usedma=0;
+
+/*
+ * switchbox stuffs
+ *
+ * We keep  track of  current mapping using  this globals  rather than
+ * reading hardware registers each time.
+ */
+static unsigned int g_sbox_map[SBOX_MAX];
+
+static inline void sbox_update_route(void)
+{
+	int i;
+#ifdef CONFIG_TANGO3
+	u64 data = 0; /* to cover two 32 bits registers */
+#else
+	unsigned int data = 0;
+#endif
+
+	for (i = SBOX_MAX - 1; i >= 0; --i)
+		data = (data << 4) | g_sbox_map[i];
+
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data & 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, (data >> 32) & 0xffffffff);
+#else
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data);
+#endif
+}
+
+static void sbox_reset(void)
+{
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xff00ff00);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfdfdfdfd);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfd00fd00);
+#endif
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01010101);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01000100);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d7d7d7d);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d007d00);
+#endif
+}
+
+static void sbox_setup(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/* W0 initially disconnected */
+	g_sbox_map[SBOX_MBUS_W0] = 0xf;
+
+#if defined(CONFIG_TANGO3) && defined(WITH_MBUS_W1R1)
+	g_sbox_map[SBOX_MBUS_W1] = 0xf;
+#else
+	/* Leave W1 alone */
+	g_sbox_map[SBOX_MBUS_W1] = 0;
+#endif
+
+	g_sbox_map[SBOX_PCIMASTER] = 0xf;
+	g_sbox_map[SBOX_PCISLAVE] = SBOX_PCISLAVE + 1; /* Loopback */
+	g_sbox_map[SBOX_SATA1] = 0xf;
+	g_sbox_map[SBOX_IDEDVD] = 0xf;
+	g_sbox_map[SBOX_IDEFLASH] = 0xf;
+#ifdef CONFIG_TANGO3
+	g_sbox_map[SBOX_SATA2] = 0xf;
+	g_sbox_map[SBOX_MBUS_W2] = 0xf;
+#else
+	g_sbox_map[SBOX_UNUSED1] = 0xf;
+#endif
+
+	sbox_update_route();
+	wmb();
+
+	local_irq_restore(flags);
+}
+
+/*
+ * Connect given interface to R?/W? channel
+ */
+#ifdef CONFIG_TANGO3
+static int sbox_connect(int iface, int *channel, int any)
+#else
+static int sbox_connect(int iface)
+#endif
+{
+	unsigned long flags;
+	int res = 0;
+#ifdef CONFIG_TANGO3
+	int chan = 0;
+#endif
+
+	local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) {
+		*channel = 0; /* connected to W0/R0 */
+		goto done;
+#ifdef WITH_MBUS_W1R1
+	} else if (g_sbox_map[SBOX_MBUS_W1] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W1 + 1)) {
+		*channel = 1; /* connected to W1/R1 */
+		goto done;
+#endif
+	} else if (g_sbox_map[SBOX_MBUS_W2] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W2 + 1)) {
+		*channel = 2; /* connected to W2/R2 */
+		goto done;
+	}
+
+	if (g_sbox_map[iface] != 0xf) { /* connect to something else already */
+		res = 1;
+		goto done;
+	}
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf) {
+		chan++; /* try next */
+#ifdef WITH_MBUS_W1R1
+		if (g_sbox_map[SBOX_MBUS_W1] != 0xf) {
+#endif
+			if (any == 0) {
+#warning TO BE FIX in TANGO3 H/W!! (W2/R2 allocation)
+				res = 1; /* TANGO3 TODO: allocate W2/R2 once IRQ is available */
+				goto done;
+			}
+			chan++; /* try next */
+			if (g_sbox_map[SBOX_MBUS_W2] != 0xf)  {
+				res = 1; /* Both W0/W2 not available, and optional (W1 as well) */
+				goto done;
+			}
+#ifdef WITH_MBUS_W1R1
+		}
+#endif
+	}
+#else
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) 
+		goto done;
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf || g_sbox_map[iface] != 0xf) {
+		res = 1;
+		goto done;
+	}
+#endif /* CONFIG_TANGO3 */
+
+#ifdef CONFIG_TANGO3
+	switch(chan) {
+		case 0: g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W0 + 1; /* W0/R0 */
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: g_sbox_map[SBOX_MBUS_W1] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W1 + 1; /* W1/R1 */
+			break;
+#endif
+		case 2: g_sbox_map[SBOX_MBUS_W2] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W2 + 1; /* W2/R2 */
+			break;
+
+		default: BUG();
+			break;
+	}
+	*channel = chan;
+#else
+	g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+	g_sbox_map[iface] = SBOX_MBUS_W0 + 1;
+#endif
+	sbox_update_route();
+	wmb();
+
+done:
+	local_irq_restore(flags);
+
+	return res;
+}
+
+#ifdef CONFIG_TANGO3
+static void sbox_disconnect(int iface, int channel)
+#else
+static void sbox_disconnect(int iface)
+#endif
+{
+	unsigned long flags;
+
+	if (iface >= 0) {
+		local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+		switch(channel) {
+			case 0: g_sbox_map[SBOX_MBUS_W0] = 0xf;
+				break;
+#ifdef WITH_MBUS_W1R1
+			case 1: g_sbox_map[SBOX_MBUS_W1] = 0xf;
+				break;
+#endif
+			case 2: g_sbox_map[SBOX_MBUS_W2] = 0xf;
+				break;
+
+			default: BUG();
+				break;
+		}
+#else
+		g_sbox_map[SBOX_MBUS_W0] = 0xf;
+#endif
+		g_sbox_map[iface] = 0xf;
+		sbox_update_route();
+		wmb();
+
+		local_irq_restore(flags);
+	}
+}
+
+static void sbox_init(void)
+{
+	sbox_setup();
+	sbox_reset();
+	// Is this early enough?
+    gbus_writel(REG_BASE_system_block + 0x240, 0x11f1f); // write
+    gbus_writel(REG_BASE_system_block + 0x244, 0x11f1f); // read
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fe4, 0x0700); // Unreset dbk channels
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3dcc, 0x8000); // dbk loopback
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fdc, 0x0003); // switchbox->WMV9
+    usedma=1;
+}
+
+
+/*
+ * mbus stuffs
+ *
+ * to  avoid   requesting/freeing  irq   each  time,  we   keep  given
+ * handler/args  for each  dma  request and  call  it in  our own  irq
+ * handler.
+ */
+#define MBUS_LINEAR_MAX		(0x2000 - 1)
+
+#ifdef CONFIG_TANGO3
+static mbus_irq_handler_t g_mbus_intr_handler[6];
+static void *g_mbus_intr_handler_arg[6];
+#else
+static mbus_irq_handler_t g_mbus_intr_handler[4];
+static void *g_mbus_intr_handler_arg[4];
+#endif
+
+/*
+ * alloc_dma, need to be called before setup, will try to connect
+ * needed sbox.
+ */
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int any)
+{
+	int x;
+
+#ifdef CONFIG_TANGO3
+	int channel = 0;
+
+	if (sbox_connect(sbox, &channel, any) != 0)
+		return -1;
+
+	switch(channel) {
+		case 0: { 	/* Using W0/R0 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W0_ADD + (x * 0x40);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: { 	/* Using W1/R1 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W1_ADD + (x * 0x40);
+			}
+			break;
+#endif
+		case 2: { 	/* Using W2/R2 pair */
+				x = (fromdev ? 0 : 1);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W2_ADD + (x * 0x40);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	if (sbox_connect(sbox) != 0)
+		return -1;
+
+	x = (fromdev ? 0 : 2);
+	if (pirq)
+		*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+	if (pregbase)
+		*pregbase = REG_BASE_host_interface + MIF_W0_ADD + x * 0x40;
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_TANGO3
+/* Convert MBUS register address to channel index */
+static inline int mbus_idx2channel(unsigned int regbase)
+{
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	static const int channel[6] = { 0, 1, 0, 1, 2, 2 };
+	return(channel[idx]);
+}
+#endif
+
+/*
+ * free_dma,  need to  be called  after  transfer is  done to  release
+ * switchbox.
+ */
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox)
+{
+	unsigned long flags;
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	local_irq_save(flags);
+	g_mbus_intr_handler[idx] = NULL;
+	wmb();
+	local_irq_restore(flags);
+
+#ifdef CONFIG_TANGO3
+	sbox_disconnect(sbox, mbus_idx2channel(regbase)); 
+#else
+	sbox_disconnect(sbox);
+#endif
+}
+
+/*
+ * irq handler for mbus interrupt
+ */
+static irqreturn_t mbus_intr(int irq, void *devinfo)
+{
+	int idx = irq - (LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE);
+
+#ifdef CONFIG_TANGO3
+	if (idx >= 4)
+		idx = irq - (LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE) + 4;
+#endif
+	if (g_mbus_intr_handler[idx]) {
+		mbus_irq_handler_t f;
+
+		f = g_mbus_intr_handler[idx];
+		g_mbus_intr_handler[idx] = NULL;
+		wmb();
+		f(irq, g_mbus_intr_handler_arg[idx]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * check if mbus is in use for given regbase
+ */
+static inline int mbus_inuse(unsigned int regbase)
+{
+	return (gbus_readl(regbase + MIF_cmd_offset) & 0x7) != 0;
+}
+
+/*
+ * setup mbus  register to start  a linear transfer (count  bytes from
+ * addr, where count < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_linear(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (linear): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, count);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x1);
+}
+
+/*
+ * setup mbus  register to start  a double transfer (count  bytes from
+ * addr and count2 bytes from addr2, where count < MBUS_LINEAR_MAX and
+ * count2 < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_double(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int addr2,
+					 unsigned int count2,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address 0x%08x\n", addr);
+	if ((addr2 < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr2 >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address2 0x%08x\n", addr2);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (count2 << 16) | count);
+	gbus_writel(regbase + MIF_add2_skip_offset, addr2);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x2);
+}
+
+/*
+ * setup mbus  register to start  a rectangle transfer (horiz  * lines
+ * bytes  from  addr,  where  horiz  <  MBUS_LINEAR_MAX  and  lines  <
+ * MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_rectangle(unsigned int regbase,
+					    unsigned int addr,
+					    unsigned int horiz,
+					    unsigned int lines,
+					    unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (rectangle): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (lines << 16) | horiz);
+	gbus_writel(regbase + MIF_add2_skip_offset, horiz);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x3);
+}
+
+/*
+ * register mbus interrupt if not done
+ */
+#ifdef CONFIG_TANGO3
+static inline void mbus_register_intr(int channel)
+#else
+static inline void mbus_register_intr(void)
+#endif
+{
+#ifdef CONFIG_TANGO3
+	static int done[3] = { 0, 0, 0 };
+
+	switch(channel) {
+		case 0: {	/* Use W0/R0 then */
+				if (done[0])
+					return;
+				done[0] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: {	/* Use W1/R1 instead */
+				if (done[1])
+					return;
+				done[1] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r1", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w1", NULL);
+			}
+			break;
+#endif
+		case 2: {	/* Use W2/R2 instead */
+				if (done[2])
+					return;
+				done[2] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r2", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w2", NULL);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	static int done = 0;
+
+	if (done)
+		return;
+	done = 1;
+	/*
+	 * register irq handler for R0/W0 only (R1/W1 are not used for
+	 * the moment)
+	 */
+	request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+
+	request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+
+#endif
+}
+
+/*
+ * setup void transaction 
+ */
+void em86xx_mbus_setup_dma_void(unsigned int regbase)
+{
+	while (mbus_inuse(regbase) != 0)
+		;
+	gbus_writel(regbase + MIF_cmd_offset, 4);
+}
+
+/*
+ * start  a   mbus  dma,   use  this  after   a  sucessfull   call  to
+ * em86xx_mbus_alloc_dma
+ */
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr,
+			  unsigned int count, mbus_irq_handler_t handler,
+			  void *arg, unsigned int tflags)
+{
+	unsigned long flags;
+	unsigned int horiz, lines, sz;
+	unsigned int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	/*
+	 * make sure no one uses the mbus before
+	 */
+	if (unlikely(mbus_inuse(regbase))) {
+		printk(KERN_ERR "MBUS: error previous command is pending\n");
+		return 1;
+	}
+
+	/*
+	 * "register" given handler if any
+	 */
+	if (handler) {
+#ifdef CONFIG_TANGO3
+		mbus_register_intr(mbus_idx2channel(regbase));
+#else
+		mbus_register_intr();
+#endif
+		local_irq_save(flags);
+		g_mbus_intr_handler[idx] = handler;
+		g_mbus_intr_handler_arg[idx] = arg;
+		wmb();
+		local_irq_restore(flags);
+	}
+
+	/*
+	 * decide which dma function to use depending on count
+	 */
+	if (count <= MBUS_LINEAR_MAX) {
+		mbus_setup_dma_linear(regbase, addr, count, tflags);
+		return 0;
+	}
+
+	if (count <= (MBUS_LINEAR_MAX * 2)) {
+		mbus_setup_dma_double(regbase, addr, MBUS_LINEAR_MAX,
+				      addr + MBUS_LINEAR_MAX,
+				      count - MBUS_LINEAR_MAX, tflags);
+		return 0;
+	}
+
+	/*
+	 * we need to use rectangle, compute  horiz & lines
+	 * values to use
+	 */
+	for (idx = 0, horiz = 1, sz = count; (idx < 10) && ((sz & 0x01) == 0); ++idx, horiz <<= 1, sz >>= 1)
+		;
+	lines = count >> idx;
+	if ((horiz > MBUS_LINEAR_MAX) || (lines > MBUS_LINEAR_MAX)) {
+		printk(KERN_ERR "MBUS: can't handle rectangle transfer "
+		       "of %d bytes (h: %d, v: %d)\n", count, horiz, lines);
+		BUG();
+	}
+	mbus_setup_dma_rectangle(regbase, addr, horiz, lines, tflags);
+
+	return 0;
+}
+
+/*
+ * Bit 0/8: MBUS_R0_SBOX
+ * Bit 1/9: MBUS_R1_SBOX
+ * Bit 2/10: PCI_MASTER_SBOX
+ * Bit 3/11: PCI_SLAVE_SBOX
+ * Bit 4/12: SATA1_SBOX
+ * Bit 5/13: IDE_ISA_SBOX
+ * Bit 6/14: IDE_DVD_SBOX
+ * Bit 7/15: SATA2_SBOX (Tango3)
+ * Bit 16/24: SBOX_MBUS_W0
+ * Bit 17/25: SBOX_MBUS_W1
+ * Bit 18/26: SBOX_PCI_MASTER
+ * Bit 19/27: SBOX_PCI_SLAVE
+ * Bit 20/28: SBOX_SATA1
+ * Bit 21/29: SBOX_ISA
+ * Bit 22/30: SBOX_DVD
+ * Bit 23/31: SBOX_SATA2 (Tango3)
+ *
+ * Bit 32/40: MBUS_R2_SBOX (Tango3)
+ * Bit 48/50: SBOX_MBUS_W2 (Tango3)
+ */
+#ifdef CONFIG_TANGO3
+static const u64 sbox_reset_vals[4][6] = {
+	{ 0x0000000001011010ULL, 0x0000000002021010ULL, 0x0000000010100101ULL, 0x0000000010100202ULL, 0x0101000000001010ULL, 0x0000010110100000ULL },
+	{ 0x0000000001012020ULL, 0x0000000002022020ULL, 0x0000000020200101ULL, 0x0000000020200202ULL, 0x0101000000002020ULL, 0x0000010120200000ULL },
+	{ 0x0000000001014040ULL, 0x0000000002024040ULL, 0x0000000040400101ULL, 0x0000000040400202ULL, 0x0101000000004040ULL, 0x0000010140400000ULL },
+	{ 0x0000000001018080ULL, 0x0000000002028080ULL, 0x0000000080800101ULL, 0x0000000080800202ULL, 0x0101000000008080ULL, 0x0000010180800000ULL },
+};
+#else
+static const unsigned int sbox_reset_vals[2][4] = {
+	{ 0x01012020, 0x02022020, 0x20200101, 0x20200202 },
+	{ 0x01014040, 0x02024040, 0x40400101, 0x40400202 }
+};
+#endif
+
+/*
+ * clear MBUS transaction for given regbase/sbox
+ */
+static void mbus_reset(unsigned int regbase, int sbox)
+{
+	int midx;
+	int sidx;
+
+#ifdef CONFIG_TANGO3
+	unsigned int rl, rh;
+
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_SATA1;
+
+	if (((midx < 0) || (midx > 5)) || ((sidx < 0) || (sidx > 3))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+	rl = sbox_reset_vals[sidx][midx] & 0xffffffff;
+	rh = (sbox_reset_vals[sidx][midx] >> 32) & 0xffffffff;
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh);
+	iob();
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl & 0xff00ff00);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh & 0xff00ff00);
+	iob();
+#else
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_IDEFLASH;
+
+	if (((midx < 0) || (midx > 3)) || ((sidx < 0) || (sidx > 2))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx]);
+	iob();
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx] & 0xff00ff00);
+	iob();
+#endif
+}
+
+/* Fancy version of memcpy, both dst and src need to be physical address */
+/* The channels have to be allocated already */
+int mbus_memcpy(unsigned int regbase, unsigned int dst, unsigned int src, unsigned int size)
+{
+	/* Save the old SBOX route */
+	unsigned int sbox_route;
+	unsigned int w_base;
+	unsigned int r_base;
+	int channel = 0;
+/* 
+ * TRANSFER defines 4 bits, bit 0: followed by void (1) or not (0),
+ * bit 1: tiled buffer or not (tango3 only).
+ * bit 3-2: 0 = 8 bit, 1 = 16 bit, 2 = 32 bit (tango3 only).
+ */
+#ifdef CONFIG_TANGO3
+#define TRANSFER    0x1 /* or 0x9 for 32 bit transfer */
+#else
+#define TRANSFER    0x1
+#endif
+
+#ifdef CONFIG_TANGO3
+	channel = mbus_idx2channel(regbase);
+
+	if (channel == 0) /* W0/R0 channels are used */
+#endif
+	{
+		w_base = REG_BASE_host_interface + MIF_W0_ADD;
+		r_base = REG_BASE_host_interface + MIF_R0_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xffffff0f;
+
+		/* Hook up W0/R0 and left W1/R1 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff01);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W0 */
+			printk("MBUS: need to reset W0 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	else if (channel == 1) { /* W1/R1 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W1_ADD;
+		r_base = REG_BASE_host_interface + MIF_R1_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xfffffff0;
+
+		/* Hook up W1/R1 and left W0/R0 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff20);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W1 */
+			printk("MBUS: need to reset W1 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#endif
+	else { /* channel == 2: W2/R2 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W2_ADD;
+		r_base = REG_BASE_host_interface + MIF_R2_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE2);
+
+		/* Hook up W2/R2 */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, 0xfffffff9);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W2 */
+			printk("MBUS: need to reset W2 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+	}
+#endif
+
+	return(size);
+}
+
+/*
+ * busy wait  for current mbus transfer  to finish, will  not wait for
+ * more than 20 ms. 0 is ok, 1 timeout, 2 for timeout + reset error.
+ */
+#define MBUS_TIMEOUT	20000
+
+int em86xx_mbus_wait(unsigned int regbase, int sbox)
+{
+	int timeout;
+
+	/* wait for mbus to be released */
+	timeout = 0;
+	do {
+		if (!mbus_inuse(regbase))
+			break;
+		udelay(1);
+		timeout++;
+	} while (timeout < MBUS_TIMEOUT);
+
+	if (timeout < MBUS_TIMEOUT ) {
+		/* ok */
+		if (sbox == SBOX_IDEFLASH){
+                        int i;
+			unsigned int pb_count = 0;
+
+			pb_count = gbus_readl(REG_BASE_host_interface + 
+					       PB_automode_control) & 0xffff;
+
+                        for (i = 0; pb_count && (i < MBUS_TIMEOUT); i++){
+                                udelay(1);
+				pb_count = gbus_readl(REG_BASE_host_interface +
+					       PB_automode_control) & 0xffff;
+			}
+
+                        if (i < MBUS_TIMEOUT) 
+				return 0;
+
+		} else
+			return 0;
+	}
+
+	/* timeout, let's dump some registers ! */
+        if (sbox == SBOX_IDEFLASH) {
+  		printk("MBUS timeout : MBUS CMD = %ld, PB Automode = %08x\n",
+                	(unsigned long)gbus_readl(regbase + MIF_cmd_offset) & 0x7,
+                	(unsigned int)gbus_readl(REG_BASE_host_interface + PB_automode_control));
+        } else {
+		printk("MBUS timeout : MBUS CMD = %08lx\n",
+			gbus_readl(regbase + MIF_cmd_offset) & 0x7);
+	}
+
+	printk("MBUS registers : %08lx %08lx %08lx %08lx\n",
+	       gbus_readl(regbase + MIF_add_offset),
+	       gbus_readl(regbase + MIF_cnt_offset),
+	       gbus_readl(regbase + MIF_add2_skip_offset),
+	       gbus_readl(regbase + MIF_cmd_offset));
+
+	printk(KERN_ERR "MBUS fails, resetting %d ..\n", sbox);
+	mbus_reset(regbase, sbox);
+
+	/* If not able to reset, return  1, so the DMA can be disabled
+	   accordingly  */
+	return mbus_inuse(regbase) ? 0 : 1;
+}
+
+int em86xx_mbus_init(void)
+{
+	static int done = 0;
+
+	if (done)
+		return 0;
+	done = 1;
+
+	/* reset sbox to default values */
+	sbox_init();
+
+	/* Give better MBUS bandwidth for Wx/Rx channel */
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_system_block + MARB_mid01_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid21_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid03_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid23_cfg, 0x12005);
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x12005);
+#endif
+#else
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x11f1f);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x11f1f);
+#endif
+
+	return 0;
+}
+
+#define offset_into_page(x) ((x) & (PAGE_SIZE - 1))
+
+size_t __invoke_copy_to_user_dma(void __user * __cu_to, const void * __cu_from, long __cu_len)
+{
+    unsigned long virt_to = (unsigned long) __cu_to;
+    unsigned long virt_from = (unsigned long) __cu_from;
+    int nr_pages = 1 + ((__cu_len - 1 + offset_into_page(virt_to)) / PAGE_SIZE);
+    struct page *pages[nr_pages];
+    dma_addr_t dma_from;
+    int nr_unmap;
+    size_t ret = 0;
+    int byte;
+    unsigned long _n;
+    int flag;
+    long long t1,t2,t3;
+	struct timeval tv;
+
+    if(__cu_len<1024 || !usedma || virt_from >= 0xC0000000)
+    {
+        em86dma_notdma_bytes+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    if(!(virt_addr_valid(__cu_from)) ||
+        !(virt_addr_valid(__cu_from + __cu_len)))
+    {
+        em86dma_notdma_bytes+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+
+	do_gettimeofday(&tv);
+	t1=tv.tv_sec*1000000LL+tv.tv_usec;
+
+    set_thread_flag(TIF_DMA);
+    down_read(&current->mm->mmap_sem);
+    nr_unmap = get_user_pages(
+        current,
+        current->mm,
+        virt_to,
+        nr_pages,
+        1,	/* write */
+        0,	/* force */
+        pages,
+        NULL);
+    up_read(&current->mm->mmap_sem);
+    if (nr_unmap != nr_pages) {
+        em86dma_notdma_bytes+=__cu_len;
+        _n = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+        goto unpin;
+    }
+    // If the virt_to is not aligned we need to flush the data before it
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__cu_len)&0xF) flush_dcache_line((virt_to+__cu_len)&~0xF);
+    blast_inv_dcache_range(virt_to, virt_to+__cu_len);
+    dma_from = dma_map_single(NULL, (void *) virt_from, __cu_len, DMA_TO_DEVICE);
+
+    raw_local_irq_save(flag);
+	do_gettimeofday(&tv);
+	t3=tv.tv_sec*1000000LL+tv.tv_usec;
+
+    for (byte = 0, _n = __cu_len; byte < __cu_len;) {
+        int len = min(PAGE_SIZE - offset_into_page(virt_to + byte), _n);
+        int idx = (byte + offset_into_page(virt_to)) >> PAGE_SHIFT;
+        dma_addr_t dma_to = dma_map_page(NULL, pages[idx],
+                        offset_into_page(virt_to + byte),
+                        len, DMA_FROM_DEVICE);
+
+        if(dma_to<0x10000000 || dma_to>=0x30000000 ||
+            dma_from<0x10000000 || dma_from>=0x30000000)
+        {
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+            //em86dma_csum_bytes+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        _n -= len;
+        
+        while(len>0)
+        {
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+    
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to) & 0xffff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+            // Start VDEC0_MBUS_R2 
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from+byte) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from+byte) & 0xffff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+            byte += len>0x1FFF ? 0x1FFF : len;;
+            len-= len>0x1FFF ? 0x1FFF : len;
+        }
+    }
+    while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+	do_gettimeofday(&tv);
+	t2=tv.tv_sec*1000000LL+tv.tv_usec;
+    raw_local_irq_restore(flag);
+    em86dma_time+=(t2-t1);
+    em86dma_csum_time+=(t2-t3);
+    em86dma_bytes+=__cu_len;
+    em86dma_csum_bytes+=1;
+unpin:
+    while (nr_unmap--) {
+        set_page_dirty_lock(pages[nr_unmap]);
+        page_cache_release(pages[nr_unmap]);
+    }
+    clear_thread_flag(TIF_DMA);
+    return _n;
+}
+
+EXPORT_SYMBOL(em86xx_mbus_alloc_dma);
+EXPORT_SYMBOL(em86xx_mbus_free_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma_void);
+EXPORT_SYMBOL(em86xx_mbus_wait);
+EXPORT_SYMBOL(em86xx_mbus_init);
+EXPORT_SYMBOL(mbus_setup_dma_linear);
+EXPORT_SYMBOL(mbus_setup_dma_double);
+EXPORT_SYMBOL(mbus_setup_dma_rectangle);
+EXPORT_SYMBOL(mbus_memcpy);
+
+EXPORT_SYMBOL(em86dma_bytes);
+EXPORT_SYMBOL(em86dma_notdma_bytes);
+EXPORT_SYMBOL(em86dma_csum_bytes);
+EXPORT_SYMBOL(em86dma_csum_time);
+EXPORT_SYMBOL(em86dma_time);
diff -Naur linux-2.6.25.8/arch/mips/tangox/mbus.c.dma2 linux-2.6.25.8-clean/arch/mips/tangox/mbus.c.dma2
--- linux-2.6.25.8/arch/mips/tangox/mbus.c.dma2	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/mbus.c.dma2	2008-09-30 14:47:13.000000000 -0400
@@ -0,0 +1,1136 @@
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/r4kcache.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+
+#include "setup.h"
+
+#if !defined(CONFIG_TANGO2) && !defined(CONFIG_TANGO3)
+#error Undefined Sigma's chip!!!
+#endif
+
+#ifdef CONFIG_TANGO3
+#warning TANGO3 TODO IRQ assignment for W2/R2!!
+/* Temporary as no W2/R2 IRQ assigned yet. */
+#define LOG2_CPU_HOST_MBUS_W2_INT	62
+#define LOG2_CPU_HOST_MBUS_R2_INT	63
+
+/* Uncomment this only if W1/R1 can be used (typically not) */
+// #define WITH_MBUS_W1R1
+
+#endif /* CONFIG_TANGO3 */
+
+/*
+ * computed in prom.c
+ */
+extern unsigned long em8xxx_kmem_start;
+extern unsigned long em8xxx_kmem_size;
+
+long long em86_stats[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+static int usedma=0;
+
+/*
+ * switchbox stuffs
+ *
+ * We keep  track of  current mapping using  this globals  rather than
+ * reading hardware registers each time.
+ */
+static unsigned int g_sbox_map[SBOX_MAX];
+
+static inline void sbox_update_route(void)
+{
+	int i;
+#ifdef CONFIG_TANGO3
+	u64 data = 0; /* to cover two 32 bits registers */
+#else
+	unsigned int data = 0;
+#endif
+
+	for (i = SBOX_MAX - 1; i >= 0; --i)
+		data = (data << 4) | g_sbox_map[i];
+
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data & 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, (data >> 32) & 0xffffffff);
+#else
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data);
+#endif
+}
+
+static void sbox_reset(void)
+{
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xff00ff00);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfdfdfdfd);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfd00fd00);
+#endif
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01010101);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01000100);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d7d7d7d);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d007d00);
+#endif
+}
+
+static void sbox_setup(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/* W0 initially disconnected */
+	g_sbox_map[SBOX_MBUS_W0] = 0xf;
+
+#if defined(CONFIG_TANGO3) && defined(WITH_MBUS_W1R1)
+	g_sbox_map[SBOX_MBUS_W1] = 0xf;
+#else
+	/* Leave W1 alone */
+	g_sbox_map[SBOX_MBUS_W1] = 0;
+#endif
+
+	g_sbox_map[SBOX_PCIMASTER] = 0xf;
+	g_sbox_map[SBOX_PCISLAVE] = SBOX_PCISLAVE + 1; /* Loopback */
+	g_sbox_map[SBOX_SATA1] = 0xf;
+	g_sbox_map[SBOX_IDEDVD] = 0xf;
+	g_sbox_map[SBOX_IDEFLASH] = 0xf;
+#ifdef CONFIG_TANGO3
+	g_sbox_map[SBOX_SATA2] = 0xf;
+	g_sbox_map[SBOX_MBUS_W2] = 0xf;
+#else
+	g_sbox_map[SBOX_UNUSED1] = 0xf;
+#endif
+
+	sbox_update_route();
+	wmb();
+
+	local_irq_restore(flags);
+}
+
+/*
+ * Connect given interface to R?/W? channel
+ */
+#ifdef CONFIG_TANGO3
+static int sbox_connect(int iface, int *channel, int any)
+#else
+static int sbox_connect(int iface)
+#endif
+{
+	unsigned long flags;
+	int res = 0;
+#ifdef CONFIG_TANGO3
+	int chan = 0;
+#endif
+
+	local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) {
+		*channel = 0; /* connected to W0/R0 */
+		goto done;
+#ifdef WITH_MBUS_W1R1
+	} else if (g_sbox_map[SBOX_MBUS_W1] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W1 + 1)) {
+		*channel = 1; /* connected to W1/R1 */
+		goto done;
+#endif
+	} else if (g_sbox_map[SBOX_MBUS_W2] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W2 + 1)) {
+		*channel = 2; /* connected to W2/R2 */
+		goto done;
+	}
+
+	if (g_sbox_map[iface] != 0xf) { /* connect to something else already */
+		res = 1;
+		goto done;
+	}
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf) {
+		chan++; /* try next */
+#ifdef WITH_MBUS_W1R1
+		if (g_sbox_map[SBOX_MBUS_W1] != 0xf) {
+#endif
+			if (any == 0) {
+#warning TO BE FIX in TANGO3 H/W!! (W2/R2 allocation)
+				res = 1; /* TANGO3 TODO: allocate W2/R2 once IRQ is available */
+				goto done;
+			}
+			chan++; /* try next */
+			if (g_sbox_map[SBOX_MBUS_W2] != 0xf)  {
+				res = 1; /* Both W0/W2 not available, and optional (W1 as well) */
+				goto done;
+			}
+#ifdef WITH_MBUS_W1R1
+		}
+#endif
+	}
+#else
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) 
+		goto done;
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf || g_sbox_map[iface] != 0xf) {
+		res = 1;
+		goto done;
+	}
+#endif /* CONFIG_TANGO3 */
+
+#ifdef CONFIG_TANGO3
+	switch(chan) {
+		case 0: g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W0 + 1; /* W0/R0 */
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: g_sbox_map[SBOX_MBUS_W1] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W1 + 1; /* W1/R1 */
+			break;
+#endif
+		case 2: g_sbox_map[SBOX_MBUS_W2] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W2 + 1; /* W2/R2 */
+			break;
+
+		default: BUG();
+			break;
+	}
+	*channel = chan;
+#else
+	g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+	g_sbox_map[iface] = SBOX_MBUS_W0 + 1;
+#endif
+	sbox_update_route();
+	wmb();
+
+done:
+	local_irq_restore(flags);
+
+	return res;
+}
+
+#ifdef CONFIG_TANGO3
+static void sbox_disconnect(int iface, int channel)
+#else
+static void sbox_disconnect(int iface)
+#endif
+{
+	unsigned long flags;
+
+	if (iface >= 0) {
+		local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+		switch(channel) {
+			case 0: g_sbox_map[SBOX_MBUS_W0] = 0xf;
+				break;
+#ifdef WITH_MBUS_W1R1
+			case 1: g_sbox_map[SBOX_MBUS_W1] = 0xf;
+				break;
+#endif
+			case 2: g_sbox_map[SBOX_MBUS_W2] = 0xf;
+				break;
+
+			default: BUG();
+				break;
+		}
+#else
+		g_sbox_map[SBOX_MBUS_W0] = 0xf;
+#endif
+		g_sbox_map[iface] = 0xf;
+		sbox_update_route();
+		wmb();
+
+		local_irq_restore(flags);
+	}
+}
+
+static void sbox_init(void)
+{
+	sbox_setup();
+	sbox_reset();
+	// Is this early enough?
+    gbus_writel(REG_BASE_system_block + 0x240, 0x11f1f); // write
+    gbus_writel(REG_BASE_system_block + 0x244, 0x11f1f); // read
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fe4, 0x0700); // Unreset dbk channels
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3dcc, 0x8000); // dbk loopback
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fdc, 0x0003); // switchbox->WMV9
+    usedma=1;
+}
+
+
+/*
+ * mbus stuffs
+ *
+ * to  avoid   requesting/freeing  irq   each  time,  we   keep  given
+ * handler/args  for each  dma  request and  call  it in  our own  irq
+ * handler.
+ */
+#define MBUS_LINEAR_MAX		(0x2000 - 1)
+
+#ifdef CONFIG_TANGO3
+static mbus_irq_handler_t g_mbus_intr_handler[6];
+static void *g_mbus_intr_handler_arg[6];
+#else
+static mbus_irq_handler_t g_mbus_intr_handler[4];
+static void *g_mbus_intr_handler_arg[4];
+#endif
+
+/*
+ * alloc_dma, need to be called before setup, will try to connect
+ * needed sbox.
+ */
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int any)
+{
+	int x;
+
+#ifdef CONFIG_TANGO3
+	int channel = 0;
+
+	if (sbox_connect(sbox, &channel, any) != 0)
+		return -1;
+
+	switch(channel) {
+		case 0: { 	/* Using W0/R0 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W0_ADD + (x * 0x40);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: { 	/* Using W1/R1 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W1_ADD + (x * 0x40);
+			}
+			break;
+#endif
+		case 2: { 	/* Using W2/R2 pair */
+				x = (fromdev ? 0 : 1);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W2_ADD + (x * 0x40);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	if (sbox_connect(sbox) != 0)
+		return -1;
+
+	x = (fromdev ? 0 : 2);
+	if (pirq)
+		*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+	if (pregbase)
+		*pregbase = REG_BASE_host_interface + MIF_W0_ADD + x * 0x40;
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_TANGO3
+/* Convert MBUS register address to channel index */
+static inline int mbus_idx2channel(unsigned int regbase)
+{
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	static const int channel[6] = { 0, 1, 0, 1, 2, 2 };
+	return(channel[idx]);
+}
+#endif
+
+/*
+ * free_dma,  need to  be called  after  transfer is  done to  release
+ * switchbox.
+ */
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox)
+{
+	unsigned long flags;
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	local_irq_save(flags);
+	g_mbus_intr_handler[idx] = NULL;
+	wmb();
+	local_irq_restore(flags);
+
+#ifdef CONFIG_TANGO3
+	sbox_disconnect(sbox, mbus_idx2channel(regbase)); 
+#else
+	sbox_disconnect(sbox);
+#endif
+}
+
+/*
+ * irq handler for mbus interrupt
+ */
+static irqreturn_t mbus_intr(int irq, void *devinfo)
+{
+	int idx = irq - (LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE);
+
+#ifdef CONFIG_TANGO3
+	if (idx >= 4)
+		idx = irq - (LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE) + 4;
+#endif
+	if (g_mbus_intr_handler[idx]) {
+		mbus_irq_handler_t f;
+
+		f = g_mbus_intr_handler[idx];
+		g_mbus_intr_handler[idx] = NULL;
+		wmb();
+		f(irq, g_mbus_intr_handler_arg[idx]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * check if mbus is in use for given regbase
+ */
+static inline int mbus_inuse(unsigned int regbase)
+{
+	return (gbus_readl(regbase + MIF_cmd_offset) & 0x7) != 0;
+}
+
+/*
+ * setup mbus  register to start  a linear transfer (count  bytes from
+ * addr, where count < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_linear(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (linear): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, count);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x1);
+}
+
+/*
+ * setup mbus  register to start  a double transfer (count  bytes from
+ * addr and count2 bytes from addr2, where count < MBUS_LINEAR_MAX and
+ * count2 < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_double(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int addr2,
+					 unsigned int count2,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address 0x%08x\n", addr);
+	if ((addr2 < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr2 >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address2 0x%08x\n", addr2);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (count2 << 16) | count);
+	gbus_writel(regbase + MIF_add2_skip_offset, addr2);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x2);
+}
+
+/*
+ * setup mbus  register to start  a rectangle transfer (horiz  * lines
+ * bytes  from  addr,  where  horiz  <  MBUS_LINEAR_MAX  and  lines  <
+ * MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_rectangle(unsigned int regbase,
+					    unsigned int addr,
+					    unsigned int horiz,
+					    unsigned int lines,
+					    unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (rectangle): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (lines << 16) | horiz);
+	gbus_writel(regbase + MIF_add2_skip_offset, horiz);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x3);
+}
+
+/*
+ * register mbus interrupt if not done
+ */
+#ifdef CONFIG_TANGO3
+static inline void mbus_register_intr(int channel)
+#else
+static inline void mbus_register_intr(void)
+#endif
+{
+#ifdef CONFIG_TANGO3
+	static int done[3] = { 0, 0, 0 };
+
+	switch(channel) {
+		case 0: {	/* Use W0/R0 then */
+				if (done[0])
+					return;
+				done[0] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: {	/* Use W1/R1 instead */
+				if (done[1])
+					return;
+				done[1] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r1", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w1", NULL);
+			}
+			break;
+#endif
+		case 2: {	/* Use W2/R2 instead */
+				if (done[2])
+					return;
+				done[2] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r2", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w2", NULL);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	static int done = 0;
+
+	if (done)
+		return;
+	done = 1;
+	/*
+	 * register irq handler for R0/W0 only (R1/W1 are not used for
+	 * the moment)
+	 */
+	request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+
+	request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+
+#endif
+}
+
+/*
+ * setup void transaction 
+ */
+void em86xx_mbus_setup_dma_void(unsigned int regbase)
+{
+	while (mbus_inuse(regbase) != 0)
+		;
+	gbus_writel(regbase + MIF_cmd_offset, 4);
+}
+
+/*
+ * start  a   mbus  dma,   use  this  after   a  sucessfull   call  to
+ * em86xx_mbus_alloc_dma
+ */
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr,
+			  unsigned int count, mbus_irq_handler_t handler,
+			  void *arg, unsigned int tflags)
+{
+	unsigned long flags;
+	unsigned int horiz, lines, sz;
+	unsigned int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	/*
+	 * make sure no one uses the mbus before
+	 */
+	if (unlikely(mbus_inuse(regbase))) {
+		printk(KERN_ERR "MBUS: error previous command is pending\n");
+		return 1;
+	}
+
+	/*
+	 * "register" given handler if any
+	 */
+	if (handler) {
+#ifdef CONFIG_TANGO3
+		mbus_register_intr(mbus_idx2channel(regbase));
+#else
+		mbus_register_intr();
+#endif
+		local_irq_save(flags);
+		g_mbus_intr_handler[idx] = handler;
+		g_mbus_intr_handler_arg[idx] = arg;
+		wmb();
+		local_irq_restore(flags);
+	}
+
+	/*
+	 * decide which dma function to use depending on count
+	 */
+	if (count <= MBUS_LINEAR_MAX) {
+		mbus_setup_dma_linear(regbase, addr, count, tflags);
+		return 0;
+	}
+
+	if (count <= (MBUS_LINEAR_MAX * 2)) {
+		mbus_setup_dma_double(regbase, addr, MBUS_LINEAR_MAX,
+				      addr + MBUS_LINEAR_MAX,
+				      count - MBUS_LINEAR_MAX, tflags);
+		return 0;
+	}
+
+	/*
+	 * we need to use rectangle, compute  horiz & lines
+	 * values to use
+	 */
+	for (idx = 0, horiz = 1, sz = count; (idx < 10) && ((sz & 0x01) == 0); ++idx, horiz <<= 1, sz >>= 1)
+		;
+	lines = count >> idx;
+	if ((horiz > MBUS_LINEAR_MAX) || (lines > MBUS_LINEAR_MAX)) {
+		printk(KERN_ERR "MBUS: can't handle rectangle transfer "
+		       "of %d bytes (h: %d, v: %d)\n", count, horiz, lines);
+		BUG();
+	}
+	mbus_setup_dma_rectangle(regbase, addr, horiz, lines, tflags);
+
+	return 0;
+}
+
+/*
+ * Bit 0/8: MBUS_R0_SBOX
+ * Bit 1/9: MBUS_R1_SBOX
+ * Bit 2/10: PCI_MASTER_SBOX
+ * Bit 3/11: PCI_SLAVE_SBOX
+ * Bit 4/12: SATA1_SBOX
+ * Bit 5/13: IDE_ISA_SBOX
+ * Bit 6/14: IDE_DVD_SBOX
+ * Bit 7/15: SATA2_SBOX (Tango3)
+ * Bit 16/24: SBOX_MBUS_W0
+ * Bit 17/25: SBOX_MBUS_W1
+ * Bit 18/26: SBOX_PCI_MASTER
+ * Bit 19/27: SBOX_PCI_SLAVE
+ * Bit 20/28: SBOX_SATA1
+ * Bit 21/29: SBOX_ISA
+ * Bit 22/30: SBOX_DVD
+ * Bit 23/31: SBOX_SATA2 (Tango3)
+ *
+ * Bit 32/40: MBUS_R2_SBOX (Tango3)
+ * Bit 48/50: SBOX_MBUS_W2 (Tango3)
+ */
+#ifdef CONFIG_TANGO3
+static const u64 sbox_reset_vals[4][6] = {
+	{ 0x0000000001011010ULL, 0x0000000002021010ULL, 0x0000000010100101ULL, 0x0000000010100202ULL, 0x0101000000001010ULL, 0x0000010110100000ULL },
+	{ 0x0000000001012020ULL, 0x0000000002022020ULL, 0x0000000020200101ULL, 0x0000000020200202ULL, 0x0101000000002020ULL, 0x0000010120200000ULL },
+	{ 0x0000000001014040ULL, 0x0000000002024040ULL, 0x0000000040400101ULL, 0x0000000040400202ULL, 0x0101000000004040ULL, 0x0000010140400000ULL },
+	{ 0x0000000001018080ULL, 0x0000000002028080ULL, 0x0000000080800101ULL, 0x0000000080800202ULL, 0x0101000000008080ULL, 0x0000010180800000ULL },
+};
+#else
+static const unsigned int sbox_reset_vals[2][4] = {
+	{ 0x01012020, 0x02022020, 0x20200101, 0x20200202 },
+	{ 0x01014040, 0x02024040, 0x40400101, 0x40400202 }
+};
+#endif
+
+/*
+ * clear MBUS transaction for given regbase/sbox
+ */
+static void mbus_reset(unsigned int regbase, int sbox)
+{
+	int midx;
+	int sidx;
+
+#ifdef CONFIG_TANGO3
+	unsigned int rl, rh;
+
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_SATA1;
+
+	if (((midx < 0) || (midx > 5)) || ((sidx < 0) || (sidx > 3))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+	rl = sbox_reset_vals[sidx][midx] & 0xffffffff;
+	rh = (sbox_reset_vals[sidx][midx] >> 32) & 0xffffffff;
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh);
+	iob();
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl & 0xff00ff00);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh & 0xff00ff00);
+	iob();
+#else
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_IDEFLASH;
+
+	if (((midx < 0) || (midx > 3)) || ((sidx < 0) || (sidx > 2))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx]);
+	iob();
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx] & 0xff00ff00);
+	iob();
+#endif
+}
+
+/* Fancy version of memcpy, both dst and src need to be physical address */
+/* The channels have to be allocated already */
+int mbus_memcpy(unsigned int regbase, unsigned int dst, unsigned int src, unsigned int size)
+{
+	/* Save the old SBOX route */
+	unsigned int sbox_route;
+	unsigned int w_base;
+	unsigned int r_base;
+	int channel = 0;
+/* 
+ * TRANSFER defines 4 bits, bit 0: followed by void (1) or not (0),
+ * bit 1: tiled buffer or not (tango3 only).
+ * bit 3-2: 0 = 8 bit, 1 = 16 bit, 2 = 32 bit (tango3 only).
+ */
+#ifdef CONFIG_TANGO3
+#define TRANSFER    0x1 /* or 0x9 for 32 bit transfer */
+#else
+#define TRANSFER    0x1
+#endif
+
+#ifdef CONFIG_TANGO3
+	channel = mbus_idx2channel(regbase);
+
+	if (channel == 0) /* W0/R0 channels are used */
+#endif
+	{
+		w_base = REG_BASE_host_interface + MIF_W0_ADD;
+		r_base = REG_BASE_host_interface + MIF_R0_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xffffff0f;
+
+		/* Hook up W0/R0 and left W1/R1 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff01);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W0 */
+			printk("MBUS: need to reset W0 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	else if (channel == 1) { /* W1/R1 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W1_ADD;
+		r_base = REG_BASE_host_interface + MIF_R1_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xfffffff0;
+
+		/* Hook up W1/R1 and left W0/R0 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff20);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W1 */
+			printk("MBUS: need to reset W1 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#endif
+	else { /* channel == 2: W2/R2 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W2_ADD;
+		r_base = REG_BASE_host_interface + MIF_R2_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE2);
+
+		/* Hook up W2/R2 */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, 0xfffffff9);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W2 */
+			printk("MBUS: need to reset W2 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+	}
+#endif
+
+	return(size);
+}
+
+/*
+ * busy wait  for current mbus transfer  to finish, will  not wait for
+ * more than 20 ms. 0 is ok, 1 timeout, 2 for timeout + reset error.
+ */
+#define MBUS_TIMEOUT	20000
+
+int em86xx_mbus_wait(unsigned int regbase, int sbox)
+{
+	int timeout;
+
+	/* wait for mbus to be released */
+	timeout = 0;
+	do {
+		if (!mbus_inuse(regbase))
+			break;
+		udelay(1);
+		timeout++;
+	} while (timeout < MBUS_TIMEOUT);
+
+	if (timeout < MBUS_TIMEOUT ) {
+		/* ok */
+		if (sbox == SBOX_IDEFLASH){
+                        int i;
+			unsigned int pb_count = 0;
+
+			pb_count = gbus_readl(REG_BASE_host_interface + 
+					       PB_automode_control) & 0xffff;
+
+                        for (i = 0; pb_count && (i < MBUS_TIMEOUT); i++){
+                                udelay(1);
+				pb_count = gbus_readl(REG_BASE_host_interface +
+					       PB_automode_control) & 0xffff;
+			}
+
+                        if (i < MBUS_TIMEOUT) 
+				return 0;
+
+		} else
+			return 0;
+	}
+
+	/* timeout, let's dump some registers ! */
+        if (sbox == SBOX_IDEFLASH) {
+  		printk("MBUS timeout : MBUS CMD = %ld, PB Automode = %08x\n",
+                	(unsigned long)gbus_readl(regbase + MIF_cmd_offset) & 0x7,
+                	(unsigned int)gbus_readl(REG_BASE_host_interface + PB_automode_control));
+        } else {
+		printk("MBUS timeout : MBUS CMD = %08lx\n",
+			gbus_readl(regbase + MIF_cmd_offset) & 0x7);
+	}
+
+	printk("MBUS registers : %08lx %08lx %08lx %08lx\n",
+	       gbus_readl(regbase + MIF_add_offset),
+	       gbus_readl(regbase + MIF_cnt_offset),
+	       gbus_readl(regbase + MIF_add2_skip_offset),
+	       gbus_readl(regbase + MIF_cmd_offset));
+
+	printk(KERN_ERR "MBUS fails, resetting %d ..\n", sbox);
+	mbus_reset(regbase, sbox);
+
+	/* If not able to reset, return  1, so the DMA can be disabled
+	   accordingly  */
+	return mbus_inuse(regbase) ? 0 : 1;
+}
+
+int em86xx_mbus_init(void)
+{
+	static int done = 0;
+
+	if (done)
+		return 0;
+	done = 1;
+
+	/* reset sbox to default values */
+	sbox_init();
+
+	/* Give better MBUS bandwidth for Wx/Rx channel */
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_system_block + MARB_mid01_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid21_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid03_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid23_cfg, 0x12005);
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x12005);
+#endif
+#else
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x11f1f);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x11f1f);
+#endif
+
+	return 0;
+}
+
+#define offset_into_page(x) ((x) & (PAGE_SIZE - 1))
+
+static inline unsigned long tangox_getxtal(void)
+{
+	return(gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt));
+}
+
+extern void *memcpy2(void *__to, __const__ void *__from, size_t __n);
+void *memcpy(void *__to, __const__ void *__from, size_t __n)
+{
+    unsigned long virt_to = (unsigned long) __to;
+    unsigned long virt_from = (unsigned long) __from;
+    dma_addr_t dma_from;
+    dma_addr_t dma_to;
+    int len=__n;
+    int flag;
+    unsigned long t1,t2;
+
+
+    if(__n<512 || !usedma || virt_from < 0x90000000 || virt_to < 0x90000000 ||
+        virt_from>=0xA0000000 || virt_to >=0xA0000000)
+    {
+        em86_stats[10]+=__n;
+        return memcpy2(__to, __from, __n);
+    }
+
+    t1=tangox_getxtal();
+
+
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__n)&0xF) flush_dcache_line((virt_to+__n)&~0xF);
+
+    dma_from=virt_from;
+    dma_to=virt_to;
+
+    raw_local_irq_save(flag);
+    while(len>0)
+    {
+        int curlen= len>0x1FFF ? 0x1FFF : len;
+        blast_dcache_range(dma_from, dma_from+curlen);
+        blast_inv_dcache_range(dma_to, dma_to+curlen);
+        while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+
+//            printk(KERN_ERR "mbus transfer %X to %x len %X\n", dma_from+byte, dma_to, len>0x1FFF ? 0x1FFF : len);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to) & 0xffff);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to) & 0x3fff0000) >> 16);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, curlen);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+        // Start VDEC0_MBUS_R2 
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from) & 0xffff);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from) & 0x3fff0000) >> 16);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, curlen);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+        dma_to += curlen;
+        dma_from += curlen;
+        len-= curlen;
+    }
+    while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+    t2=tangox_getxtal();
+    em86_stats[12]+=__n;
+    em86_stats[13]+=(t2-t1);
+    raw_local_irq_restore(flag);
+    return __to;
+}
+
+size_t __invoke_copy_to_user_dma(void __user * __cu_to, const void * __cu_from, long __cu_len)
+{
+    unsigned long virt_to = (unsigned long) __cu_to;
+    unsigned long virt_from = (unsigned long) __cu_from;
+    dma_addr_t dma_from;
+    int byte;
+    unsigned long _n;
+    int flag;
+//    long long t1,t2,t3;
+//	struct timeval tv;
+
+    if(__cu_len<512 || !usedma || virt_from >= 0xC0000000 || virt_to >= 0x80000000)
+    {
+        em86_stats[14]+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    if(!(virt_addr_valid(__cu_from)) ||
+        !(virt_addr_valid(__cu_from + __cu_len)))
+    {
+        em86_stats[14]+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    // Verify all pages exist
+    for(byte = 0; byte < __cu_len; byte+=PAGE_SIZE)
+    {
+        __put_user_check(0, (unsigned char *) (virt_to+byte), 1);
+    }
+    __put_user_check(0, (unsigned char *) (virt_to+__cu_len-1), 1);
+
+//	do_gettimeofday(&tv);
+//	t1=tv.tv_sec*1000000LL+tv.tv_usec;
+
+    // If the virt_to is not aligned we need to flush the data before it
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__cu_len)&0xF) flush_dcache_line((virt_to+__cu_len)&~0xF);
+    blast_inv_dcache_range(virt_to, virt_to+__cu_len);
+    dma_from = dma_map_single(NULL, (void *) virt_from, __cu_len, DMA_TO_DEVICE);
+
+//    printk(KERN_ERR "dma transfer %X to %x len %X\n", __cu_from, __cu_to , __cu_len);
+
+    raw_local_irq_save(flag);
+//	do_gettimeofday(&tv);
+//	t3=tv.tv_sec*1000000LL+tv.tv_usec;
+
+    for (byte = 0, _n = __cu_len; byte < __cu_len;) 
+    {
+        int len = min(PAGE_SIZE - offset_into_page(virt_to + byte), _n);
+        pgd_t *pgd;
+        pud_t *pud;
+        pmd_t *pmd;
+        pte_t *pte;
+        unsigned long pg_addr;
+        unsigned long dma_to;
+
+        pg_addr = (virt_to+byte) & PAGE_MASK; /* address of start page */
+
+        if (pg_addr > TASK_SIZE)
+            pgd = pgd_offset_k(pg_addr);
+        else
+            pgd = pgd_offset_gate(current->mm, pg_addr);
+        BUG_ON(pgd_none(*pgd));
+        pud = pud_offset(pgd, pg_addr);
+        BUG_ON(pud_none(*pud));
+        pmd = pmd_offset(pud, pg_addr);
+        if (pmd_none(*pmd)) 
+        {
+            printk(KERN_ERR "pmd_none\n");
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        pte = pte_offset_map(pmd, pg_addr);
+        if (pte_none(*pte)) {
+            pte_unmap(pte);
+            printk(KERN_ERR "pte_none\n");
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        dma_to= (pte_val(*pte) & PAGE_MASK) + offset_into_page(virt_to + byte);
+        pte_unmap(pte);
+
+
+        if(dma_to<0x10000000 || dma_to>=0x30000000 ||
+            dma_from<0x10000000 || dma_from>=0x30000000)
+        {
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        _n -= len;
+
+        while(len>0)
+        {
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+    
+//            printk(KERN_ERR "mbus transfer %X to %x len %X\n", dma_from+byte, dma_to, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to) & 0xffff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+            // Start VDEC0_MBUS_R2 
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from+byte) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from+byte) & 0xffff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+            dma_to += len>0x1FFF ? 0x1FFF : len;
+            byte += len>0x1FFF ? 0x1FFF : len;
+            len-= len>0x1FFF ? 0x1FFF : len;
+        }
+    }
+    while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+//	do_gettimeofday(&tv);
+//	t2=tv.tv_sec*1000000LL+tv.tv_usec;
+    raw_local_irq_restore(flag);
+//    em86dma_time+=(t2-t1);
+//    em86dma_csum_time+=(t2-t3);
+    em86_stats[0]+=__cu_len;
+    em86_stats[2]+=1;
+unpin:
+    return _n;
+}
+
+EXPORT_SYMBOL(em86xx_mbus_alloc_dma);
+EXPORT_SYMBOL(em86xx_mbus_free_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma_void);
+EXPORT_SYMBOL(em86xx_mbus_wait);
+EXPORT_SYMBOL(em86xx_mbus_init);
+EXPORT_SYMBOL(mbus_setup_dma_linear);
+EXPORT_SYMBOL(mbus_setup_dma_double);
+EXPORT_SYMBOL(mbus_setup_dma_rectangle);
+EXPORT_SYMBOL(mbus_memcpy);
+
+EXPORT_SYMBOL(em86_stats);
+EXPORT_SYMBOL(memcpy);
+EXPORT_SYMBOL(__invoke_copy_to_user_dma);
diff -Naur linux-2.6.25.8/arch/mips/tangox/mbus.c.dma3 linux-2.6.25.8-clean/arch/mips/tangox/mbus.c.dma3
--- linux-2.6.25.8/arch/mips/tangox/mbus.c.dma3	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/mbus.c.dma3	2008-09-30 16:23:46.000000000 -0400
@@ -0,0 +1,1146 @@
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/r4kcache.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+
+#include "setup.h"
+
+#if !defined(CONFIG_TANGO2) && !defined(CONFIG_TANGO3)
+#error Undefined Sigma's chip!!!
+#endif
+
+#ifdef CONFIG_TANGO3
+#warning TANGO3 TODO IRQ assignment for W2/R2!!
+/* Temporary as no W2/R2 IRQ assigned yet. */
+#define LOG2_CPU_HOST_MBUS_W2_INT	62
+#define LOG2_CPU_HOST_MBUS_R2_INT	63
+
+/* Uncomment this only if W1/R1 can be used (typically not) */
+// #define WITH_MBUS_W1R1
+
+#endif /* CONFIG_TANGO3 */
+
+/*
+ * computed in prom.c
+ */
+extern unsigned long em8xxx_kmem_start;
+extern unsigned long em8xxx_kmem_size;
+
+long long em86_stats[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+static int usedma=0;
+
+/*
+ * switchbox stuffs
+ *
+ * We keep  track of  current mapping using  this globals  rather than
+ * reading hardware registers each time.
+ */
+static unsigned int g_sbox_map[SBOX_MAX];
+
+static inline void sbox_update_route(void)
+{
+	int i;
+#ifdef CONFIG_TANGO3
+	u64 data = 0; /* to cover two 32 bits registers */
+#else
+	unsigned int data = 0;
+#endif
+
+	for (i = SBOX_MAX - 1; i >= 0; --i)
+		data = (data << 4) | g_sbox_map[i];
+
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data & 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, (data >> 32) & 0xffffffff);
+#else
+	gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, data);
+#endif
+}
+
+static void sbox_reset(void)
+{
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xffffffff);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xff00ff00);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfdfdfdfd);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfd00fd00);
+#endif
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01010101);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01000100);
+#else
+	/* Leave W1/R1 alone. */
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d7d7d7d);
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d007d00);
+#endif
+}
+
+static void sbox_setup(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/* W0 initially disconnected */
+	g_sbox_map[SBOX_MBUS_W0] = 0xf;
+
+#if defined(CONFIG_TANGO3) && defined(WITH_MBUS_W1R1)
+	g_sbox_map[SBOX_MBUS_W1] = 0xf;
+#else
+	/* Leave W1 alone */
+	g_sbox_map[SBOX_MBUS_W1] = 0;
+#endif
+
+	g_sbox_map[SBOX_PCIMASTER] = 0xf;
+	g_sbox_map[SBOX_PCISLAVE] = SBOX_PCISLAVE + 1; /* Loopback */
+	g_sbox_map[SBOX_SATA1] = 0xf;
+	g_sbox_map[SBOX_IDEDVD] = 0xf;
+	g_sbox_map[SBOX_IDEFLASH] = 0xf;
+#ifdef CONFIG_TANGO3
+	g_sbox_map[SBOX_SATA2] = 0xf;
+	g_sbox_map[SBOX_MBUS_W2] = 0xf;
+#else
+	g_sbox_map[SBOX_UNUSED1] = 0xf;
+#endif
+
+	sbox_update_route();
+	wmb();
+
+	local_irq_restore(flags);
+}
+
+/*
+ * Connect given interface to R?/W? channel
+ */
+#ifdef CONFIG_TANGO3
+static int sbox_connect(int iface, int *channel, int any)
+#else
+static int sbox_connect(int iface)
+#endif
+{
+	unsigned long flags;
+	int res = 0;
+#ifdef CONFIG_TANGO3
+	int chan = 0;
+#endif
+
+	local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) {
+		*channel = 0; /* connected to W0/R0 */
+		goto done;
+#ifdef WITH_MBUS_W1R1
+	} else if (g_sbox_map[SBOX_MBUS_W1] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W1 + 1)) {
+		*channel = 1; /* connected to W1/R1 */
+		goto done;
+#endif
+	} else if (g_sbox_map[SBOX_MBUS_W2] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W2 + 1)) {
+		*channel = 2; /* connected to W2/R2 */
+		goto done;
+	}
+
+	if (g_sbox_map[iface] != 0xf) { /* connect to something else already */
+		res = 1;
+		goto done;
+	}
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf) {
+		chan++; /* try next */
+#ifdef WITH_MBUS_W1R1
+		if (g_sbox_map[SBOX_MBUS_W1] != 0xf) {
+#endif
+			if (any == 0) {
+#warning TO BE FIX in TANGO3 H/W!! (W2/R2 allocation)
+				res = 1; /* TANGO3 TODO: allocate W2/R2 once IRQ is available */
+				goto done;
+			}
+			chan++; /* try next */
+			if (g_sbox_map[SBOX_MBUS_W2] != 0xf)  {
+				res = 1; /* Both W0/W2 not available, and optional (W1 as well) */
+				goto done;
+			}
+#ifdef WITH_MBUS_W1R1
+		}
+#endif
+	}
+#else
+	/* Already connected? */
+	if (g_sbox_map[SBOX_MBUS_W0] == (iface + 1) && g_sbox_map[iface] == (SBOX_MBUS_W0 + 1)) 
+		goto done;
+
+	/* In use ? */
+	if (g_sbox_map[SBOX_MBUS_W0] != 0xf || g_sbox_map[iface] != 0xf) {
+		res = 1;
+		goto done;
+	}
+#endif /* CONFIG_TANGO3 */
+
+#ifdef CONFIG_TANGO3
+	switch(chan) {
+		case 0: g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W0 + 1; /* W0/R0 */
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: g_sbox_map[SBOX_MBUS_W1] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W1 + 1; /* W1/R1 */
+			break;
+#endif
+		case 2: g_sbox_map[SBOX_MBUS_W2] = iface + 1;
+			g_sbox_map[iface] = SBOX_MBUS_W2 + 1; /* W2/R2 */
+			break;
+
+		default: BUG();
+			break;
+	}
+	*channel = chan;
+#else
+	g_sbox_map[SBOX_MBUS_W0] = iface + 1;
+	g_sbox_map[iface] = SBOX_MBUS_W0 + 1;
+#endif
+	sbox_update_route();
+	wmb();
+
+done:
+	local_irq_restore(flags);
+
+	return res;
+}
+
+#ifdef CONFIG_TANGO3
+static void sbox_disconnect(int iface, int channel)
+#else
+static void sbox_disconnect(int iface)
+#endif
+{
+	unsigned long flags;
+
+	if (iface >= 0) {
+		local_irq_save(flags);
+
+#ifdef CONFIG_TANGO3
+		switch(channel) {
+			case 0: g_sbox_map[SBOX_MBUS_W0] = 0xf;
+				break;
+#ifdef WITH_MBUS_W1R1
+			case 1: g_sbox_map[SBOX_MBUS_W1] = 0xf;
+				break;
+#endif
+			case 2: g_sbox_map[SBOX_MBUS_W2] = 0xf;
+				break;
+
+			default: BUG();
+				break;
+		}
+#else
+		g_sbox_map[SBOX_MBUS_W0] = 0xf;
+#endif
+		g_sbox_map[iface] = 0xf;
+		sbox_update_route();
+		wmb();
+
+		local_irq_restore(flags);
+	}
+}
+
+static void sbox_init(void)
+{
+	sbox_setup();
+	sbox_reset();
+	// Is this early enough?
+    gbus_writel(REG_BASE_system_block + 0x240, 0x11f1f); // write
+    gbus_writel(REG_BASE_system_block + 0x244, 0x11f1f); // read
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fe4, 0x0700); // Unreset dbk channels
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3dcc, 0x8000); // dbk loopback
+    gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3fdc, 0x0003); // switchbox->WMV9
+    usedma=1;
+}
+
+
+/*
+ * mbus stuffs
+ *
+ * to  avoid   requesting/freeing  irq   each  time,  we   keep  given
+ * handler/args  for each  dma  request and  call  it in  our own  irq
+ * handler.
+ */
+#define MBUS_LINEAR_MAX		(0x2000 - 1)
+
+#ifdef CONFIG_TANGO3
+static mbus_irq_handler_t g_mbus_intr_handler[6];
+static void *g_mbus_intr_handler_arg[6];
+#else
+static mbus_irq_handler_t g_mbus_intr_handler[4];
+static void *g_mbus_intr_handler_arg[4];
+#endif
+
+/*
+ * alloc_dma, need to be called before setup, will try to connect
+ * needed sbox.
+ */
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int any)
+{
+	int x;
+
+#ifdef CONFIG_TANGO3
+	int channel = 0;
+
+	if (sbox_connect(sbox, &channel, any) != 0)
+		return -1;
+
+	switch(channel) {
+		case 0: { 	/* Using W0/R0 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W0_ADD + (x * 0x40);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: { 	/* Using W1/R1 pair */
+				x = (fromdev ? 0 : 2);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W1_ADD + (x * 0x40);
+			}
+			break;
+#endif
+		case 2: { 	/* Using W2/R2 pair */
+				x = (fromdev ? 0 : 1);
+				if (pirq)
+					*pirq = LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+				if (pregbase)
+					*pregbase = REG_BASE_host_interface + MIF_W2_ADD + (x * 0x40);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	if (sbox_connect(sbox) != 0)
+		return -1;
+
+	x = (fromdev ? 0 : 2);
+	if (pirq)
+		*pirq = LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE + x;
+	if (pregbase)
+		*pregbase = REG_BASE_host_interface + MIF_W0_ADD + x * 0x40;
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_TANGO3
+/* Convert MBUS register address to channel index */
+static inline int mbus_idx2channel(unsigned int regbase)
+{
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	static const int channel[6] = { 0, 1, 0, 1, 2, 2 };
+	return(channel[idx]);
+}
+#endif
+
+/*
+ * free_dma,  need to  be called  after  transfer is  done to  release
+ * switchbox.
+ */
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox)
+{
+	unsigned long flags;
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	local_irq_save(flags);
+	g_mbus_intr_handler[idx] = NULL;
+	wmb();
+	local_irq_restore(flags);
+
+#ifdef CONFIG_TANGO3
+	sbox_disconnect(sbox, mbus_idx2channel(regbase)); 
+#else
+	sbox_disconnect(sbox);
+#endif
+}
+
+/*
+ * irq handler for mbus interrupt
+ */
+static irqreturn_t mbus_intr(int irq, void *devinfo)
+{
+	int idx = irq - (LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE);
+
+#ifdef CONFIG_TANGO3
+	if (idx >= 4)
+		idx = irq - (LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE) + 4;
+#endif
+	if (g_mbus_intr_handler[idx]) {
+		mbus_irq_handler_t f;
+
+		f = g_mbus_intr_handler[idx];
+		g_mbus_intr_handler[idx] = NULL;
+		wmb();
+		f(irq, g_mbus_intr_handler_arg[idx]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * check if mbus is in use for given regbase
+ */
+static inline int mbus_inuse(unsigned int regbase)
+{
+	return (gbus_readl(regbase + MIF_cmd_offset) & 0x7) != 0;
+}
+
+/*
+ * setup mbus  register to start  a linear transfer (count  bytes from
+ * addr, where count < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_linear(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (linear): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, count);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x1);
+}
+
+/*
+ * setup mbus  register to start  a double transfer (count  bytes from
+ * addr and count2 bytes from addr2, where count < MBUS_LINEAR_MAX and
+ * count2 < MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_double(unsigned int regbase,
+					 unsigned int addr,
+					 unsigned int count,
+					 unsigned int addr2,
+					 unsigned int count2,
+					 unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address 0x%08x\n", addr);
+	if ((addr2 < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr2 >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address2 0x%08x\n", addr2);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (count2 << 16) | count);
+	gbus_writel(regbase + MIF_add2_skip_offset, addr2);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x2);
+}
+
+/*
+ * setup mbus  register to start  a rectangle transfer (horiz  * lines
+ * bytes  from  addr,  where  horiz  <  MBUS_LINEAR_MAX  and  lines  <
+ * MBUS_LINEAR_MAX)
+ */
+void mbus_setup_dma_rectangle(unsigned int regbase,
+					    unsigned int addr,
+					    unsigned int horiz,
+					    unsigned int lines,
+					    unsigned int flags)
+{
+#if !defined(CONFIG_SD_DIRECT_DMA) 
+	if ((addr < tangox_dma_address(CPHYSADDR(em8xxx_kmem_start))) || (addr >= (tangox_dma_address(CPHYSADDR(em8xxx_kmem_start)) + em8xxx_kmem_size)))
+		printk("MBUS Warning (rectangle): bad transfer address 0x%08x\n", addr);
+#endif
+
+	gbus_writel(regbase + MIF_add_offset, addr);
+	gbus_writel(regbase + MIF_cnt_offset, (lines << 16) | horiz);
+	gbus_writel(regbase + MIF_add2_skip_offset, horiz);
+	iob();
+	gbus_writel(regbase + MIF_cmd_offset, (flags<<2)|0x3);
+}
+
+/*
+ * register mbus interrupt if not done
+ */
+#ifdef CONFIG_TANGO3
+static inline void mbus_register_intr(int channel)
+#else
+static inline void mbus_register_intr(void)
+#endif
+{
+#ifdef CONFIG_TANGO3
+	static int done[3] = { 0, 0, 0 };
+
+	switch(channel) {
+		case 0: {	/* Use W0/R0 then */
+				if (done[0])
+					return;
+				done[0] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: {	/* Use W1/R1 instead */
+				if (done[1])
+					return;
+				done[1] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r1", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W1_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w1", NULL);
+			}
+			break;
+#endif
+		case 2: {	/* Use W2/R2 instead */
+				if (done[2])
+					return;
+				done[2] = 1;
+				request_irq(LOG2_CPU_HOST_MBUS_R2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_r2", NULL);
+				request_irq(LOG2_CPU_HOST_MBUS_W2_INT + IRQ_CONTROLLER_IRQ_BASE,
+					    mbus_intr, IRQF_DISABLED, "tangox_mbus_w2", NULL);
+			}
+			break;
+
+		default: BUG();
+			break;
+	}
+#else
+	static int done = 0;
+
+	if (done)
+		return;
+	done = 1;
+	/*
+	 * register irq handler for R0/W0 only (R1/W1 are not used for
+	 * the moment)
+	 */
+	request_irq(LOG2_CPU_HOST_MBUS_R0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_r0", NULL);
+
+	request_irq(LOG2_CPU_HOST_MBUS_W0_INT + IRQ_CONTROLLER_IRQ_BASE,
+		    mbus_intr, IRQF_DISABLED, "tangox_mbus_w0", NULL);
+
+#endif
+}
+
+/*
+ * setup void transaction 
+ */
+void em86xx_mbus_setup_dma_void(unsigned int regbase)
+{
+	while (mbus_inuse(regbase) != 0)
+		;
+	gbus_writel(regbase + MIF_cmd_offset, 4);
+}
+
+/*
+ * start  a   mbus  dma,   use  this  after   a  sucessfull   call  to
+ * em86xx_mbus_alloc_dma
+ */
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr,
+			  unsigned int count, mbus_irq_handler_t handler,
+			  void *arg, unsigned int tflags)
+{
+	unsigned long flags;
+	unsigned int horiz, lines, sz;
+	unsigned int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+
+	/*
+	 * make sure no one uses the mbus before
+	 */
+	if (unlikely(mbus_inuse(regbase))) {
+		printk(KERN_ERR "MBUS: error previous command is pending\n");
+		return 1;
+	}
+
+	/*
+	 * "register" given handler if any
+	 */
+	if (handler) {
+#ifdef CONFIG_TANGO3
+		mbus_register_intr(mbus_idx2channel(regbase));
+#else
+		mbus_register_intr();
+#endif
+		local_irq_save(flags);
+		g_mbus_intr_handler[idx] = handler;
+		g_mbus_intr_handler_arg[idx] = arg;
+		wmb();
+		local_irq_restore(flags);
+	}
+
+	/*
+	 * decide which dma function to use depending on count
+	 */
+	if (count <= MBUS_LINEAR_MAX) {
+		mbus_setup_dma_linear(regbase, addr, count, tflags);
+		return 0;
+	}
+
+	if (count <= (MBUS_LINEAR_MAX * 2)) {
+		mbus_setup_dma_double(regbase, addr, MBUS_LINEAR_MAX,
+				      addr + MBUS_LINEAR_MAX,
+				      count - MBUS_LINEAR_MAX, tflags);
+		return 0;
+	}
+
+	/*
+	 * we need to use rectangle, compute  horiz & lines
+	 * values to use
+	 */
+	for (idx = 0, horiz = 1, sz = count; (idx < 10) && ((sz & 0x01) == 0); ++idx, horiz <<= 1, sz >>= 1)
+		;
+	lines = count >> idx;
+	if ((horiz > MBUS_LINEAR_MAX) || (lines > MBUS_LINEAR_MAX)) {
+		printk(KERN_ERR "MBUS: can't handle rectangle transfer "
+		       "of %d bytes (h: %d, v: %d)\n", count, horiz, lines);
+		BUG();
+	}
+	mbus_setup_dma_rectangle(regbase, addr, horiz, lines, tflags);
+
+	return 0;
+}
+
+/*
+ * Bit 0/8: MBUS_R0_SBOX
+ * Bit 1/9: MBUS_R1_SBOX
+ * Bit 2/10: PCI_MASTER_SBOX
+ * Bit 3/11: PCI_SLAVE_SBOX
+ * Bit 4/12: SATA1_SBOX
+ * Bit 5/13: IDE_ISA_SBOX
+ * Bit 6/14: IDE_DVD_SBOX
+ * Bit 7/15: SATA2_SBOX (Tango3)
+ * Bit 16/24: SBOX_MBUS_W0
+ * Bit 17/25: SBOX_MBUS_W1
+ * Bit 18/26: SBOX_PCI_MASTER
+ * Bit 19/27: SBOX_PCI_SLAVE
+ * Bit 20/28: SBOX_SATA1
+ * Bit 21/29: SBOX_ISA
+ * Bit 22/30: SBOX_DVD
+ * Bit 23/31: SBOX_SATA2 (Tango3)
+ *
+ * Bit 32/40: MBUS_R2_SBOX (Tango3)
+ * Bit 48/50: SBOX_MBUS_W2 (Tango3)
+ */
+#ifdef CONFIG_TANGO3
+static const u64 sbox_reset_vals[4][6] = {
+	{ 0x0000000001011010ULL, 0x0000000002021010ULL, 0x0000000010100101ULL, 0x0000000010100202ULL, 0x0101000000001010ULL, 0x0000010110100000ULL },
+	{ 0x0000000001012020ULL, 0x0000000002022020ULL, 0x0000000020200101ULL, 0x0000000020200202ULL, 0x0101000000002020ULL, 0x0000010120200000ULL },
+	{ 0x0000000001014040ULL, 0x0000000002024040ULL, 0x0000000040400101ULL, 0x0000000040400202ULL, 0x0101000000004040ULL, 0x0000010140400000ULL },
+	{ 0x0000000001018080ULL, 0x0000000002028080ULL, 0x0000000080800101ULL, 0x0000000080800202ULL, 0x0101000000008080ULL, 0x0000010180800000ULL },
+};
+#else
+static const unsigned int sbox_reset_vals[2][4] = {
+	{ 0x01012020, 0x02022020, 0x20200101, 0x20200202 },
+	{ 0x01014040, 0x02024040, 0x40400101, 0x40400202 }
+};
+#endif
+
+/*
+ * clear MBUS transaction for given regbase/sbox
+ */
+static void mbus_reset(unsigned int regbase, int sbox)
+{
+	int midx;
+	int sidx;
+
+#ifdef CONFIG_TANGO3
+	unsigned int rl, rh;
+
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_SATA1;
+
+	if (((midx < 0) || (midx > 5)) || ((sidx < 0) || (sidx > 3))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+	rl = sbox_reset_vals[sidx][midx] & 0xffffffff;
+	rh = (sbox_reset_vals[sidx][midx] >> 32) & 0xffffffff;
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh);
+	iob();
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET, rl & 0xff00ff00);
+	if (rh) 
+		gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh & 0xff00ff00);
+	iob();
+#else
+	midx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	sidx = sbox - SBOX_IDEFLASH;
+
+	if (((midx < 0) || (midx > 3)) || ((sidx < 0) || (sidx > 2))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n",
+		       midx, sidx);
+		return;
+	}
+
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx]);
+	iob();
+	gbus_writel(REG_BASE_host_interface + SBOX_FIFO_RESET,
+		    sbox_reset_vals[sidx][midx] & 0xff00ff00);
+	iob();
+#endif
+}
+
+/* Fancy version of memcpy, both dst and src need to be physical address */
+/* The channels have to be allocated already */
+int mbus_memcpy(unsigned int regbase, unsigned int dst, unsigned int src, unsigned int size)
+{
+	/* Save the old SBOX route */
+	unsigned int sbox_route;
+	unsigned int w_base;
+	unsigned int r_base;
+	int channel = 0;
+/* 
+ * TRANSFER defines 4 bits, bit 0: followed by void (1) or not (0),
+ * bit 1: tiled buffer or not (tango3 only).
+ * bit 3-2: 0 = 8 bit, 1 = 16 bit, 2 = 32 bit (tango3 only).
+ */
+#ifdef CONFIG_TANGO3
+#define TRANSFER    0x1 /* or 0x9 for 32 bit transfer */
+#else
+#define TRANSFER    0x1
+#endif
+
+#ifdef CONFIG_TANGO3
+	channel = mbus_idx2channel(regbase);
+
+	if (channel == 0) /* W0/R0 channels are used */
+#endif
+	{
+		w_base = REG_BASE_host_interface + MIF_W0_ADD;
+		r_base = REG_BASE_host_interface + MIF_R0_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xffffff0f;
+
+		/* Hook up W0/R0 and left W1/R1 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff01);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W0 */
+			printk("MBUS: need to reset W0 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#ifdef CONFIG_TANGO3
+#ifdef WITH_MBUS_W1R1
+	else if (channel == 1) { /* W1/R1 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W1_ADD;
+		r_base = REG_BASE_host_interface + MIF_R1_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE) & 0xfffffff0;
+
+		/* Hook up W1/R1 and left W0/R0 the same as before */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff20);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W1 */
+			printk("MBUS: need to reset W1 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+	}
+#endif
+	else { /* channel == 2: W2/R2 channels are used */
+		w_base = REG_BASE_host_interface + MIF_W2_ADD;
+		r_base = REG_BASE_host_interface + MIF_R2_ADD;
+		sbox_route = gbus_readl(REG_BASE_host_interface + SBOX_ROUTE2);
+
+		/* Hook up W2/R2 */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, 0xfffffff9);
+	
+		if (em86xx_mbus_setup_dma(w_base, dst, size, NULL, NULL, TRANSFER) != 0) {
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		} else if (em86xx_mbus_setup_dma(r_base, src, size, NULL, NULL, TRANSFER) != 0) {
+			/* TODO: should reset W2 */
+			printk("MBUS: need to reset W2 channel.\n");
+			gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			return(0);
+		}
+
+		/* TODO: a timeout mechanism should be added to reset W0/R0 */
+		while (mbus_inuse(r_base) != 0)
+			;
+		while (mbus_inuse(w_base) != 0)
+			;
+
+		/* Restore SBOX route once we're done */
+		gbus_writel(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+	}
+#endif
+
+	return(size);
+}
+
+/*
+ * busy wait  for current mbus transfer  to finish, will  not wait for
+ * more than 20 ms. 0 is ok, 1 timeout, 2 for timeout + reset error.
+ */
+#define MBUS_TIMEOUT	20000
+
+int em86xx_mbus_wait(unsigned int regbase, int sbox)
+{
+	int timeout;
+
+	/* wait for mbus to be released */
+	timeout = 0;
+	do {
+		if (!mbus_inuse(regbase))
+			break;
+		udelay(1);
+		timeout++;
+	} while (timeout < MBUS_TIMEOUT);
+
+	if (timeout < MBUS_TIMEOUT ) {
+		/* ok */
+		if (sbox == SBOX_IDEFLASH){
+                        int i;
+			unsigned int pb_count = 0;
+
+			pb_count = gbus_readl(REG_BASE_host_interface + 
+					       PB_automode_control) & 0xffff;
+
+                        for (i = 0; pb_count && (i < MBUS_TIMEOUT); i++){
+                                udelay(1);
+				pb_count = gbus_readl(REG_BASE_host_interface +
+					       PB_automode_control) & 0xffff;
+			}
+
+                        if (i < MBUS_TIMEOUT) 
+				return 0;
+
+		} else
+			return 0;
+	}
+
+	/* timeout, let's dump some registers ! */
+        if (sbox == SBOX_IDEFLASH) {
+  		printk("MBUS timeout : MBUS CMD = %ld, PB Automode = %08x\n",
+                	(unsigned long)gbus_readl(regbase + MIF_cmd_offset) & 0x7,
+                	(unsigned int)gbus_readl(REG_BASE_host_interface + PB_automode_control));
+        } else {
+		printk("MBUS timeout : MBUS CMD = %08lx\n",
+			gbus_readl(regbase + MIF_cmd_offset) & 0x7);
+	}
+
+	printk("MBUS registers : %08lx %08lx %08lx %08lx\n",
+	       gbus_readl(regbase + MIF_add_offset),
+	       gbus_readl(regbase + MIF_cnt_offset),
+	       gbus_readl(regbase + MIF_add2_skip_offset),
+	       gbus_readl(regbase + MIF_cmd_offset));
+
+	printk(KERN_ERR "MBUS fails, resetting %d ..\n", sbox);
+	mbus_reset(regbase, sbox);
+
+	/* If not able to reset, return  1, so the DMA can be disabled
+	   accordingly  */
+	return mbus_inuse(regbase) ? 0 : 1;
+}
+
+int em86xx_mbus_init(void)
+{
+	static int done = 0;
+
+	if (done)
+		return 0;
+	done = 1;
+
+	/* reset sbox to default values */
+	sbox_init();
+
+	/* Give better MBUS bandwidth for Wx/Rx channel */
+#ifdef CONFIG_TANGO3
+	gbus_writel(REG_BASE_system_block + MARB_mid01_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid21_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid03_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid23_cfg, 0x12005);
+#ifdef WITH_MBUS_W1R1
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x12005);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x12005);
+#endif
+#else
+	gbus_writel(REG_BASE_system_block + MARB_mid02_cfg, 0x11f1f);
+	gbus_writel(REG_BASE_system_block + MARB_mid22_cfg, 0x11f1f);
+#endif
+
+	return 0;
+}
+
+#define offset_into_page(x) ((x) & (PAGE_SIZE - 1))
+
+static inline unsigned long tangox_getxtal(void)
+{
+	return(gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt));
+}
+
+extern void *memcpy2(void *__to, __const__ void *__from, size_t __n);
+void *memcpy(void *__to, __const__ void *__from, size_t __n)
+{
+    unsigned long virt_to = (unsigned long) __to;
+    unsigned long virt_from = (unsigned long) __from;
+    dma_addr_t dma_from;
+    dma_addr_t dma_to;
+    int len=__n;
+    int flag;
+    unsigned long t1,t2;
+
+
+    if(__n<512 || !usedma || virt_from < 0x90000000 || virt_to < 0x90000000 ||
+        virt_from>=0xA0000000 || virt_to >=0xA0000000)
+    {
+        em86_stats[10]+=__n;
+        return memcpy2(__to, __from, __n);
+    }
+
+    t1=tangox_getxtal();
+
+
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__n)&0xF) flush_dcache_line((virt_to+__n)&~0xF);
+
+    dma_from=virt_from;
+    dma_to=virt_to;
+
+    raw_local_irq_save(flag);
+    while(len>0)
+    {
+        int curlen= len>0x1FFF ? 0x1FFF : len;
+        blast_dcache_range(dma_from, dma_from+curlen);
+        blast_inv_dcache_range(dma_to, dma_to+curlen);
+        while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+
+//            printk(KERN_ERR "mbus transfer %X to %x len %X\n", dma_from+byte, dma_to, len>0x1FFF ? 0x1FFF : len);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to) & 0xffff);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to) & 0x3fff0000) >> 16);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, curlen);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+        // Start VDEC0_MBUS_R2 
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from) & 0xffff);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from) & 0x3fff0000) >> 16);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, curlen);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+        gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+        dma_to += curlen;
+        dma_from += curlen;
+        len-= curlen;
+    }
+    while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+    t2=tangox_getxtal();
+    em86_stats[12]+=__n;
+    em86_stats[13]+=(t2-t1);
+    raw_local_irq_restore(flag);
+    return __to;
+}
+
+size_t __invoke_copy_to_user_dma(void __user * __cu_to, const void * __cu_from, long __cu_len)
+{
+    unsigned long virt_to = (unsigned long) __cu_to;
+    unsigned long virt_from = (unsigned long) __cu_from;
+    dma_addr_t dma_from;
+    int byte;
+    unsigned long _n;
+    int flag;
+    unsigned long t1,t2;
+
+    if(virt_to >= 0x80000000)
+    {
+        memcpy(__cu_to, __cu_from, __cu_len);
+        return 0;
+    }
+
+    if(__cu_len<512 || !usedma || virt_from >= 0xC0000000 || virt_to >= 0x80000000)
+    {
+        em86_stats[14]+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    if(!(virt_addr_valid(__cu_from)) ||
+        !(virt_addr_valid(__cu_from + __cu_len)))
+    {
+        em86_stats[14]+=__cu_len;
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+    }
+
+    // Verify all pages exist
+    for(byte = 0; byte < __cu_len; byte+=PAGE_SIZE)
+    {
+        __put_user_check(0, (unsigned char *) (virt_to+byte), 1);
+    }
+    __put_user_check(0, (unsigned char *) (virt_to+__cu_len-1), 1);
+
+    t1=tangox_getxtal();
+
+    // If the virt_to is not aligned we need to flush the data before it
+    if(virt_to&0xF) flush_dcache_line(virt_to&~0xF);
+    // If the virt_to+cu_len is not aligned we need to flush the data after it
+    if((virt_to+__cu_len)&0xF) flush_dcache_line((virt_to+__cu_len)&~0xF);
+
+    dma_from = virt_from;
+
+    // printk(KERN_ERR "dma transfer %X to %x len %X\n", __cu_from, __cu_to , __cu_len);
+
+    raw_local_irq_save(flag);
+
+    for (byte = 0, _n = __cu_len; byte < __cu_len;) 
+    {
+        int len = min(PAGE_SIZE - offset_into_page(virt_to + byte), _n);
+        pgd_t *pgd;
+        pud_t *pud;
+        pmd_t *pmd;
+        pte_t *pte;
+        unsigned long pg_addr;
+        unsigned long dma_to;
+
+        pg_addr = (virt_to+byte) & PAGE_MASK; /* address of start page */
+
+        if (pg_addr > TASK_SIZE)
+            pgd = pgd_offset_k(pg_addr);
+        else
+            pgd = pgd_offset_gate(current->mm, pg_addr);
+        BUG_ON(pgd_none(*pgd));
+        pud = pud_offset(pgd, pg_addr);
+        BUG_ON(pud_none(*pud));
+        pmd = pmd_offset(pud, pg_addr);
+        if (pmd_none(*pmd)) 
+        {
+            printk(KERN_ERR "pmd_none\n");
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        pte = pte_offset_map(pmd, pg_addr);
+        if (pte_none(*pte)) {
+            pte_unmap(pte);
+            printk(KERN_ERR "pte_none\n");
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            goto unpin;
+        }
+        dma_to= (pte_val(*pte) & PAGE_MASK) + offset_into_page(virt_to + byte);
+        pte_unmap(pte);
+
+
+        if(dma_to<0x10000000 || dma_to>=0x30000000)
+        {
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+            em86_stats[14]+=__cu_len;
+            raw_local_irq_restore(flag);
+            printk(KERN_ERR "invalid copy to user %08X\n",dma_to);
+            goto unpin;
+        }
+        _n -= len;
+
+        while(len>0)
+        {
+            int curlen=len>0x1FFF ? 0x1FFF : len;
+
+            // printk(KERN_ERR "mbus transfer %X to %x len %X\n", dma_from+byte, dma_to, curlen);
+            
+            blast_dcache_range(dma_from+byte, dma_from+byte+curlen);
+            blast_inv_dcache_range(virt_to+byte, virt_to+byte+curlen);
+
+            while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+    
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac0, (dma_to) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac4, ((dma_to) & 0x3fff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ac8, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3acc, 0);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3ad8, 0x5);
+            // Start VDEC0_MBUS_R2 
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b00, (dma_from+byte) & 0xffff);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b04, ((dma_from+byte) & 0x3fff0000) >> 16);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b08, len>0x1FFF ? 0x1FFF : len);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b0c, 0);
+            gbus_writel(DMEM_BASE_mpeg_engine_0 + 0x3b18, 0x5);
+            dma_to += curlen;
+            byte += curlen;
+            len-= curlen;
+        }
+    }
+    while ((gbus_readl(DMEM_BASE_mpeg_engine_0 + 0x3ad8) & 0x7) != 0);
+//	do_gettimeofday(&tv);
+//	t2=tv.tv_sec*1000000LL+tv.tv_usec;
+    raw_local_irq_restore(flag);
+//    em86dma_time+=(t2-t1);
+//    em86dma_csum_time+=(t2-t3);
+    em86_stats[0]+=__cu_len;
+    em86_stats[2]+=1;
+    t2=tangox_getxtal();
+    em86_stats[1]+=(t2-t1);
+unpin:
+    return _n;
+}
+
+EXPORT_SYMBOL(em86xx_mbus_alloc_dma);
+EXPORT_SYMBOL(em86xx_mbus_free_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma_void);
+EXPORT_SYMBOL(em86xx_mbus_wait);
+EXPORT_SYMBOL(em86xx_mbus_init);
+EXPORT_SYMBOL(mbus_setup_dma_linear);
+EXPORT_SYMBOL(mbus_setup_dma_double);
+EXPORT_SYMBOL(mbus_setup_dma_rectangle);
+EXPORT_SYMBOL(mbus_memcpy);
+
+EXPORT_SYMBOL(em86_stats);
+EXPORT_SYMBOL(memcpy);
+EXPORT_SYMBOL(__invoke_copy_to_user_dma);
diff -Naur linux-2.6.25.8/arch/mips/tangox/mbus.dis linux-2.6.25.8-clean/arch/mips/tangox/mbus.dis
--- linux-2.6.25.8/arch/mips/tangox/mbus.dis	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/mbus.dis	2009-01-19 15:22:26.000000000 -0500
@@ -0,0 +1,1937 @@
+
+mbus.o:     file format elf32-tradlittlemips
+
+Disassembly of section .text:
+
+00000000 <mbus_intr>:
+       0:	2482ffef 	addiu	v0,a0,-17
+       4:	00022880 	sll	a1,v0,0x2
+       8:	3c020000 	lui	v0,0x0
+       c:	27bdffe8 	addiu	sp,sp,-24
+      10:	244200cc 	addiu	v0,v0,204
+      14:	afbf0010 	sw	ra,16(sp)
+      18:	00a21021 	addu	v0,a1,v0
+      1c:	8c430000 	lw	v1,0(v0)
+      20:	10600009 	beqz	v1,48 <mbus_intr+0x48>
+      24:	8fbf0010 	lw	ra,16(sp)
+      28:	ac400000 	sw	zero,0(v0)
+      2c:	0000000f 	sync
+      30:	3c020000 	lui	v0,0x0
+      34:	244200dc 	addiu	v0,v0,220
+      38:	00a21021 	addu	v0,a1,v0
+      3c:	0060f809 	jalr	v1
+      40:	8c450000 	lw	a1,0(v0)
+      44:	8fbf0010 	lw	ra,16(sp)
+      48:	24020001 	li	v0,1
+      4c:	03e00008 	jr	ra
+      50:	27bd0018 	addiu	sp,sp,24
+
+00000054 <mbus_setup_dma_rectangle>:
+      54:	27bdffd8 	addiu	sp,sp,-40
+      58:	afb40020 	sw	s4,32(sp)
+      5c:	afb3001c 	sw	s3,28(sp)
+      60:	afb20018 	sw	s2,24(sp)
+      64:	afb10014 	sw	s1,20(sp)
+      68:	afb00010 	sw	s0,16(sp)
+      6c:	3c020000 	lui	v0,0x0
+      70:	afbf0024 	sw	ra,36(sp)
+      74:	8c430000 	lw	v1,0(v0)
+      78:	3c021fff 	lui	v0,0x1fff
+      7c:	3442ffff 	ori	v0,v0,0xffff
+      80:	00621824 	and	v1,v1,v0
+      84:	00a3102b 	sltu	v0,a1,v1
+      88:	00a08021 	move	s0,a1
+      8c:	00808821 	move	s1,a0
+      90:	00c09021 	move	s2,a2
+      94:	00e09821 	move	s3,a3
+      98:	14400007 	bnez	v0,b8 <mbus_setup_dma_rectangle+0x64>
+      9c:	8fb40038 	lw	s4,56(sp)
+      a0:	3c020000 	lui	v0,0x0
+      a4:	8c420000 	lw	v0,0(v0)
+      a8:	00621021 	addu	v0,v1,v0
+      ac:	00a2102b 	sltu	v0,a1,v0
+      b0:	14400005 	bnez	v0,c8 <mbus_setup_dma_rectangle+0x74>
+      b4:	02003021 	move	a2,s0
+      b8:	3c040000 	lui	a0,0x0
+      bc:	0c000000 	jal	0 <mbus_intr>
+      c0:	24840000 	addiu	a0,a0,0
+      c4:	02003021 	move	a2,s0
+      c8:	02202821 	move	a1,s1
+      cc:	0c000000 	jal	0 <mbus_intr>
+      d0:	24040001 	li	a0,1
+      d4:	00133400 	sll	a2,s3,0x10
+      d8:	00d23025 	or	a2,a2,s2
+      dc:	26250004 	addiu	a1,s1,4
+      e0:	0c000000 	jal	0 <mbus_intr>
+      e4:	24040001 	li	a0,1
+      e8:	02403021 	move	a2,s2
+      ec:	24040001 	li	a0,1
+      f0:	0c000000 	jal	0 <mbus_intr>
+      f4:	26250008 	addiu	a1,s1,8
+      f8:	0000000f 	sync
+      fc:	3c02a000 	lui	v0,0xa000
+     100:	8c400000 	lw	zero,0(v0)
+     104:	00000000 	nop
+     108:	00143080 	sll	a2,s4,0x2
+     10c:	2625000c 	addiu	a1,s1,12
+     110:	8fbf0024 	lw	ra,36(sp)
+     114:	8fb40020 	lw	s4,32(sp)
+     118:	8fb3001c 	lw	s3,28(sp)
+     11c:	8fb20018 	lw	s2,24(sp)
+     120:	8fb10014 	lw	s1,20(sp)
+     124:	8fb00010 	lw	s0,16(sp)
+     128:	34c60003 	ori	a2,a2,0x3
+     12c:	24040001 	li	a0,1
+     130:	08000000 	j	0 <mbus_intr>
+     134:	27bd0028 	addiu	sp,sp,40
+
+00000138 <mbus_setup_dma_double>:
+     138:	27bdffd0 	addiu	sp,sp,-48
+     13c:	afb50024 	sw	s5,36(sp)
+     140:	afb40020 	sw	s4,32(sp)
+     144:	afb3001c 	sw	s3,28(sp)
+     148:	afb20018 	sw	s2,24(sp)
+     14c:	afb10014 	sw	s1,20(sp)
+     150:	afb00010 	sw	s0,16(sp)
+     154:	3c020000 	lui	v0,0x0
+     158:	afbf0028 	sw	ra,40(sp)
+     15c:	8c430000 	lw	v1,0(v0)
+     160:	3c021fff 	lui	v0,0x1fff
+     164:	3442ffff 	ori	v0,v0,0xffff
+     168:	00621824 	and	v1,v1,v0
+     16c:	00a3102b 	sltu	v0,a1,v1
+     170:	00a08821 	move	s1,a1
+     174:	00809021 	move	s2,a0
+     178:	00c0a021 	move	s4,a2
+     17c:	00e08021 	move	s0,a3
+     180:	8fb30040 	lw	s3,64(sp)
+     184:	14400007 	bnez	v0,1a4 <mbus_setup_dma_double+0x6c>
+     188:	8fb50044 	lw	s5,68(sp)
+     18c:	3c020000 	lui	v0,0x0
+     190:	8c420000 	lw	v0,0(v0)
+     194:	00621021 	addu	v0,v1,v0
+     198:	00a2102b 	sltu	v0,a1,v0
+     19c:	14400005 	bnez	v0,1b4 <mbus_setup_dma_double+0x7c>
+     1a0:	3c020000 	lui	v0,0x0
+     1a4:	3c040000 	lui	a0,0x0
+     1a8:	0c000000 	jal	0 <mbus_intr>
+     1ac:	24840000 	addiu	a0,a0,0
+     1b0:	3c020000 	lui	v0,0x0
+     1b4:	8c430000 	lw	v1,0(v0)
+     1b8:	3c021fff 	lui	v0,0x1fff
+     1bc:	3442ffff 	ori	v0,v0,0xffff
+     1c0:	00621824 	and	v1,v1,v0
+     1c4:	0203102b 	sltu	v0,s0,v1
+     1c8:	14400006 	bnez	v0,1e4 <mbus_setup_dma_double+0xac>
+     1cc:	3c020000 	lui	v0,0x0
+     1d0:	8c420000 	lw	v0,0(v0)
+     1d4:	00621021 	addu	v0,v1,v0
+     1d8:	0202102b 	sltu	v0,s0,v0
+     1dc:	14400006 	bnez	v0,1f8 <mbus_setup_dma_double+0xc0>
+     1e0:	02203021 	move	a2,s1
+     1e4:	3c040000 	lui	a0,0x0
+     1e8:	24840000 	addiu	a0,a0,0
+     1ec:	0c000000 	jal	0 <mbus_intr>
+     1f0:	02002821 	move	a1,s0
+     1f4:	02203021 	move	a2,s1
+     1f8:	02402821 	move	a1,s2
+     1fc:	0c000000 	jal	0 <mbus_intr>
+     200:	24040001 	li	a0,1
+     204:	00133400 	sll	a2,s3,0x10
+     208:	00d43025 	or	a2,a2,s4
+     20c:	26450004 	addiu	a1,s2,4
+     210:	0c000000 	jal	0 <mbus_intr>
+     214:	24040001 	li	a0,1
+     218:	02003021 	move	a2,s0
+     21c:	24040001 	li	a0,1
+     220:	0c000000 	jal	0 <mbus_intr>
+     224:	26450008 	addiu	a1,s2,8
+     228:	0000000f 	sync
+     22c:	3c02a000 	lui	v0,0xa000
+     230:	8c400000 	lw	zero,0(v0)
+     234:	00000000 	nop
+     238:	00153080 	sll	a2,s5,0x2
+     23c:	2645000c 	addiu	a1,s2,12
+     240:	8fbf0028 	lw	ra,40(sp)
+     244:	8fb50024 	lw	s5,36(sp)
+     248:	8fb40020 	lw	s4,32(sp)
+     24c:	8fb3001c 	lw	s3,28(sp)
+     250:	8fb20018 	lw	s2,24(sp)
+     254:	8fb10014 	lw	s1,20(sp)
+     258:	8fb00010 	lw	s0,16(sp)
+     25c:	34c60002 	ori	a2,a2,0x2
+     260:	24040001 	li	a0,1
+     264:	08000000 	j	0 <mbus_intr>
+     268:	27bd0030 	addiu	sp,sp,48
+
+0000026c <mbus_setup_dma_linear>:
+     26c:	27bdffd8 	addiu	sp,sp,-40
+     270:	afb3001c 	sw	s3,28(sp)
+     274:	afb20018 	sw	s2,24(sp)
+     278:	afb10014 	sw	s1,20(sp)
+     27c:	afb00010 	sw	s0,16(sp)
+     280:	3c020000 	lui	v0,0x0
+     284:	afbf0020 	sw	ra,32(sp)
+     288:	8c430000 	lw	v1,0(v0)
+     28c:	3c021fff 	lui	v0,0x1fff
+     290:	3442ffff 	ori	v0,v0,0xffff
+     294:	00621824 	and	v1,v1,v0
+     298:	00a3102b 	sltu	v0,a1,v1
+     29c:	00a08021 	move	s0,a1
+     2a0:	00808821 	move	s1,a0
+     2a4:	00c09021 	move	s2,a2
+     2a8:	14400007 	bnez	v0,2c8 <mbus_setup_dma_linear+0x5c>
+     2ac:	00e09821 	move	s3,a3
+     2b0:	3c020000 	lui	v0,0x0
+     2b4:	8c420000 	lw	v0,0(v0)
+     2b8:	00621021 	addu	v0,v1,v0
+     2bc:	00a2102b 	sltu	v0,a1,v0
+     2c0:	14400005 	bnez	v0,2d8 <mbus_setup_dma_linear+0x6c>
+     2c4:	02003021 	move	a2,s0
+     2c8:	3c040000 	lui	a0,0x0
+     2cc:	0c000000 	jal	0 <mbus_intr>
+     2d0:	24840000 	addiu	a0,a0,0
+     2d4:	02003021 	move	a2,s0
+     2d8:	02202821 	move	a1,s1
+     2dc:	0c000000 	jal	0 <mbus_intr>
+     2e0:	24040001 	li	a0,1
+     2e4:	02403021 	move	a2,s2
+     2e8:	24040001 	li	a0,1
+     2ec:	0c000000 	jal	0 <mbus_intr>
+     2f0:	26250004 	addiu	a1,s1,4
+     2f4:	0000000f 	sync
+     2f8:	3c02a000 	lui	v0,0xa000
+     2fc:	8c400000 	lw	zero,0(v0)
+     300:	00000000 	nop
+     304:	00133080 	sll	a2,s3,0x2
+     308:	2625000c 	addiu	a1,s1,12
+     30c:	8fbf0020 	lw	ra,32(sp)
+     310:	8fb3001c 	lw	s3,28(sp)
+     314:	8fb20018 	lw	s2,24(sp)
+     318:	8fb10014 	lw	s1,20(sp)
+     31c:	8fb00010 	lw	s0,16(sp)
+     320:	34c60001 	ori	a2,a2,0x1
+     324:	24040001 	li	a0,1
+     328:	08000000 	j	0 <mbus_intr>
+     32c:	27bd0028 	addiu	sp,sp,40
+
+00000330 <em86xx_mbus_alloc_dma>:
+     330:	27bdffd8 	addiu	sp,sp,-40
+     334:	afb3001c 	sw	s3,28(sp)
+     338:	afb20018 	sw	s2,24(sp)
+     33c:	afb10014 	sw	s1,20(sp)
+     340:	afbf0020 	sw	ra,32(sp)
+     344:	afb00010 	sw	s0,16(sp)
+     348:	00a09821 	move	s3,a1
+     34c:	00c09021 	move	s2,a2
+     350:	00e08821 	move	s1,a3
+     354:	41706000 	di	s0
+     358:	32100001 	andi	s0,s0,0x1
+     35c:	000000c0 	ehb
+     360:	3c030000 	lui	v1,0x0
+     364:	8c6500ac 	lw	a1,172(v1)
+     368:	24870001 	addiu	a3,a0,1
+     36c:	14a70009 	bne	a1,a3,394 <em86xx_mbus_alloc_dma+0x64>
+     370:	2402000f 	li	v0,15
+     374:	246300ac 	addiu	v1,v1,172
+     378:	00041080 	sll	v0,a0,0x2
+     37c:	00431021 	addu	v0,v0,v1
+     380:	8c430000 	lw	v1,0(v0)
+     384:	24020001 	li	v0,1
+     388:	1062001e 	beq	v1,v0,404 <em86xx_mbus_alloc_dma+0xd4>
+     38c:	00003021 	move	a2,zero
+     390:	2402000f 	li	v0,15
+     394:	14a2001b 	bne	a1,v0,404 <em86xx_mbus_alloc_dma+0xd4>
+     398:	24060001 	li	a2,1
+     39c:	3c030000 	lui	v1,0x0
+     3a0:	00041080 	sll	v0,a0,0x2
+     3a4:	246600ac 	addiu	a2,v1,172
+     3a8:	00462021 	addu	a0,v0,a2
+     3ac:	8c820000 	lw	v0,0(a0)
+     3b0:	14450013 	bne	v0,a1,400 <em86xx_mbus_alloc_dma+0xd0>
+     3b4:	24020001 	li	v0,1
+     3b8:	ac6700ac 	sw	a3,172(v1)
+     3bc:	ac820000 	sw	v0,0(a0)
+     3c0:	3c020000 	lui	v0,0x0
+     3c4:	24c5fffc 	addiu	a1,a2,-4
+     3c8:	244400c8 	addiu	a0,v0,200
+     3cc:	00003021 	move	a2,zero
+     3d0:	8c830000 	lw	v1,0(a0)
+     3d4:	00061100 	sll	v0,a2,0x4
+     3d8:	2484fffc 	addiu	a0,a0,-4
+     3dc:	1485fffc 	bne	a0,a1,3d0 <em86xx_mbus_alloc_dma+0xa0>
+     3e0:	00433025 	or	a2,v0,v1
+     3e4:	3c050002 	lui	a1,0x2
+     3e8:	34a590a8 	ori	a1,a1,0x90a8
+     3ec:	0c000000 	jal	0 <mbus_intr>
+     3f0:	24040001 	li	a0,1
+     3f4:	0000000f 	sync
+     3f8:	08000101 	j	404 <em86xx_mbus_alloc_dma+0xd4>
+     3fc:	00003021 	move	a2,zero
+     400:	24060001 	li	a2,1
+     404:	12000002 	beqz	s0,410 <em86xx_mbus_alloc_dma+0xe0>
+     408:	41606000 	di
+     40c:	41606020 	ei
+     410:	000000c0 	ehb
+     414:	14c0000f 	bnez	a2,454 <em86xx_mbus_alloc_dma+0x124>
+     418:	2402ffff 	li	v0,-1
+     41c:	24020002 	li	v0,2
+     420:	00001821 	move	v1,zero
+     424:	12200003 	beqz	s1,434 <em86xx_mbus_alloc_dma+0x104>
+     428:	0053180a 	movz	v1,v0,s3
+     42c:	24620011 	addiu	v0,v1,17
+     430:	ae220000 	sw	v0,0(s1)
+     434:	12400007 	beqz	s2,454 <em86xx_mbus_alloc_dma+0x124>
+     438:	00001021 	move	v0,zero
+     43c:	3c020002 	lui	v0,0x2
+     440:	3442b000 	ori	v0,v0,0xb000
+     444:	00031980 	sll	v1,v1,0x6
+     448:	00621821 	addu	v1,v1,v0
+     44c:	ae430000 	sw	v1,0(s2)
+     450:	00001021 	move	v0,zero
+     454:	8fbf0020 	lw	ra,32(sp)
+     458:	8fb3001c 	lw	s3,28(sp)
+     45c:	8fb20018 	lw	s2,24(sp)
+     460:	8fb10014 	lw	s1,20(sp)
+     464:	8fb00010 	lw	s0,16(sp)
+     468:	03e00008 	jr	ra
+     46c:	27bd0028 	addiu	sp,sp,40
+
+00000470 <em86xx_mbus_init>:
+     470:	27bdffe8 	addiu	sp,sp,-24
+     474:	afbf0014 	sw	ra,20(sp)
+     478:	afb00010 	sw	s0,16(sp)
+     47c:	3c030000 	lui	v1,0x0
+     480:	8c6200a4 	lw	v0,164(v1)
+     484:	14400047 	bnez	v0,5a4 <em86xx_mbus_init+0x134>
+     488:	24020001 	li	v0,1
+     48c:	ac6200a4 	sw	v0,164(v1)
+     490:	41706000 	di	s0
+     494:	32100001 	andi	s0,s0,0x1
+     498:	000000c0 	ehb
+     49c:	3c050000 	lui	a1,0x0
+     4a0:	24a200ac 	addiu	v0,a1,172
+     4a4:	24030004 	li	v1,4
+     4a8:	2404000f 	li	a0,15
+     4ac:	ac43000c 	sw	v1,12(v0)
+     4b0:	3c030000 	lui	v1,0x0
+     4b4:	aca400ac 	sw	a0,172(a1)
+     4b8:	ac44001c 	sw	a0,28(v0)
+     4bc:	ac440008 	sw	a0,8(v0)
+     4c0:	ac440010 	sw	a0,16(v0)
+     4c4:	ac440018 	sw	a0,24(v0)
+     4c8:	ac440014 	sw	a0,20(v0)
+     4cc:	ac400004 	sw	zero,4(v0)
+     4d0:	246400c8 	addiu	a0,v1,200
+     4d4:	2445fffc 	addiu	a1,v0,-4
+     4d8:	00003021 	move	a2,zero
+     4dc:	8c830000 	lw	v1,0(a0)
+     4e0:	00061100 	sll	v0,a2,0x4
+     4e4:	2484fffc 	addiu	a0,a0,-4
+     4e8:	1485fffc 	bne	a0,a1,4dc <em86xx_mbus_init+0x6c>
+     4ec:	00433025 	or	a2,v0,v1
+     4f0:	3c050002 	lui	a1,0x2
+     4f4:	34a590a8 	ori	a1,a1,0x90a8
+     4f8:	0c000000 	jal	0 <mbus_intr>
+     4fc:	24040001 	li	a0,1
+     500:	0000000f 	sync
+     504:	12000002 	beqz	s0,510 <em86xx_mbus_init+0xa0>
+     508:	41606000 	di
+     50c:	41606020 	ei
+     510:	000000c0 	ehb
+     514:	3c100002 	lui	s0,0x2
+     518:	3c067d7d 	lui	a2,0x7d7d
+     51c:	360590a0 	ori	a1,s0,0x90a0
+     520:	34c67d7d 	ori	a2,a2,0x7d7d
+     524:	0c000000 	jal	0 <mbus_intr>
+     528:	24040001 	li	a0,1
+     52c:	3c067d00 	lui	a2,0x7d00
+     530:	360590a0 	ori	a1,s0,0x90a0
+     534:	34c67d00 	ori	a2,a2,0x7d00
+     538:	3c100011 	lui	s0,0x11
+     53c:	0c000000 	jal	0 <mbus_intr>
+     540:	24040001 	li	a0,1
+     544:	36053fe4 	ori	a1,s0,0x3fe4
+     548:	24040001 	li	a0,1
+     54c:	0c000000 	jal	0 <mbus_intr>
+     550:	24060700 	li	a2,1792
+     554:	36053dcc 	ori	a1,s0,0x3dcc
+     558:	24040001 	li	a0,1
+     55c:	0c000000 	jal	0 <mbus_intr>
+     560:	34068000 	li	a2,0x8000
+     564:	36053fdc 	ori	a1,s0,0x3fdc
+     568:	24040001 	li	a0,1
+     56c:	3c100001 	lui	s0,0x1
+     570:	0c000000 	jal	0 <mbus_intr>
+     574:	24060003 	li	a2,3
+     578:	24040001 	li	a0,1
+     57c:	36050208 	ori	a1,s0,0x208
+     580:	36061f1f 	ori	a2,s0,0x1f1f
+     584:	24030001 	li	v1,1
+     588:	3c020000 	lui	v0,0x0
+     58c:	0c000000 	jal	0 <mbus_intr>
+     590:	ac4300a0 	sw	v1,160(v0)
+     594:	36061f1f 	ori	a2,s0,0x1f1f
+     598:	24040001 	li	a0,1
+     59c:	0c000000 	jal	0 <mbus_intr>
+     5a0:	3605020c 	ori	a1,s0,0x20c
+     5a4:	8fbf0014 	lw	ra,20(sp)
+     5a8:	8fb00010 	lw	s0,16(sp)
+     5ac:	00001021 	move	v0,zero
+     5b0:	03e00008 	jr	ra
+     5b4:	27bd0018 	addiu	sp,sp,24
+
+000005b8 <wait_mpegdma>:
+     5b8:	27bdffe0 	addiu	sp,sp,-32
+     5bc:	3c020011 	lui	v0,0x11
+     5c0:	afb10014 	sw	s1,20(sp)
+     5c4:	afb00010 	sw	s0,16(sp)
+     5c8:	34513ad8 	ori	s1,v0,0x3ad8
+     5cc:	00008021 	move	s0,zero
+     5d0:	afbf0018 	sw	ra,24(sp)
+     5d4:	24040001 	li	a0,1
+     5d8:	0c000000 	jal	0 <mbus_intr>
+     5dc:	02202821 	move	a1,s1
+     5e0:	30420007 	andi	v0,v0,0x7
+     5e4:	1440fffb 	bnez	v0,5d4 <wait_mpegdma+0x1c>
+     5e8:	26100200 	addiu	s0,s0,512
+     5ec:	2610fe00 	addiu	s0,s0,-512
+     5f0:	02001021 	move	v0,s0
+     5f4:	8fbf0018 	lw	ra,24(sp)
+     5f8:	8fb10014 	lw	s1,20(sp)
+     5fc:	8fb00010 	lw	s0,16(sp)
+     600:	03e00008 	jr	ra
+     604:	27bd0020 	addiu	sp,sp,32
+
+00000608 <memcpy>:
+     608:	27bdffc0 	addiu	sp,sp,-64
+     60c:	2cc20200 	sltiu	v0,a2,512
+     610:	afb60030 	sw	s6,48(sp)
+     614:	afb5002c 	sw	s5,44(sp)
+     618:	afb00018 	sw	s0,24(sp)
+     61c:	afbf003c 	sw	ra,60(sp)
+     620:	afbe0038 	sw	s8,56(sp)
+     624:	afb70034 	sw	s7,52(sp)
+     628:	afb40028 	sw	s4,40(sp)
+     62c:	afb30024 	sw	s3,36(sp)
+     630:	afb20020 	sw	s2,32(sp)
+     634:	afb1001c 	sw	s1,28(sp)
+     638:	00c0b021 	move	s6,a2
+     63c:	0080a821 	move	s5,a0
+     640:	14400014 	bnez	v0,694 <memcpy+0x8c>
+     644:	00a08021 	move	s0,a1
+     648:	3c020000 	lui	v0,0x0
+     64c:	8c4200a0 	lw	v0,160(v0)
+     650:	10400011 	beqz	v0,698 <memcpy+0x90>
+     654:	3c0a0000 	lui	t2,0x0
+     658:	3c039000 	lui	v1,0x9000
+     65c:	00a3102b 	sltu	v0,a1,v1
+     660:	1440000e 	bnez	v0,69c <memcpy+0x94>
+     664:	254a0000 	addiu	t2,t2,0
+     668:	0083102b 	sltu	v0,a0,v1
+     66c:	14400009 	bnez	v0,694 <memcpy+0x8c>
+     670:	3c029fff 	lui	v0,0x9fff
+     674:	3442ffff 	ori	v0,v0,0xffff
+     678:	0045102b 	sltu	v0,v0,a1
+     67c:	14400006 	bnez	v0,698 <memcpy+0x90>
+     680:	3c0a0000 	lui	t2,0x0
+     684:	3c02a000 	lui	v0,0xa000
+     688:	0082102b 	sltu	v0,a0,v0
+     68c:	1440001b 	bnez	v0,6fc <memcpy+0xf4>
+     690:	3c050001 	lui	a1,0x1
+     694:	3c0a0000 	lui	t2,0x0
+     698:	254a0000 	addiu	t2,t2,0
+     69c:	8d460050 	lw	a2,80(t2)
+     6a0:	8d470054 	lw	a3,84(t2)
+     6a4:	00001821 	move	v1,zero
+     6a8:	02c64021 	addu	t0,s6,a2
+     6ac:	0116202b 	sltu	a0,t0,s6
+     6b0:	00674821 	addu	t1,v1,a3
+     6b4:	00894821 	addu	t1,a0,t1
+     6b8:	02002821 	move	a1,s0
+     6bc:	02a02021 	move	a0,s5
+     6c0:	02c03021 	move	a2,s6
+     6c4:	8fbf003c 	lw	ra,60(sp)
+     6c8:	8fbe0038 	lw	s8,56(sp)
+     6cc:	8fb70034 	lw	s7,52(sp)
+     6d0:	8fb60030 	lw	s6,48(sp)
+     6d4:	8fb5002c 	lw	s5,44(sp)
+     6d8:	8fb40028 	lw	s4,40(sp)
+     6dc:	8fb30024 	lw	s3,36(sp)
+     6e0:	8fb20020 	lw	s2,32(sp)
+     6e4:	8fb1001c 	lw	s1,28(sp)
+     6e8:	8fb00018 	lw	s0,24(sp)
+     6ec:	27bd0040 	addiu	sp,sp,64
+     6f0:	ad480050 	sw	t0,80(t2)
+     6f4:	08000000 	j	0 <mbus_intr>
+     6f8:	ad490054 	sw	t1,84(t2)
+     6fc:	34a50048 	ori	a1,a1,0x48
+     700:	0c000000 	jal	0 <mbus_intr>
+     704:	24040001 	li	a0,1
+     708:	afa20010 	sw	v0,16(sp)
+     70c:	32a2000f 	andi	v0,s5,0xf
+     710:	10400005 	beqz	v0,728 <memcpy+0x120>
+     714:	02d51821 	addu	v1,s6,s5
+     718:	2402fff0 	li	v0,-16
+     71c:	02a21024 	and	v0,s5,v0
+     720:	bc550000 	cache	0x15,0(v0)
+     724:	02d51821 	addu	v1,s6,s5
+     728:	3062000f 	andi	v0,v1,0xf
+     72c:	10400003 	beqz	v0,73c <memcpy+0x134>
+     730:	2402fff0 	li	v0,-16
+     734:	00621024 	and	v0,v1,v0
+     738:	bc550000 	cache	0x15,0(v0)
+     73c:	02c09021 	move	s2,s6
+     740:	41626000 	di	v0
+     744:	30420001 	andi	v0,v0,0x1
+     748:	000000c0 	ehb
+     74c:	02009821 	move	s3,s0
+     750:	02a08021 	move	s0,s5
+     754:	08000221 	j	884 <memcpy+0x27c>
+     758:	afa20014 	sw	v0,20(sp)
+     75c:	24630000 	addiu	v1,v1,0
+     760:	2a422000 	slti	v0,s2,8192
+     764:	90650037 	lbu	a1,55(v1)
+     768:	24141fff 	li	s4,8191
+     76c:	0242a00b 	movn	s4,s2,v0
+     770:	0293f021 	addu	s8,s4,s3
+     774:	00052023 	negu	a0,a1
+     778:	27c2ffff 	addiu	v0,s8,-1
+     77c:	00441024 	and	v0,v0,a0
+     780:	02641824 	and	v1,s3,a0
+     784:	bc750000 	cache	0x15,0(v1)
+     788:	1462fffe 	bne	v1,v0,784 <memcpy+0x17c>
+     78c:	00651821 	addu	v1,v1,a1
+     790:	0290b821 	addu	s7,s4,s0
+     794:	26e2ffff 	addiu	v0,s7,-1
+     798:	00441024 	and	v0,v0,a0
+     79c:	02041824 	and	v1,s0,a0
+     7a0:	bc710000 	cache	0x11,0(v1)
+     7a4:	1462fffe 	bne	v1,v0,7a0 <memcpy+0x198>
+     7a8:	00651821 	addu	v1,v1,a1
+     7ac:	0c00016e 	jal	5b8 <wait_mpegdma>
+     7b0:	3c110011 	lui	s1,0x11
+     7b4:	24040001 	li	a0,1
+     7b8:	36253ac0 	ori	a1,s1,0x3ac0
+     7bc:	0c000000 	jal	0 <mbus_intr>
+     7c0:	3206ffff 	andi	a2,s0,0xffff
+     7c4:	7e066c00 	ext	a2,s0,0x10,0xe
+     7c8:	24040001 	li	a0,1
+     7cc:	0c000000 	jal	0 <mbus_intr>
+     7d0:	36253ac4 	ori	a1,s1,0x3ac4
+     7d4:	24040001 	li	a0,1
+     7d8:	36253ac8 	ori	a1,s1,0x3ac8
+     7dc:	0c000000 	jal	0 <mbus_intr>
+     7e0:	02803021 	move	a2,s4
+     7e4:	24040001 	li	a0,1
+     7e8:	36253acc 	ori	a1,s1,0x3acc
+     7ec:	0c000000 	jal	0 <mbus_intr>
+     7f0:	00003021 	move	a2,zero
+     7f4:	16540004 	bne	s2,s4,808 <memcpy+0x200>
+     7f8:	24040001 	li	a0,1
+     7fc:	36253ad8 	ori	a1,s1,0x3ad8
+     800:	08000204 	j	810 <memcpy+0x208>
+     804:	24060005 	li	a2,5
+     808:	36253ad8 	ori	a1,s1,0x3ad8
+     80c:	24060001 	li	a2,1
+     810:	0c000000 	jal	0 <mbus_intr>
+     814:	3c100011 	lui	s0,0x11
+     818:	24040001 	li	a0,1
+     81c:	36053b00 	ori	a1,s0,0x3b00
+     820:	0c000000 	jal	0 <mbus_intr>
+     824:	3266ffff 	andi	a2,s3,0xffff
+     828:	7e666c00 	ext	a2,s3,0x10,0xe
+     82c:	24040001 	li	a0,1
+     830:	0c000000 	jal	0 <mbus_intr>
+     834:	36053b04 	ori	a1,s0,0x3b04
+     838:	24040001 	li	a0,1
+     83c:	36053b08 	ori	a1,s0,0x3b08
+     840:	0c000000 	jal	0 <mbus_intr>
+     844:	02803021 	move	a2,s4
+     848:	24040001 	li	a0,1
+     84c:	36053b0c 	ori	a1,s0,0x3b0c
+     850:	0c000000 	jal	0 <mbus_intr>
+     854:	00003021 	move	a2,zero
+     858:	16540004 	bne	s2,s4,86c <memcpy+0x264>
+     85c:	36053b18 	ori	a1,s0,0x3b18
+     860:	24040001 	li	a0,1
+     864:	0800021d 	j	874 <memcpy+0x26c>
+     868:	24060005 	li	a2,5
+     86c:	24040001 	li	a0,1
+     870:	24060001 	li	a2,1
+     874:	0c000000 	jal	0 <mbus_intr>
+     878:	02549023 	subu	s2,s2,s4
+     87c:	03c09821 	move	s3,s8
+     880:	02e08021 	move	s0,s7
+     884:	1e40ffb5 	bgtz	s2,75c <memcpy+0x154>
+     888:	3c030000 	lui	v1,0x0
+     88c:	0c00016e 	jal	5b8 <wait_mpegdma>
+     890:	00000000 	nop
+     894:	3c050001 	lui	a1,0x1
+     898:	34a50048 	ori	a1,a1,0x48
+     89c:	0c000000 	jal	0 <mbus_intr>
+     8a0:	24040001 	li	a0,1
+     8a4:	3c0a0000 	lui	t2,0x0
+     8a8:	254a0000 	addiu	t2,t2,0
+     8ac:	8fa30010 	lw	v1,16(sp)
+     8b0:	8d4c0060 	lw	t4,96(t2)
+     8b4:	8d4e0068 	lw	t6,104(t2)
+     8b8:	8d4d0064 	lw	t5,100(t2)
+     8bc:	8d4f006c 	lw	t7,108(t2)
+     8c0:	00431023 	subu	v0,v0,v1
+     8c4:	004e2021 	addu	a0,v0,t6
+     8c8:	02cc3021 	addu	a2,s6,t4
+     8cc:	00004821 	move	t1,zero
+     8d0:	00001821 	move	v1,zero
+     8d4:	0082402b 	sltu	t0,a0,v0
+     8d8:	00d6582b 	sltu	t3,a2,s6
+     8dc:	012d3821 	addu	a3,t1,t5
+     8e0:	006f2821 	addu	a1,v1,t7
+     8e4:	01673821 	addu	a3,t3,a3
+     8e8:	01052821 	addu	a1,t0,a1
+     8ec:	ad440068 	sw	a0,104(t2)
+     8f0:	ad45006c 	sw	a1,108(t2)
+     8f4:	ad460060 	sw	a2,96(t2)
+     8f8:	ad470064 	sw	a3,100(t2)
+     8fc:	8fa20014 	lw	v0,20(sp)
+     900:	10400002 	beqz	v0,90c <memcpy+0x304>
+     904:	41606000 	di
+     908:	41606020 	ei
+     90c:	000000c0 	ehb
+     910:	02a01021 	move	v0,s5
+     914:	8fbf003c 	lw	ra,60(sp)
+     918:	8fbe0038 	lw	s8,56(sp)
+     91c:	8fb70034 	lw	s7,52(sp)
+     920:	8fb60030 	lw	s6,48(sp)
+     924:	8fb5002c 	lw	s5,44(sp)
+     928:	8fb40028 	lw	s4,40(sp)
+     92c:	8fb30024 	lw	s3,36(sp)
+     930:	8fb20020 	lw	s2,32(sp)
+     934:	8fb1001c 	lw	s1,28(sp)
+     938:	8fb00018 	lw	s0,24(sp)
+     93c:	03e00008 	jr	ra
+     940:	27bd0040 	addiu	sp,sp,64
+
+00000944 <em86xx_mbus_setup_dma>:
+     944:	27bdffc8 	addiu	sp,sp,-56
+     948:	afb30024 	sw	s3,36(sp)
+     94c:	00809821 	move	s3,a0
+     950:	afb40028 	sw	s4,40(sp)
+     954:	24040001 	li	a0,1
+     958:	00a0a021 	move	s4,a1
+     95c:	2665000c 	addiu	a1,s3,12
+     960:	afb5002c 	sw	s5,44(sp)
+     964:	afb20020 	sw	s2,32(sp)
+     968:	afb1001c 	sw	s1,28(sp)
+     96c:	afbf0030 	sw	ra,48(sp)
+     970:	afb00018 	sw	s0,24(sp)
+     974:	00c09021 	move	s2,a2
+     978:	00e08821 	move	s1,a3
+     97c:	0c000000 	jal	0 <mbus_intr>
+     980:	8fb5004c 	lw	s5,76(sp)
+     984:	30420007 	andi	v0,v0,0x7
+     988:	10400005 	beqz	v0,9a0 <em86xx_mbus_setup_dma+0x5c>
+     98c:	3c040000 	lui	a0,0x0
+     990:	0c000000 	jal	0 <mbus_intr>
+     994:	24840000 	addiu	a0,a0,0
+     998:	080002c7 	j	b1c <em86xx_mbus_setup_dma+0x1d8>
+     99c:	24020001 	li	v0,1
+     9a0:	1220002a 	beqz	s1,a4c <em86xx_mbus_setup_dma+0x108>
+     9a4:	3c030000 	lui	v1,0x0
+     9a8:	8c6200a8 	lw	v0,168(v1)
+     9ac:	14400011 	bnez	v0,9f4 <em86xx_mbus_setup_dma+0xb0>
+     9b0:	3c100000 	lui	s0,0x0
+     9b4:	3c070000 	lui	a3,0x0
+     9b8:	24e70000 	addiu	a3,a3,0
+     9bc:	24040013 	li	a0,19
+     9c0:	26050000 	addiu	a1,s0,0
+     9c4:	24060020 	li	a2,32
+     9c8:	24020001 	li	v0,1
+     9cc:	ac6200a8 	sw	v0,168(v1)
+     9d0:	0c000000 	jal	0 <mbus_intr>
+     9d4:	afa00010 	sw	zero,16(sp)
+     9d8:	3c070000 	lui	a3,0x0
+     9dc:	26050000 	addiu	a1,s0,0
+     9e0:	24e70000 	addiu	a3,a3,0
+     9e4:	24040011 	li	a0,17
+     9e8:	24060020 	li	a2,32
+     9ec:	0c000000 	jal	0 <mbus_intr>
+     9f0:	afa00010 	sw	zero,16(sp)
+     9f4:	3c03fffd 	lui	v1,0xfffd
+     9f8:	34635000 	ori	v1,v1,0x5000
+     9fc:	02631821 	addu	v1,s3,v1
+     a00:	00031982 	srl	v1,v1,0x6
+     a04:	41656000 	di	a1
+     a08:	30a50001 	andi	a1,a1,0x1
+     a0c:	000000c0 	ehb
+     a10:	3c040000 	lui	a0,0x0
+     a14:	3c020000 	lui	v0,0x0
+     a18:	00031880 	sll	v1,v1,0x2
+     a1c:	244200cc 	addiu	v0,v0,204
+     a20:	248400dc 	addiu	a0,a0,220
+     a24:	00642021 	addu	a0,v1,a0
+     a28:	00621821 	addu	v1,v1,v0
+     a2c:	8fa20048 	lw	v0,72(sp)
+     a30:	ac710000 	sw	s1,0(v1)
+     a34:	ac820000 	sw	v0,0(a0)
+     a38:	0000000f 	sync
+     a3c:	10a00002 	beqz	a1,a48 <em86xx_mbus_setup_dma+0x104>
+     a40:	41606000 	di
+     a44:	41606020 	ei
+     a48:	000000c0 	ehb
+     a4c:	2e422000 	sltiu	v0,s2,8192
+     a50:	10400007 	beqz	v0,a70 <em86xx_mbus_setup_dma+0x12c>
+     a54:	02602021 	move	a0,s3
+     a58:	02802821 	move	a1,s4
+     a5c:	02403021 	move	a2,s2
+     a60:	0c000000 	jal	0 <mbus_intr>
+     a64:	02a03821 	move	a3,s5
+     a68:	080002c7 	j	b1c <em86xx_mbus_setup_dma+0x1d8>
+     a6c:	00001021 	move	v0,zero
+     a70:	2e423fff 	sltiu	v0,s2,16383
+     a74:	14400004 	bnez	v0,a88 <em86xx_mbus_setup_dma+0x144>
+     a78:	02401821 	move	v1,s2
+     a7c:	24110001 	li	s1,1
+     a80:	080002b0 	j	ac0 <em86xx_mbus_setup_dma+0x17c>
+     a84:	00003821 	move	a3,zero
+     a88:	2642e001 	addiu	v0,s2,-8191
+     a8c:	02802821 	move	a1,s4
+     a90:	02602021 	move	a0,s3
+     a94:	24061fff 	li	a2,8191
+     a98:	26871fff 	addiu	a3,s4,8191
+     a9c:	afa20010 	sw	v0,16(sp)
+     aa0:	0c000000 	jal	0 <mbus_intr>
+     aa4:	afb50014 	sw	s5,20(sp)
+     aa8:	080002c7 	j	b1c <em86xx_mbus_setup_dma+0x1d8>
+     aac:	00001021 	move	v0,zero
+     ab0:	24e70001 	addiu	a3,a3,1
+     ab4:	2402000a 	li	v0,10
+     ab8:	10e20004 	beq	a3,v0,acc <em86xx_mbus_setup_dma+0x188>
+     abc:	00118840 	sll	s1,s1,0x1
+     ac0:	30620001 	andi	v0,v1,0x1
+     ac4:	1040fffa 	beqz	v0,ab0 <em86xx_mbus_setup_dma+0x16c>
+     ac8:	00031842 	srl	v1,v1,0x1
+     acc:	2e222000 	sltiu	v0,s1,8192
+     ad0:	10400004 	beqz	v0,ae4 <em86xx_mbus_setup_dma+0x1a0>
+     ad4:	00f28006 	srlv	s0,s2,a3
+     ad8:	2e022000 	sltiu	v0,s0,8192
+     adc:	14400009 	bnez	v0,b04 <em86xx_mbus_setup_dma+0x1c0>
+     ae0:	02602021 	move	a0,s3
+     ae4:	3c040000 	lui	a0,0x0
+     ae8:	24840000 	addiu	a0,a0,0
+     aec:	02402821 	move	a1,s2
+     af0:	02203021 	move	a2,s1
+     af4:	0c000000 	jal	0 <mbus_intr>
+     af8:	02003821 	move	a3,s0
+     afc:	0200000d 	break	0x200
+     b00:	02602021 	move	a0,s3
+     b04:	02802821 	move	a1,s4
+     b08:	02203021 	move	a2,s1
+     b0c:	02003821 	move	a3,s0
+     b10:	0c000000 	jal	0 <mbus_intr>
+     b14:	afb50010 	sw	s5,16(sp)
+     b18:	00001021 	move	v0,zero
+     b1c:	8fbf0030 	lw	ra,48(sp)
+     b20:	8fb5002c 	lw	s5,44(sp)
+     b24:	8fb40028 	lw	s4,40(sp)
+     b28:	8fb30024 	lw	s3,36(sp)
+     b2c:	8fb20020 	lw	s2,32(sp)
+     b30:	8fb1001c 	lw	s1,28(sp)
+     b34:	8fb00018 	lw	s0,24(sp)
+     b38:	03e00008 	jr	ra
+     b3c:	27bd0038 	addiu	sp,sp,56
+
+00000b40 <em86xx_mbus_free_dma>:
+     b40:	27bdffe8 	addiu	sp,sp,-24
+     b44:	afbf0014 	sw	ra,20(sp)
+     b48:	afb00010 	sw	s0,16(sp)
+     b4c:	00a03021 	move	a2,a1
+     b50:	41636000 	di	v1
+     b54:	30630001 	andi	v1,v1,0x1
+     b58:	000000c0 	ehb
+     b5c:	3c02fffd 	lui	v0,0xfffd
+     b60:	34425000 	ori	v0,v0,0x5000
+     b64:	00822021 	addu	a0,a0,v0
+     b68:	00042182 	srl	a0,a0,0x6
+     b6c:	3c020000 	lui	v0,0x0
+     b70:	244200cc 	addiu	v0,v0,204
+     b74:	00042080 	sll	a0,a0,0x2
+     b78:	00822021 	addu	a0,a0,v0
+     b7c:	ac800000 	sw	zero,0(a0)
+     b80:	0000000f 	sync
+     b84:	10600002 	beqz	v1,b90 <em86xx_mbus_free_dma+0x50>
+     b88:	41606000 	di
+     b8c:	41606020 	ei
+     b90:	000000c0 	ehb
+     b94:	04a0001e 	bltz	a1,c10 <em86xx_mbus_free_dma+0xd0>
+     b98:	8fbf0014 	lw	ra,20(sp)
+     b9c:	41706000 	di	s0
+     ba0:	32100001 	andi	s0,s0,0x1
+     ba4:	000000c0 	ehb
+     ba8:	3c040000 	lui	a0,0x0
+     bac:	248500ac 	addiu	a1,a0,172
+     bb0:	00061080 	sll	v0,a2,0x2
+     bb4:	00451021 	addu	v0,v0,a1
+     bb8:	2403000f 	li	v1,15
+     bbc:	ac8300ac 	sw	v1,172(a0)
+     bc0:	ac430000 	sw	v1,0(v0)
+     bc4:	3c020000 	lui	v0,0x0
+     bc8:	244400c8 	addiu	a0,v0,200
+     bcc:	24a5fffc 	addiu	a1,a1,-4
+     bd0:	00003021 	move	a2,zero
+     bd4:	8c830000 	lw	v1,0(a0)
+     bd8:	00061100 	sll	v0,a2,0x4
+     bdc:	2484fffc 	addiu	a0,a0,-4
+     be0:	1485fffc 	bne	a0,a1,bd4 <em86xx_mbus_free_dma+0x94>
+     be4:	00433025 	or	a2,v0,v1
+     be8:	3c050002 	lui	a1,0x2
+     bec:	34a590a8 	ori	a1,a1,0x90a8
+     bf0:	0c000000 	jal	0 <mbus_intr>
+     bf4:	24040001 	li	a0,1
+     bf8:	0000000f 	sync
+     bfc:	12000002 	beqz	s0,c08 <em86xx_mbus_free_dma+0xc8>
+     c00:	41606000 	di
+     c04:	41606020 	ei
+     c08:	000000c0 	ehb
+     c0c:	8fbf0014 	lw	ra,20(sp)
+     c10:	8fb00010 	lw	s0,16(sp)
+     c14:	03e00008 	jr	ra
+     c18:	27bd0018 	addiu	sp,sp,24
+
+00000c1c <__invoke_copy_to_user_dma>:
+     c1c:	27bdffb0 	addiu	sp,sp,-80
+     c20:	28c20200 	slti	v0,a2,512
+     c24:	afb40038 	sw	s4,56(sp)
+     c28:	afbf004c 	sw	ra,76(sp)
+     c2c:	afbe0048 	sw	s8,72(sp)
+     c30:	afb70044 	sw	s7,68(sp)
+     c34:	afb60040 	sw	s6,64(sp)
+     c38:	afb5003c 	sw	s5,60(sp)
+     c3c:	afb30034 	sw	s3,52(sp)
+     c40:	afb20030 	sw	s2,48(sp)
+     c44:	afb1002c 	sw	s1,44(sp)
+     c48:	afb00028 	sw	s0,40(sp)
+     c4c:	00c0a021 	move	s4,a2
+     c50:	afa40050 	sw	a0,80(sp)
+     c54:	10400005 	beqz	v0,c6c <__invoke_copy_to_user_dma+0x50>
+     c58:	afa50054 	sw	a1,84(sp)
+     c5c:	0c000000 	jal	0 <mbus_intr>
+     c60:	00000000 	nop
+     c64:	080004c6 	j	1318 <__invoke_copy_to_user_dma+0x6fc>
+     c68:	00c01021 	move	v0,a2
+     c6c:	8fa20050 	lw	v0,80(sp)
+     c70:	04410005 	bgez	v0,c88 <__invoke_copy_to_user_dma+0x6c>
+     c74:	00000000 	nop
+     c78:	0c000000 	jal	0 <mbus_intr>
+     c7c:	00000000 	nop
+     c80:	080004c6 	j	1318 <__invoke_copy_to_user_dma+0x6fc>
+     c84:	00001021 	move	v0,zero
+     c88:	3c020000 	lui	v0,0x0
+     c8c:	8c4200a0 	lw	v0,160(v0)
+     c90:	10400011 	beqz	v0,cd8 <__invoke_copy_to_user_dma+0xbc>
+     c94:	3c070000 	lui	a3,0x0
+     c98:	8fa30054 	lw	v1,84(sp)
+     c9c:	3c02bfff 	lui	v0,0xbfff
+     ca0:	3442ffff 	ori	v0,v0,0xffff
+     ca4:	0043102b 	sltu	v0,v0,v1
+     ca8:	1440000c 	bnez	v0,cdc <__invoke_copy_to_user_dma+0xc0>
+     cac:	24e70000 	addiu	a3,a3,0
+     cb0:	3c020000 	lui	v0,0x0
+     cb4:	8c440000 	lw	a0,0(v0)
+     cb8:	3c028000 	lui	v0,0x8000
+     cbc:	00621021 	addu	v0,v1,v0
+     cc0:	00021382 	srl	v0,v0,0xe
+     cc4:	0044102b 	sltu	v0,v0,a0
+     cc8:	1040001d 	beqz	v0,d40 <__invoke_copy_to_user_dma+0x124>
+     ccc:	8fa60054 	lw	a2,84(sp)
+     cd0:	08000346 	j	d18 <__invoke_copy_to_user_dma+0xfc>
+     cd4:	3c038000 	lui	v1,0x8000
+     cd8:	24e70000 	addiu	a3,a3,0
+     cdc:	8ce80070 	lw	t0,112(a3)
+     ce0:	8ce90074 	lw	t1,116(a3)
+     ce4:	00142fc3 	sra	a1,s4,0x1f
+     ce8:	02881021 	addu	v0,s4,t0
+     cec:	0054302b 	sltu	a2,v0,s4
+     cf0:	00a91821 	addu	v1,a1,t1
+     cf4:	00c31821 	addu	v1,a2,v1
+     cf8:	ace20070 	sw	v0,112(a3)
+     cfc:	ace30074 	sw	v1,116(a3)
+     d00:	8fa40050 	lw	a0,80(sp)
+     d04:	8fa50054 	lw	a1,84(sp)
+     d08:	0c000000 	jal	0 <mbus_intr>
+     d0c:	02803021 	move	a2,s4
+     d10:	080004c6 	j	1318 <__invoke_copy_to_user_dma+0x6fc>
+     d14:	00c01021 	move	v0,a2
+     d18:	00d41021 	addu	v0,a2,s4
+     d1c:	00431021 	addu	v0,v0,v1
+     d20:	00021382 	srl	v0,v0,0xe
+     d24:	0044102b 	sltu	v0,v0,a0
+     d28:	10400006 	beqz	v0,d44 <__invoke_copy_to_user_dma+0x128>
+     d2c:	3c070000 	lui	a3,0x0
+     d30:	8fa30050 	lw	v1,80(sp)
+     d34:	03803021 	move	a2,gp
+     d38:	08000361 	j	d84 <__invoke_copy_to_user_dma+0x168>
+     d3c:	00002021 	move	a0,zero
+     d40:	3c070000 	lui	a3,0x0
+     d44:	24e70000 	addiu	a3,a3,0
+     d48:	8ce80070 	lw	t0,112(a3)
+     d4c:	8ce90074 	lw	t1,116(a3)
+     d50:	00142fc3 	sra	a1,s4,0x1f
+     d54:	02881021 	addu	v0,s4,t0
+     d58:	0054302b 	sltu	a2,v0,s4
+     d5c:	00a91821 	addu	v1,a1,t1
+     d60:	00c31821 	addu	v1,a2,v1
+     d64:	ace20070 	sw	v0,112(a3)
+     d68:	ace30074 	sw	v1,116(a3)
+     d6c:	8fa40050 	lw	a0,80(sp)
+     d70:	8fa50054 	lw	a1,84(sp)
+     d74:	0c000000 	jal	0 <mbus_intr>
+     d78:	02803021 	move	a2,s4
+     d7c:	080004c6 	j	1318 <__invoke_copy_to_user_dma+0x6fc>
+     d80:	00c01021 	move	v0,a2
+     d84:	8cc50018 	lw	a1,24(a2)
+     d88:	24620001 	addiu	v0,v1,1
+     d8c:	00431025 	or	v0,v0,v1
+     d90:	00451024 	and	v0,v0,a1
+     d94:	14400002 	bnez	v0,da0 <__invoke_copy_to_user_dma+0x184>
+     d98:	00000000 	nop
+     d9c:	a0600000 	sb	zero,0(v1)
+     da0:	24844000 	addiu	a0,a0,16384
+     da4:	0094102a 	slt	v0,a0,s4
+     da8:	1440fff6 	bnez	v0,d84 <__invoke_copy_to_user_dma+0x168>
+     dac:	24634000 	addiu	v1,v1,16384
+     db0:	8fa20050 	lw	v0,80(sp)
+     db4:	02828021 	addu	s0,s4,v0
+     db8:	2602ffff 	addiu	v0,s0,-1
+     dbc:	02021025 	or	v0,s0,v0
+     dc0:	00451024 	and	v0,v0,a1
+     dc4:	14400002 	bnez	v0,dd0 <__invoke_copy_to_user_dma+0x1b4>
+     dc8:	0280b021 	move	s6,s4
+     dcc:	a200ffff 	sb	zero,-1(s0)
+     dd0:	3c050001 	lui	a1,0x1
+     dd4:	34a50048 	ori	a1,a1,0x48
+     dd8:	0c000000 	jal	0 <mbus_intr>
+     ddc:	24040001 	li	a0,1
+     de0:	8fa30050 	lw	v1,80(sp)
+     de4:	afa20018 	sw	v0,24(sp)
+     de8:	3062000f 	andi	v0,v1,0xf
+     dec:	10400005 	beqz	v0,e04 <__invoke_copy_to_user_dma+0x1e8>
+     df0:	3202000f 	andi	v0,s0,0xf
+     df4:	2402fff0 	li	v0,-16
+     df8:	00621024 	and	v0,v1,v0
+     dfc:	bc550000 	cache	0x15,0(v0)
+     e00:	3202000f 	andi	v0,s0,0xf
+     e04:	10400003 	beqz	v0,e14 <__invoke_copy_to_user_dma+0x1f8>
+     e08:	2402fff0 	li	v0,-16
+     e0c:	02021024 	and	v0,s0,v0
+     e10:	bc550000 	cache	0x15,0(v0)
+     e14:	41756000 	di	s5
+     e18:	32b50001 	andi	s5,s5,0x1
+     e1c:	000000c0 	ehb
+     e20:	afa0001c 	sw	zero,28(sp)
+     e24:	8fa20050 	lw	v0,80(sp)
+     e28:	8fa6001c 	lw	a2,28(sp)
+     e2c:	3c037fff 	lui	v1,0x7fff
+     e30:	34638001 	ori	v1,v1,0x8001
+     e34:	00c23021 	addu	a2,a2,v0
+     e38:	2402c000 	li	v0,-16384
+     e3c:	00c22824 	and	a1,a2,v0
+     e40:	00a3102b 	sltu	v0,a1,v1
+     e44:	afa60020 	sw	a2,32(sp)
+     e48:	14400006 	bnez	v0,e64 <__invoke_copy_to_user_dma+0x248>
+     e4c:	00052682 	srl	a0,a1,0x1a
+     e50:	3c060000 	lui	a2,0x0
+     e54:	24c60000 	addiu	a2,a2,0
+     e58:	8cc30024 	lw	v1,36(a2)
+     e5c:	0800039d 	j	e74 <__invoke_copy_to_user_dma+0x258>
+     e60:	00041080 	sll	v0,a0,0x2
+     e64:	8f820000 	lw	v0,0(gp)
+     e68:	00041880 	sll	v1,a0,0x2
+     e6c:	8c4200b8 	lw	v0,184(v0)
+     e70:	8c420024 	lw	v0,36(v0)
+     e74:	00621821 	addu	v1,v1,v0
+     e78:	00001021 	move	v0,zero
+     e7c:	00028036 	tne	zero,v0,0x200
+     e80:	00028036 	tne	zero,v0,0x200
+     e84:	8c620000 	lw	v0,0(v1)
+     e88:	3c030000 	lui	v1,0x0
+     e8c:	24630000 	addiu	v1,v1,0
+     e90:	14430003 	bne	v0,v1,ea0 <__invoke_copy_to_user_dma+0x284>
+     e94:	3c040000 	lui	a0,0x0
+     e98:	080003b7 	j	edc <__invoke_copy_to_user_dma+0x2c0>
+     e9c:	24840000 	addiu	a0,a0,0
+     ea0:	3c048000 	lui	a0,0x8000
+     ea4:	00441821 	addu	v1,v0,a0
+     ea8:	00031b82 	srl	v1,v1,0xe
+     eac:	7ca25b80 	ext	v0,a1,0xe,0xc
+     eb0:	00031b80 	sll	v1,v1,0xe
+     eb4:	00021080 	sll	v0,v0,0x2
+     eb8:	00431021 	addu	v0,v0,v1
+     ebc:	00441021 	addu	v0,v0,a0
+     ec0:	8c430000 	lw	v1,0(v0)
+     ec4:	2402ffbf 	li	v0,-65
+     ec8:	00621024 	and	v0,v1,v0
+     ecc:	14400018 	bnez	v0,f30 <__invoke_copy_to_user_dma+0x314>
+     ed0:	8fa60020 	lw	a2,32(sp)
+     ed4:	3c040000 	lui	a0,0x0
+     ed8:	24840000 	addiu	a0,a0,0
+     edc:	0c000000 	jal	0 <mbus_intr>
+     ee0:	00000000 	nop
+     ee4:	0c00016e 	jal	5b8 <wait_mpegdma>
+     ee8:	00000000 	nop
+     eec:	3c070000 	lui	a3,0x0
+     ef0:	24e70000 	addiu	a3,a3,0
+     ef4:	8ce80070 	lw	t0,112(a3)
+     ef8:	8ce90074 	lw	t1,116(a3)
+     efc:	00142fc3 	sra	a1,s4,0x1f
+     f00:	02881021 	addu	v0,s4,t0
+     f04:	0054302b 	sltu	a2,v0,s4
+     f08:	00a91821 	addu	v1,a1,t1
+     f0c:	00c31821 	addu	v1,a2,v1
+     f10:	ace20070 	sw	v0,112(a3)
+     f14:	ace30074 	sw	v1,116(a3)
+     f18:	12a00002 	beqz	s5,f24 <__invoke_copy_to_user_dma+0x308>
+     f1c:	41606000 	di
+     f20:	41606020 	ei
+     f24:	000000c0 	ehb
+     f28:	080004c6 	j	1318 <__invoke_copy_to_user_dma+0x6fc>
+     f2c:	02c01021 	move	v0,s6
+     f30:	2402c000 	li	v0,-16384
+     f34:	00621024 	and	v0,v1,v0
+     f38:	30c43fff 	andi	a0,a2,0x3fff
+     f3c:	00828021 	addu	s0,a0,v0
+     f40:	3c02f000 	lui	v0,0xf000
+     f44:	02021021 	addu	v0,s0,v0
+     f48:	3c032000 	lui	v1,0x2000
+     f4c:	0043102b 	sltu	v0,v0,v1
+     f50:	14400018 	bnez	v0,fb4 <__invoke_copy_to_user_dma+0x398>
+     f54:	8fa30054 	lw	v1,84(sp)
+     f58:	0c00016e 	jal	5b8 <wait_mpegdma>
+     f5c:	00000000 	nop
+     f60:	3c070000 	lui	a3,0x0
+     f64:	24e70000 	addiu	a3,a3,0
+     f68:	8ce80070 	lw	t0,112(a3)
+     f6c:	8ce90074 	lw	t1,116(a3)
+     f70:	00142fc3 	sra	a1,s4,0x1f
+     f74:	02881021 	addu	v0,s4,t0
+     f78:	0054302b 	sltu	a2,v0,s4
+     f7c:	00a91821 	addu	v1,a1,t1
+     f80:	00c31821 	addu	v1,a2,v1
+     f84:	ace20070 	sw	v0,112(a3)
+     f88:	ace30074 	sw	v1,116(a3)
+     f8c:	12a00002 	beqz	s5,f98 <__invoke_copy_to_user_dma+0x37c>
+     f90:	41606000 	di
+     f94:	41606020 	ei
+     f98:	000000c0 	ehb
+     f9c:	3c040000 	lui	a0,0x0
+     fa0:	24840000 	addiu	a0,a0,0
+     fa4:	0c000000 	jal	0 <mbus_intr>
+     fa8:	02002821 	move	a1,s0
+     fac:	080004c6 	j	1318 <__invoke_copy_to_user_dma+0x6fc>
+     fb0:	02c01021 	move	v0,s6
+     fb4:	24024000 	li	v0,16384
+     fb8:	0044b823 	subu	s7,v0,a0
+     fbc:	02d7102b 	sltu	v0,s6,s7
+     fc0:	02c2b80b 	movn	s7,s6,v0
+     fc4:	8fa2001c 	lw	v0,28(sp)
+     fc8:	0200f021 	move	s8,s0
+     fcc:	02e08821 	move	s1,s7
+     fd0:	00431021 	addu	v0,v0,v1
+     fd4:	afa00010 	sw	zero,16(sp)
+     fd8:	08000495 	j	1254 <__invoke_copy_to_user_dma+0x638>
+     fdc:	afa20024 	sw	v0,36(sp)
+     fe0:	10400005 	beqz	v0,ff8 <__invoke_copy_to_user_dma+0x3dc>
+     fe4:	3c038004 	lui	v1,0x8004
+     fe8:	24060001 	li	a2,1
+     fec:	02209021 	move	s2,s1
+     ff0:	08000409 	j	1024 <__invoke_copy_to_user_dma+0x408>
+     ff4:	afa60014 	sw	a2,20(sp)
+     ff8:	34630021 	ori	v1,v1,0x21
+     ffc:	02230018 	mult	s1,v1
+    1000:	00111fc3 	sra	v1,s1,0x1f
+    1004:	00001010 	mfhi	v0
+    1008:	00511021 	addu	v0,v0,s1
+    100c:	00021303 	sra	v0,v0,0xc
+    1010:	00431023 	subu	v0,v0,v1
+    1014:	afa20014 	sw	v0,20(sp)
+    1018:	8fa60014 	lw	a2,20(sp)
+    101c:	00021340 	sll	v0,v0,0xd
+    1020:	00469023 	subu	s2,v0,a2
+    1024:	8fa30024 	lw	v1,36(sp)
+    1028:	3c020000 	lui	v0,0x0
+    102c:	8fa60010 	lw	a2,16(sp)
+    1030:	24420000 	addiu	v0,v0,0
+    1034:	90450037 	lbu	a1,55(v0)
+    1038:	00669821 	addu	s3,v1,a2
+    103c:	2662ffff 	addiu	v0,s3,-1
+    1040:	00052023 	negu	a0,a1
+    1044:	00521021 	addu	v0,v0,s2
+    1048:	00441024 	and	v0,v0,a0
+    104c:	02641824 	and	v1,s3,a0
+    1050:	bc750000 	cache	0x15,0(v1)
+    1054:	1462fffe 	bne	v1,v0,1050 <__invoke_copy_to_user_dma+0x434>
+    1058:	00651821 	addu	v1,v1,a1
+    105c:	8fa20010 	lw	v0,16(sp)
+    1060:	8fa60020 	lw	a2,32(sp)
+    1064:	00461821 	addu	v1,v0,a2
+    1068:	2462ffff 	addiu	v0,v1,-1
+    106c:	00521021 	addu	v0,v0,s2
+    1070:	00441024 	and	v0,v0,a0
+    1074:	00641824 	and	v1,v1,a0
+    1078:	bc710000 	cache	0x11,0(v1)
+    107c:	1462fffe 	bne	v1,v0,1078 <__invoke_copy_to_user_dma+0x45c>
+    1080:	00651821 	addu	v1,v1,a1
+    1084:	0c00016e 	jal	5b8 <wait_mpegdma>
+    1088:	3c100011 	lui	s0,0x11
+    108c:	24040001 	li	a0,1
+    1090:	36053ac0 	ori	a1,s0,0x3ac0
+    1094:	0c000000 	jal	0 <mbus_intr>
+    1098:	33c6ffff 	andi	a2,s8,0xffff
+    109c:	24040001 	li	a0,1
+    10a0:	36053ac4 	ori	a1,s0,0x3ac4
+    10a4:	0c000000 	jal	0 <mbus_intr>
+    10a8:	7fc66c00 	ext	a2,s8,0x10,0xe
+    10ac:	2a422000 	slti	v0,s2,8192
+    10b0:	1440001b 	bnez	v0,1120 <__invoke_copy_to_user_dma+0x504>
+    10b4:	2a222000 	slti	v0,s1,8192
+    10b8:	24040001 	li	a0,1
+    10bc:	36053ac8 	ori	a1,s0,0x3ac8
+    10c0:	0c000000 	jal	0 <mbus_intr>
+    10c4:	24061fff 	li	a2,8191
+    10c8:	8fa60014 	lw	a2,20(sp)
+    10cc:	24040001 	li	a0,1
+    10d0:	0c000000 	jal	0 <mbus_intr>
+    10d4:	36053acc 	ori	a1,s0,0x3acc
+    10d8:	24040001 	li	a0,1
+    10dc:	36053ad0 	ori	a1,s0,0x3ad0
+    10e0:	0c000000 	jal	0 <mbus_intr>
+    10e4:	24061fff 	li	a2,8191
+    10e8:	24040001 	li	a0,1
+    10ec:	36053ad4 	ori	a1,s0,0x3ad4
+    10f0:	0c000000 	jal	0 <mbus_intr>
+    10f4:	00003021 	move	a2,zero
+    10f8:	16320005 	bne	s1,s2,1110 <__invoke_copy_to_user_dma+0x4f4>
+    10fc:	00000000 	nop
+    1100:	36053ad8 	ori	a1,s0,0x3ad8
+    1104:	24040001 	li	a0,1
+    1108:	08000458 	j	1160 <__invoke_copy_to_user_dma+0x544>
+    110c:	24060007 	li	a2,7
+    1110:	36053ad8 	ori	a1,s0,0x3ad8
+    1114:	24040001 	li	a0,1
+    1118:	08000458 	j	1160 <__invoke_copy_to_user_dma+0x544>
+    111c:	24060003 	li	a2,3
+    1120:	24061fff 	li	a2,8191
+    1124:	0222300b 	movn	a2,s1,v0
+    1128:	24040001 	li	a0,1
+    112c:	0c000000 	jal	0 <mbus_intr>
+    1130:	36053ac8 	ori	a1,s0,0x3ac8
+    1134:	24040001 	li	a0,1
+    1138:	36053acc 	ori	a1,s0,0x3acc
+    113c:	0c000000 	jal	0 <mbus_intr>
+    1140:	00003021 	move	a2,zero
+    1144:	16320004 	bne	s1,s2,1158 <__invoke_copy_to_user_dma+0x53c>
+    1148:	24040001 	li	a0,1
+    114c:	36053ad8 	ori	a1,s0,0x3ad8
+    1150:	08000458 	j	1160 <__invoke_copy_to_user_dma+0x544>
+    1154:	24060005 	li	a2,5
+    1158:	36053ad8 	ori	a1,s0,0x3ad8
+    115c:	24060001 	li	a2,1
+    1160:	0c000000 	jal	0 <mbus_intr>
+    1164:	3c100011 	lui	s0,0x11
+    1168:	24040001 	li	a0,1
+    116c:	36053b00 	ori	a1,s0,0x3b00
+    1170:	0c000000 	jal	0 <mbus_intr>
+    1174:	3266ffff 	andi	a2,s3,0xffff
+    1178:	7e666c00 	ext	a2,s3,0x10,0xe
+    117c:	24040001 	li	a0,1
+    1180:	0c000000 	jal	0 <mbus_intr>
+    1184:	36053b04 	ori	a1,s0,0x3b04
+    1188:	2a422000 	slti	v0,s2,8192
+    118c:	1440001b 	bnez	v0,11fc <__invoke_copy_to_user_dma+0x5e0>
+    1190:	2a222000 	slti	v0,s1,8192
+    1194:	24040001 	li	a0,1
+    1198:	36053b08 	ori	a1,s0,0x3b08
+    119c:	0c000000 	jal	0 <mbus_intr>
+    11a0:	24061fff 	li	a2,8191
+    11a4:	8fa60014 	lw	a2,20(sp)
+    11a8:	24040001 	li	a0,1
+    11ac:	0c000000 	jal	0 <mbus_intr>
+    11b0:	36053b0c 	ori	a1,s0,0x3b0c
+    11b4:	24040001 	li	a0,1
+    11b8:	36053b10 	ori	a1,s0,0x3b10
+    11bc:	0c000000 	jal	0 <mbus_intr>
+    11c0:	24061fff 	li	a2,8191
+    11c4:	24040001 	li	a0,1
+    11c8:	36053b14 	ori	a1,s0,0x3b14
+    11cc:	0c000000 	jal	0 <mbus_intr>
+    11d0:	00003021 	move	a2,zero
+    11d4:	16320005 	bne	s1,s2,11ec <__invoke_copy_to_user_dma+0x5d0>
+    11d8:	00000000 	nop
+    11dc:	36053b18 	ori	a1,s0,0x3b18
+    11e0:	24040001 	li	a0,1
+    11e4:	0800048f 	j	123c <__invoke_copy_to_user_dma+0x620>
+    11e8:	24060007 	li	a2,7
+    11ec:	36053b18 	ori	a1,s0,0x3b18
+    11f0:	24040001 	li	a0,1
+    11f4:	0800048f 	j	123c <__invoke_copy_to_user_dma+0x620>
+    11f8:	24060003 	li	a2,3
+    11fc:	24061fff 	li	a2,8191
+    1200:	0222300b 	movn	a2,s1,v0
+    1204:	24040001 	li	a0,1
+    1208:	0c000000 	jal	0 <mbus_intr>
+    120c:	36053b08 	ori	a1,s0,0x3b08
+    1210:	24040001 	li	a0,1
+    1214:	36053b0c 	ori	a1,s0,0x3b0c
+    1218:	0c000000 	jal	0 <mbus_intr>
+    121c:	00003021 	move	a2,zero
+    1220:	16320004 	bne	s1,s2,1234 <__invoke_copy_to_user_dma+0x618>
+    1224:	36053b18 	ori	a1,s0,0x3b18
+    1228:	24040001 	li	a0,1
+    122c:	0800048f 	j	123c <__invoke_copy_to_user_dma+0x620>
+    1230:	24060005 	li	a2,5
+    1234:	24040001 	li	a0,1
+    1238:	24060001 	li	a2,1
+    123c:	0c000000 	jal	0 <mbus_intr>
+    1240:	02328823 	subu	s1,s1,s2
+    1244:	8fa20010 	lw	v0,16(sp)
+    1248:	03d2f021 	addu	s8,s8,s2
+    124c:	00521021 	addu	v0,v0,s2
+    1250:	afa20010 	sw	v0,16(sp)
+    1254:	1e20ff62 	bgtz	s1,fe0 <__invoke_copy_to_user_dma+0x3c4>
+    1258:	2a222000 	slti	v0,s1,8192
+    125c:	8fa3001c 	lw	v1,28(sp)
+    1260:	8fa60010 	lw	a2,16(sp)
+    1264:	02d7b023 	subu	s6,s6,s7
+    1268:	00661821 	addu	v1,v1,a2
+    126c:	0074102a 	slt	v0,v1,s4
+    1270:	1440feec 	bnez	v0,e24 <__invoke_copy_to_user_dma+0x208>
+    1274:	afa3001c 	sw	v1,28(sp)
+    1278:	0c00016e 	jal	5b8 <wait_mpegdma>
+    127c:	00000000 	nop
+    1280:	12a00002 	beqz	s5,128c <__invoke_copy_to_user_dma+0x670>
+    1284:	41606000 	di
+    1288:	41606020 	ei
+    128c:	000000c0 	ehb
+    1290:	3c0d0000 	lui	t5,0x0
+    1294:	25b00000 	addiu	s0,t5,0
+    1298:	8e040010 	lw	a0,16(s0)
+    129c:	8daa0000 	lw	t2,0(t5)
+    12a0:	8e050014 	lw	a1,20(s0)
+    12a4:	8dab0004 	lw	t3,4(t5)
+    12a8:	24880001 	addiu	t0,a0,1
+    12ac:	028a3021 	addu	a2,s4,t2
+    12b0:	0104102b 	sltu	v0,t0,a0
+    12b4:	00141fc3 	sra	v1,s4,0x1f
+    12b8:	00454821 	addu	t1,v0,a1
+    12bc:	00d4602b 	sltu	t4,a2,s4
+    12c0:	006b3821 	addu	a3,v1,t3
+    12c4:	3c050001 	lui	a1,0x1
+    12c8:	01873821 	addu	a3,t4,a3
+    12cc:	34a50048 	ori	a1,a1,0x48
+    12d0:	24040001 	li	a0,1
+    12d4:	ae080010 	sw	t0,16(s0)
+    12d8:	ae090014 	sw	t1,20(s0)
+    12dc:	ada60000 	sw	a2,0(t5)
+    12e0:	0c000000 	jal	0 <mbus_intr>
+    12e4:	ada70004 	sw	a3,4(t5)
+    12e8:	8fa30018 	lw	v1,24(sp)
+    12ec:	8e080008 	lw	t0,8(s0)
+    12f0:	8e09000c 	lw	t1,12(s0)
+    12f4:	00431023 	subu	v0,v0,v1
+    12f8:	00482021 	addu	a0,v0,t0
+    12fc:	00001821 	move	v1,zero
+    1300:	0082302b 	sltu	a2,a0,v0
+    1304:	00692821 	addu	a1,v1,t1
+    1308:	00c52821 	addu	a1,a2,a1
+    130c:	ae040008 	sw	a0,8(s0)
+    1310:	ae05000c 	sw	a1,12(s0)
+    1314:	02c01021 	move	v0,s6
+    1318:	8fbf004c 	lw	ra,76(sp)
+    131c:	8fbe0048 	lw	s8,72(sp)
+    1320:	8fb70044 	lw	s7,68(sp)
+    1324:	8fb60040 	lw	s6,64(sp)
+    1328:	8fb5003c 	lw	s5,60(sp)
+    132c:	8fb40038 	lw	s4,56(sp)
+    1330:	8fb30034 	lw	s3,52(sp)
+    1334:	8fb20030 	lw	s2,48(sp)
+    1338:	8fb1002c 	lw	s1,44(sp)
+    133c:	8fb00028 	lw	s0,40(sp)
+    1340:	03e00008 	jr	ra
+    1344:	27bd0050 	addiu	sp,sp,80
+
+00001348 <__invoke_copy_from_user_dma>:
+    1348:	27bdffc0 	addiu	sp,sp,-64
+    134c:	28c20200 	slti	v0,a2,512
+    1350:	afb40028 	sw	s4,40(sp)
+    1354:	afbf003c 	sw	ra,60(sp)
+    1358:	afbe0038 	sw	s8,56(sp)
+    135c:	afb70034 	sw	s7,52(sp)
+    1360:	afb60030 	sw	s6,48(sp)
+    1364:	afb5002c 	sw	s5,44(sp)
+    1368:	afb30024 	sw	s3,36(sp)
+    136c:	afb20020 	sw	s2,32(sp)
+    1370:	afb1001c 	sw	s1,28(sp)
+    1374:	afb00018 	sw	s0,24(sp)
+    1378:	00c0a021 	move	s4,a2
+    137c:	afa40040 	sw	a0,64(sp)
+    1380:	10400010 	beqz	v0,13c4 <__invoke_copy_from_user_dma+0x7c>
+    1384:	afa50044 	sw	a1,68(sp)
+    1388:	3c0a0000 	lui	t2,0x0
+    138c:	254a0000 	addiu	t2,t2,0
+    1390:	8d4c0020 	lw	t4,32(t2)
+    1394:	8d4d0024 	lw	t5,36(t2)
+    1398:	00064fc3 	sra	t1,a2,0x1f
+    139c:	00cc1021 	addu	v0,a2,t4
+    13a0:	0046382b 	sltu	a3,v0,a2
+    13a4:	012d1821 	addu	v1,t1,t5
+    13a8:	00e31821 	addu	v1,a3,v1
+    13ac:	ad420020 	sw	v0,32(t2)
+    13b0:	ad430024 	sw	v1,36(t2)
+    13b4:	0c000000 	jal	0 <mbus_intr>
+    13b8:	00a60821 	addu	at,a1,a2
+    13bc:	0800064f 	j	193c <__invoke_copy_from_user_dma+0x5f4>
+    13c0:	00c01021 	move	v0,a2
+    13c4:	8fa20044 	lw	v0,68(sp)
+    13c8:	04410005 	bgez	v0,13e0 <__invoke_copy_from_user_dma+0x98>
+    13cc:	00000000 	nop
+    13d0:	0c000000 	jal	0 <mbus_intr>
+    13d4:	00000000 	nop
+    13d8:	0800064f 	j	193c <__invoke_copy_from_user_dma+0x5f4>
+    13dc:	00001021 	move	v0,zero
+    13e0:	3c020000 	lui	v0,0x0
+    13e4:	8c4200a0 	lw	v0,160(v0)
+    13e8:	10400006 	beqz	v0,1404 <__invoke_copy_from_user_dma+0xbc>
+    13ec:	3c070000 	lui	a3,0x0
+    13f0:	8fa30040 	lw	v1,64(sp)
+    13f4:	3c02c000 	lui	v0,0xc000
+    13f8:	0062102b 	sltu	v0,v1,v0
+    13fc:	14400017 	bnez	v0,145c <__invoke_copy_from_user_dma+0x114>
+    1400:	00000000 	nop
+    1404:	24e70000 	addiu	a3,a3,0
+    1408:	8cec0080 	lw	t4,128(a3)
+    140c:	8cee0020 	lw	t6,32(a3)
+    1410:	8ced0084 	lw	t5,132(a3)
+    1414:	8cef0024 	lw	t7,36(a3)
+    1418:	028c5021 	addu	t2,s4,t4
+    141c:	00141fc3 	sra	v1,s4,0x1f
+    1420:	028e4021 	addu	t0,s4,t6
+    1424:	0154802b 	sltu	s0,t2,s4
+    1428:	006d5821 	addu	t3,v1,t5
+    142c:	0114602b 	sltu	t4,t0,s4
+    1430:	006f4821 	addu	t1,v1,t7
+    1434:	020b5821 	addu	t3,s0,t3
+    1438:	01894821 	addu	t1,t4,t1
+    143c:	ace80020 	sw	t0,32(a3)
+    1440:	ace90024 	sw	t1,36(a3)
+    1444:	acea0080 	sw	t2,128(a3)
+    1448:	aceb0084 	sw	t3,132(a3)
+    144c:	0c000000 	jal	0 <mbus_intr>
+    1450:	00a60821 	addu	at,a1,a2
+    1454:	0800064f 	j	193c <__invoke_copy_from_user_dma+0x5f4>
+    1458:	00c01021 	move	v0,a2
+    145c:	8fa50040 	lw	a1,64(sp)
+    1460:	3c020000 	lui	v0,0x0
+    1464:	8c430000 	lw	v1,0(v0)
+    1468:	3c048000 	lui	a0,0x8000
+    146c:	00a41021 	addu	v0,a1,a0
+    1470:	00021382 	srl	v0,v0,0xe
+    1474:	0043102b 	sltu	v0,v0,v1
+    1478:	1040000b 	beqz	v0,14a8 <__invoke_copy_from_user_dma+0x160>
+    147c:	3c080000 	lui	t0,0x0
+    1480:	00a61021 	addu	v0,a1,a2
+    1484:	00441021 	addu	v0,v0,a0
+    1488:	00021382 	srl	v0,v0,0xe
+    148c:	0043102b 	sltu	v0,v0,v1
+    1490:	10400006 	beqz	v0,14ac <__invoke_copy_from_user_dma+0x164>
+    1494:	25080000 	addiu	t0,t0,0
+    1498:	8fa40044 	lw	a0,68(sp)
+    149c:	03803821 	move	a3,gp
+    14a0:	08000543 	j	150c <__invoke_copy_from_user_dma+0x1c4>
+    14a4:	00002821 	move	a1,zero
+    14a8:	25080000 	addiu	t0,t0,0
+    14ac:	8d0a0080 	lw	t2,128(t0)
+    14b0:	8d0c0020 	lw	t4,32(t0)
+    14b4:	8d0b0084 	lw	t3,132(t0)
+    14b8:	8d0d0024 	lw	t5,36(t0)
+    14bc:	028a3021 	addu	a2,s4,t2
+    14c0:	028c2021 	addu	a0,s4,t4
+    14c4:	00141fc3 	sra	v1,s4,0x1f
+    14c8:	00d4702b 	sltu	t6,a2,s4
+    14cc:	0094482b 	sltu	t1,a0,s4
+    14d0:	006b3821 	addu	a3,v1,t3
+    14d4:	006d2821 	addu	a1,v1,t5
+    14d8:	01252821 	addu	a1,t1,a1
+    14dc:	01c73821 	addu	a3,t6,a3
+    14e0:	ad040020 	sw	a0,32(t0)
+    14e4:	ad050024 	sw	a1,36(t0)
+    14e8:	ad060080 	sw	a2,128(t0)
+    14ec:	ad070084 	sw	a3,132(t0)
+    14f0:	8fa40040 	lw	a0,64(sp)
+    14f4:	8fa50044 	lw	a1,68(sp)
+    14f8:	02803021 	move	a2,s4
+    14fc:	0c000000 	jal	0 <mbus_intr>
+    1500:	00a60821 	addu	at,a1,a2
+    1504:	0800064f 	j	193c <__invoke_copy_from_user_dma+0x5f4>
+    1508:	00c01021 	move	v0,a2
+    150c:	8ce60018 	lw	a2,24(a3)
+    1510:	24820001 	addiu	v0,a0,1
+    1514:	00441025 	or	v0,v0,a0
+    1518:	00461024 	and	v0,v0,a2
+    151c:	14400002 	bnez	v0,1528 <__invoke_copy_from_user_dma+0x1e0>
+    1520:	00401821 	move	v1,v0
+    1524:	80820000 	lb	v0,0(a0)
+    1528:	24a54000 	addiu	a1,a1,16384
+    152c:	00b4102a 	slt	v0,a1,s4
+    1530:	1440fff6 	bnez	v0,150c <__invoke_copy_from_user_dma+0x1c4>
+    1534:	24844000 	addiu	a0,a0,16384
+    1538:	8fa20044 	lw	v0,68(sp)
+    153c:	00541821 	addu	v1,v0,s4
+    1540:	2462ffff 	addiu	v0,v1,-1
+    1544:	00621025 	or	v0,v1,v0
+    1548:	00461024 	and	v0,v0,a2
+    154c:	14400003 	bnez	v0,155c <__invoke_copy_from_user_dma+0x214>
+    1550:	0280b821 	move	s7,s4
+    1554:	00402021 	move	a0,v0
+    1558:	8062ffff 	lb	v0,-1(v1)
+    155c:	3c050001 	lui	a1,0x1
+    1560:	34a50048 	ori	a1,a1,0x48
+    1564:	0c000000 	jal	0 <mbus_intr>
+    1568:	24040001 	li	a0,1
+    156c:	8fa50040 	lw	a1,64(sp)
+    1570:	afa20010 	sw	v0,16(sp)
+    1574:	30a2000f 	andi	v0,a1,0xf
+    1578:	10400005 	beqz	v0,1590 <__invoke_copy_from_user_dma+0x248>
+    157c:	8fa20040 	lw	v0,64(sp)
+    1580:	2402fff0 	li	v0,-16
+    1584:	00a21024 	and	v0,a1,v0
+    1588:	bc550000 	cache	0x15,0(v0)
+    158c:	8fa20040 	lw	v0,64(sp)
+    1590:	02e21821 	addu	v1,s7,v0
+    1594:	3062000f 	andi	v0,v1,0xf
+    1598:	10400003 	beqz	v0,15a8 <__invoke_copy_from_user_dma+0x260>
+    159c:	2402fff0 	li	v0,-16
+    15a0:	00621024 	and	v0,v1,v0
+    15a4:	bc550000 	cache	0x15,0(v0)
+    15a8:	41756000 	di	s5
+    15ac:	32b50001 	andi	s5,s5,0x1
+    15b0:	000000c0 	ehb
+    15b4:	afa00014 	sw	zero,20(sp)
+    15b8:	8fa30014 	lw	v1,20(sp)
+    15bc:	8fa40044 	lw	a0,68(sp)
+    15c0:	2402c000 	li	v0,-16384
+    15c4:	00643021 	addu	a2,v1,a0
+    15c8:	3c037fff 	lui	v1,0x7fff
+    15cc:	00c22824 	and	a1,a2,v0
+    15d0:	34638001 	ori	v1,v1,0x8001
+    15d4:	00a3102b 	sltu	v0,a1,v1
+    15d8:	14400006 	bnez	v0,15f4 <__invoke_copy_from_user_dma+0x2ac>
+    15dc:	00052682 	srl	a0,a1,0x1a
+    15e0:	3c020000 	lui	v0,0x0
+    15e4:	24420000 	addiu	v0,v0,0
+    15e8:	8c430024 	lw	v1,36(v0)
+    15ec:	08000581 	j	1604 <__invoke_copy_from_user_dma+0x2bc>
+    15f0:	00041080 	sll	v0,a0,0x2
+    15f4:	8f820000 	lw	v0,0(gp)
+    15f8:	00041880 	sll	v1,a0,0x2
+    15fc:	8c4200b8 	lw	v0,184(v0)
+    1600:	8c420024 	lw	v0,36(v0)
+    1604:	00621821 	addu	v1,v1,v0
+    1608:	00001021 	move	v0,zero
+    160c:	00028036 	tne	zero,v0,0x200
+    1610:	00028036 	tne	zero,v0,0x200
+    1614:	8c620000 	lw	v0,0(v1)
+    1618:	3c030000 	lui	v1,0x0
+    161c:	24630000 	addiu	v1,v1,0
+    1620:	14430003 	bne	v0,v1,1630 <__invoke_copy_from_user_dma+0x2e8>
+    1624:	3c040000 	lui	a0,0x0
+    1628:	0800059b 	j	166c <__invoke_copy_from_user_dma+0x324>
+    162c:	24840000 	addiu	a0,a0,0
+    1630:	3c048000 	lui	a0,0x8000
+    1634:	00441821 	addu	v1,v0,a0
+    1638:	00031b82 	srl	v1,v1,0xe
+    163c:	7ca25b80 	ext	v0,a1,0xe,0xc
+    1640:	00031b80 	sll	v1,v1,0xe
+    1644:	00021080 	sll	v0,v0,0x2
+    1648:	00431021 	addu	v0,v0,v1
+    164c:	00441021 	addu	v0,v0,a0
+    1650:	8c430000 	lw	v1,0(v0)
+    1654:	2402ffbf 	li	v0,-65
+    1658:	00621024 	and	v0,v1,v0
+    165c:	14400018 	bnez	v0,16c0 <__invoke_copy_from_user_dma+0x378>
+    1660:	30c43fff 	andi	a0,a2,0x3fff
+    1664:	3c040000 	lui	a0,0x0
+    1668:	24840000 	addiu	a0,a0,0
+    166c:	0c000000 	jal	0 <mbus_intr>
+    1670:	00000000 	nop
+    1674:	0c00016e 	jal	5b8 <wait_mpegdma>
+    1678:	00000000 	nop
+    167c:	3c070000 	lui	a3,0x0
+    1680:	24e70000 	addiu	a3,a3,0
+    1684:	8ce80080 	lw	t0,128(a3)
+    1688:	8ce90084 	lw	t1,132(a3)
+    168c:	00142fc3 	sra	a1,s4,0x1f
+    1690:	02881021 	addu	v0,s4,t0
+    1694:	0054302b 	sltu	a2,v0,s4
+    1698:	00a91821 	addu	v1,a1,t1
+    169c:	00c31821 	addu	v1,a2,v1
+    16a0:	ace20080 	sw	v0,128(a3)
+    16a4:	ace30084 	sw	v1,132(a3)
+    16a8:	12a00002 	beqz	s5,16b4 <__invoke_copy_from_user_dma+0x36c>
+    16ac:	41606000 	di
+    16b0:	41606020 	ei
+    16b4:	000000c0 	ehb
+    16b8:	0800064f 	j	193c <__invoke_copy_from_user_dma+0x5f4>
+    16bc:	02e01021 	move	v0,s7
+    16c0:	2402c000 	li	v0,-16384
+    16c4:	00621024 	and	v0,v1,v0
+    16c8:	0082f021 	addu	s8,a0,v0
+    16cc:	3c02f000 	lui	v0,0xf000
+    16d0:	03c21021 	addu	v0,s8,v0
+    16d4:	3c032000 	lui	v1,0x2000
+    16d8:	0043102b 	sltu	v0,v0,v1
+    16dc:	14400018 	bnez	v0,1740 <__invoke_copy_from_user_dma+0x3f8>
+    16e0:	00000000 	nop
+    16e4:	0c00016e 	jal	5b8 <wait_mpegdma>
+    16e8:	00000000 	nop
+    16ec:	3c070000 	lui	a3,0x0
+    16f0:	24e70000 	addiu	a3,a3,0
+    16f4:	8ce80080 	lw	t0,128(a3)
+    16f8:	8ce90084 	lw	t1,132(a3)
+    16fc:	00142fc3 	sra	a1,s4,0x1f
+    1700:	02881021 	addu	v0,s4,t0
+    1704:	0054302b 	sltu	a2,v0,s4
+    1708:	00a91821 	addu	v1,a1,t1
+    170c:	00c31821 	addu	v1,a2,v1
+    1710:	ace20080 	sw	v0,128(a3)
+    1714:	ace30084 	sw	v1,132(a3)
+    1718:	12a00002 	beqz	s5,1724 <__invoke_copy_from_user_dma+0x3dc>
+    171c:	41606000 	di
+    1720:	41606020 	ei
+    1724:	000000c0 	ehb
+    1728:	3c040000 	lui	a0,0x0
+    172c:	24840000 	addiu	a0,a0,0
+    1730:	0c000000 	jal	0 <mbus_intr>
+    1734:	03c02821 	move	a1,s8
+    1738:	0800064f 	j	193c <__invoke_copy_from_user_dma+0x5f4>
+    173c:	02e01021 	move	v0,s7
+    1740:	24024000 	li	v0,16384
+    1744:	0044b023 	subu	s6,v0,a0
+    1748:	02f6102b 	sltu	v0,s7,s6
+    174c:	02e2b00b 	movn	s6,s7,v0
+    1750:	08000629 	j	18a4 <__invoke_copy_from_user_dma+0x55c>
+    1754:	02c09021 	move	s2,s6
+    1758:	3c040000 	lui	a0,0x0
+    175c:	2a422000 	slti	v0,s2,8192
+    1760:	24840000 	addiu	a0,a0,0
+    1764:	24131fff 	li	s3,8191
+    1768:	90850037 	lbu	a1,55(a0)
+    176c:	0242980b 	movn	s3,s2,v0
+    1770:	8fa40044 	lw	a0,68(sp)
+    1774:	8fa20014 	lw	v0,20(sp)
+    1778:	00441821 	addu	v1,v0,a0
+    177c:	00731021 	addu	v0,v1,s3
+    1780:	00052023 	negu	a0,a1
+    1784:	2442ffff 	addiu	v0,v0,-1
+    1788:	00441024 	and	v0,v0,a0
+    178c:	00641824 	and	v1,v1,a0
+    1790:	bc750000 	cache	0x15,0(v1)
+    1794:	1462fffe 	bne	v1,v0,1790 <__invoke_copy_from_user_dma+0x448>
+    1798:	00651821 	addu	v1,v1,a1
+    179c:	8fa20014 	lw	v0,20(sp)
+    17a0:	8fa30040 	lw	v1,64(sp)
+    17a4:	00438021 	addu	s0,v0,v1
+    17a8:	02131021 	addu	v0,s0,s3
+    17ac:	2442ffff 	addiu	v0,v0,-1
+    17b0:	00441024 	and	v0,v0,a0
+    17b4:	02041824 	and	v1,s0,a0
+    17b8:	bc710000 	cache	0x11,0(v1)
+    17bc:	1462fffe 	bne	v1,v0,17b8 <__invoke_copy_from_user_dma+0x470>
+    17c0:	00651821 	addu	v1,v1,a1
+    17c4:	0c00016e 	jal	5b8 <wait_mpegdma>
+    17c8:	3c110011 	lui	s1,0x11
+    17cc:	24040001 	li	a0,1
+    17d0:	36253ac0 	ori	a1,s1,0x3ac0
+    17d4:	0c000000 	jal	0 <mbus_intr>
+    17d8:	3206ffff 	andi	a2,s0,0xffff
+    17dc:	7e066c00 	ext	a2,s0,0x10,0xe
+    17e0:	24040001 	li	a0,1
+    17e4:	0c000000 	jal	0 <mbus_intr>
+    17e8:	36253ac4 	ori	a1,s1,0x3ac4
+    17ec:	24040001 	li	a0,1
+    17f0:	36253ac8 	ori	a1,s1,0x3ac8
+    17f4:	0c000000 	jal	0 <mbus_intr>
+    17f8:	02603021 	move	a2,s3
+    17fc:	24040001 	li	a0,1
+    1800:	36253acc 	ori	a1,s1,0x3acc
+    1804:	0c000000 	jal	0 <mbus_intr>
+    1808:	00003021 	move	a2,zero
+    180c:	16720004 	bne	s3,s2,1820 <__invoke_copy_from_user_dma+0x4d8>
+    1810:	36253ad8 	ori	a1,s1,0x3ad8
+    1814:	24040001 	li	a0,1
+    1818:	0800060a 	j	1828 <__invoke_copy_from_user_dma+0x4e0>
+    181c:	24060005 	li	a2,5
+    1820:	24040001 	li	a0,1
+    1824:	24060001 	li	a2,1
+    1828:	0c000000 	jal	0 <mbus_intr>
+    182c:	3c100011 	lui	s0,0x11
+    1830:	24040001 	li	a0,1
+    1834:	36053b00 	ori	a1,s0,0x3b00
+    1838:	0c000000 	jal	0 <mbus_intr>
+    183c:	33c6ffff 	andi	a2,s8,0xffff
+    1840:	24040001 	li	a0,1
+    1844:	36053b04 	ori	a1,s0,0x3b04
+    1848:	0c000000 	jal	0 <mbus_intr>
+    184c:	7fc66c00 	ext	a2,s8,0x10,0xe
+    1850:	24040001 	li	a0,1
+    1854:	36053b08 	ori	a1,s0,0x3b08
+    1858:	0c000000 	jal	0 <mbus_intr>
+    185c:	02603021 	move	a2,s3
+    1860:	24040001 	li	a0,1
+    1864:	36053b0c 	ori	a1,s0,0x3b0c
+    1868:	0c000000 	jal	0 <mbus_intr>
+    186c:	00003021 	move	a2,zero
+    1870:	16720004 	bne	s3,s2,1884 <__invoke_copy_from_user_dma+0x53c>
+    1874:	36053b18 	ori	a1,s0,0x3b18
+    1878:	24040001 	li	a0,1
+    187c:	08000623 	j	188c <__invoke_copy_from_user_dma+0x544>
+    1880:	24060005 	li	a2,5
+    1884:	24040001 	li	a0,1
+    1888:	24060001 	li	a2,1
+    188c:	0c000000 	jal	0 <mbus_intr>
+    1890:	02539023 	subu	s2,s2,s3
+    1894:	8fa40014 	lw	a0,20(sp)
+    1898:	03d3f021 	addu	s8,s8,s3
+    189c:	00932021 	addu	a0,a0,s3
+    18a0:	afa40014 	sw	a0,20(sp)
+    18a4:	1e40ffac 	bgtz	s2,1758 <__invoke_copy_from_user_dma+0x410>
+    18a8:	8fa50014 	lw	a1,20(sp)
+    18ac:	00b4102a 	slt	v0,a1,s4
+    18b0:	1440ff41 	bnez	v0,15b8 <__invoke_copy_from_user_dma+0x270>
+    18b4:	02f6b823 	subu	s7,s7,s6
+    18b8:	0c00016e 	jal	5b8 <wait_mpegdma>
+    18bc:	00000000 	nop
+    18c0:	12a00002 	beqz	s5,18cc <__invoke_copy_from_user_dma+0x584>
+    18c4:	41606000 	di
+    18c8:	41606020 	ei
+    18cc:	000000c0 	ehb
+    18d0:	3c100000 	lui	s0,0x0
+    18d4:	26100000 	addiu	s0,s0,0
+    18d8:	8e080090 	lw	t0,144(s0)
+    18dc:	8e090094 	lw	t1,148(s0)
+    18e0:	00141fc3 	sra	v1,s4,0x1f
+    18e4:	02883021 	addu	a2,s4,t0
+    18e8:	00d4202b 	sltu	a0,a2,s4
+    18ec:	00693821 	addu	a3,v1,t1
+    18f0:	00873821 	addu	a3,a0,a3
+    18f4:	3c050001 	lui	a1,0x1
+    18f8:	34a50048 	ori	a1,a1,0x48
+    18fc:	24040001 	li	a0,1
+    1900:	ae060090 	sw	a2,144(s0)
+    1904:	0c000000 	jal	0 <mbus_intr>
+    1908:	ae070094 	sw	a3,148(s0)
+    190c:	8fa30010 	lw	v1,16(sp)
+    1910:	8e080098 	lw	t0,152(s0)
+    1914:	8e09009c 	lw	t1,156(s0)
+    1918:	00431023 	subu	v0,v0,v1
+    191c:	00482021 	addu	a0,v0,t0
+    1920:	00001821 	move	v1,zero
+    1924:	0082302b 	sltu	a2,a0,v0
+    1928:	00692821 	addu	a1,v1,t1
+    192c:	00c52821 	addu	a1,a2,a1
+    1930:	ae040098 	sw	a0,152(s0)
+    1934:	ae05009c 	sw	a1,156(s0)
+    1938:	02e01021 	move	v0,s7
+    193c:	8fbf003c 	lw	ra,60(sp)
+    1940:	8fbe0038 	lw	s8,56(sp)
+    1944:	8fb70034 	lw	s7,52(sp)
+    1948:	8fb60030 	lw	s6,48(sp)
+    194c:	8fb5002c 	lw	s5,44(sp)
+    1950:	8fb40028 	lw	s4,40(sp)
+    1954:	8fb30024 	lw	s3,36(sp)
+    1958:	8fb20020 	lw	s2,32(sp)
+    195c:	8fb1001c 	lw	s1,28(sp)
+    1960:	8fb00018 	lw	s0,24(sp)
+    1964:	03e00008 	jr	ra
+    1968:	27bd0040 	addiu	sp,sp,64
+
+0000196c <em86xx_mbus_setup_dma_void>:
+    196c:	27bdffe8 	addiu	sp,sp,-24
+    1970:	afb00010 	sw	s0,16(sp)
+    1974:	afbf0014 	sw	ra,20(sp)
+    1978:	2490000c 	addiu	s0,a0,12
+    197c:	24040001 	li	a0,1
+    1980:	0c000000 	jal	0 <mbus_intr>
+    1984:	02002821 	move	a1,s0
+    1988:	30420007 	andi	v0,v0,0x7
+    198c:	1440fffc 	bnez	v0,1980 <em86xx_mbus_setup_dma_void+0x14>
+    1990:	24040001 	li	a0,1
+    1994:	02002821 	move	a1,s0
+    1998:	8fbf0014 	lw	ra,20(sp)
+    199c:	8fb00010 	lw	s0,16(sp)
+    19a0:	24060004 	li	a2,4
+    19a4:	08000000 	j	0 <mbus_intr>
+    19a8:	27bd0018 	addiu	sp,sp,24
+
+000019ac <mbus_memcpy>:
+    19ac:	27bdffd0 	addiu	sp,sp,-48
+    19b0:	afb1001c 	sw	s1,28(sp)
+    19b4:	3c110002 	lui	s1,0x2
+    19b8:	afb00018 	sw	s0,24(sp)
+    19bc:	24040001 	li	a0,1
+    19c0:	00a08021 	move	s0,a1
+    19c4:	362590a8 	ori	a1,s1,0x90a8
+    19c8:	afbf002c 	sw	ra,44(sp)
+    19cc:	afb40028 	sw	s4,40(sp)
+    19d0:	afb30024 	sw	s3,36(sp)
+    19d4:	afb20020 	sw	s2,32(sp)
+    19d8:	00e09821 	move	s3,a3
+    19dc:	0c000000 	jal	0 <mbus_intr>
+    19e0:	00c0a021 	move	s4,a2
+    19e4:	24040001 	li	a0,1
+    19e8:	362590a8 	ori	a1,s1,0x90a8
+    19ec:	2406ff01 	li	a2,-255
+    19f0:	2403ff0f 	li	v1,-241
+    19f4:	0c000000 	jal	0 <mbus_intr>
+    19f8:	00439024 	and	s2,v0,v1
+    19fc:	02002821 	move	a1,s0
+    1a00:	3624b000 	ori	a0,s1,0xb000
+    1a04:	24100001 	li	s0,1
+    1a08:	02603021 	move	a2,s3
+    1a0c:	00003821 	move	a3,zero
+    1a10:	afa00010 	sw	zero,16(sp)
+    1a14:	0c000000 	jal	0 <mbus_intr>
+    1a18:	afb00014 	sw	s0,20(sp)
+    1a1c:	1440000e 	bnez	v0,1a58 <mbus_memcpy+0xac>
+    1a20:	362590a8 	ori	a1,s1,0x90a8
+    1a24:	02802821 	move	a1,s4
+    1a28:	3624b080 	ori	a0,s1,0xb080
+    1a2c:	02603021 	move	a2,s3
+    1a30:	00003821 	move	a3,zero
+    1a34:	afb00014 	sw	s0,20(sp)
+    1a38:	0c000000 	jal	0 <mbus_intr>
+    1a3c:	afa00010 	sw	zero,16(sp)
+    1a40:	1040000a 	beqz	v0,1a6c <mbus_memcpy+0xc0>
+    1a44:	3630b08c 	ori	s0,s1,0xb08c
+    1a48:	3c040000 	lui	a0,0x0
+    1a4c:	0c000000 	jal	0 <mbus_intr>
+    1a50:	24840000 	addiu	a0,a0,0
+    1a54:	362590a8 	ori	a1,s1,0x90a8
+    1a58:	02403021 	move	a2,s2
+    1a5c:	0c000000 	jal	0 <mbus_intr>
+    1a60:	24040001 	li	a0,1
+    1a64:	080006ad 	j	1ab4 <mbus_memcpy+0x108>
+    1a68:	00001021 	move	v0,zero
+    1a6c:	24040001 	li	a0,1
+    1a70:	0c000000 	jal	0 <mbus_intr>
+    1a74:	02002821 	move	a1,s0
+    1a78:	30420007 	andi	v0,v0,0x7
+    1a7c:	1440fffc 	bnez	v0,1a70 <mbus_memcpy+0xc4>
+    1a80:	24040001 	li	a0,1
+    1a84:	3c100002 	lui	s0,0x2
+    1a88:	3611b00c 	ori	s1,s0,0xb00c
+    1a8c:	0c000000 	jal	0 <mbus_intr>
+    1a90:	02202821 	move	a1,s1
+    1a94:	30420007 	andi	v0,v0,0x7
+    1a98:	1440fffc 	bnez	v0,1a8c <mbus_memcpy+0xe0>
+    1a9c:	24040001 	li	a0,1
+    1aa0:	360590a8 	ori	a1,s0,0x90a8
+    1aa4:	02403021 	move	a2,s2
+    1aa8:	0c000000 	jal	0 <mbus_intr>
+    1aac:	24040001 	li	a0,1
+    1ab0:	02601021 	move	v0,s3
+    1ab4:	8fbf002c 	lw	ra,44(sp)
+    1ab8:	8fb40028 	lw	s4,40(sp)
+    1abc:	8fb30024 	lw	s3,36(sp)
+    1ac0:	8fb20020 	lw	s2,32(sp)
+    1ac4:	8fb1001c 	lw	s1,28(sp)
+    1ac8:	8fb00018 	lw	s0,24(sp)
+    1acc:	03e00008 	jr	ra
+    1ad0:	27bd0030 	addiu	sp,sp,48
+
+00001ad4 <em86xx_mbus_wait>:
+    1ad4:	27bdffc8 	addiu	sp,sp,-56
+    1ad8:	3c020010 	lui	v0,0x10
+    1adc:	afb60030 	sw	s6,48(sp)
+    1ae0:	afb5002c 	sw	s5,44(sp)
+    1ae4:	afb40028 	sw	s4,40(sp)
+    1ae8:	afb20020 	sw	s2,32(sp)
+    1aec:	afb1001c 	sw	s1,28(sp)
+    1af0:	afb00018 	sw	s0,24(sp)
+    1af4:	afbf0034 	sw	ra,52(sp)
+    1af8:	afb30024 	sw	s3,36(sp)
+    1afc:	0080a821 	move	s5,a0
+    1b00:	00a0b021 	move	s6,a1
+    1b04:	3450624e 	ori	s0,v0,0x624e
+    1b08:	00008821 	move	s1,zero
+    1b0c:	2492000c 	addiu	s2,a0,12
+    1b10:	3c140000 	lui	s4,0x0
+    1b14:	24040001 	li	a0,1
+    1b18:	0c000000 	jal	0 <mbus_intr>
+    1b1c:	02402821 	move	a1,s2
+    1b20:	30420007 	andi	v0,v0,0x7
+    1b24:	1040000c 	beqz	v0,1b58 <em86xx_mbus_wait+0x84>
+    1b28:	02409821 	move	s3,s2
+    1b2c:	8e820000 	lw	v0,0(s4)
+    1b30:	02020019 	multu	s0,v0
+    1b34:	00001010 	mfhi	v0
+    1b38:	1440ffff 	bnez	v0,1b38 <em86xx_mbus_wait+0x64>
+    1b3c:	2442ffff 	addiu	v0,v0,-1
+    1b40:	24024e20 	li	v0,20000
+    1b44:	26310001 	addiu	s1,s1,1
+    1b48:	12220028 	beq	s1,v0,1bec <em86xx_mbus_wait+0x118>
+    1b4c:	24040001 	li	a0,1
+    1b50:	080006c6 	j	1b18 <em86xx_mbus_wait+0x44>
+    1b54:	00000000 	nop
+    1b58:	2a224e20 	slti	v0,s1,20000
+    1b5c:	10400024 	beqz	v0,1bf0 <em86xx_mbus_wait+0x11c>
+    1b60:	24020005 	li	v0,5
+    1b64:	16c2007f 	bne	s6,v0,1d64 <em86xx_mbus_wait+0x290>
+    1b68:	00001021 	move	v0,zero
+    1b6c:	3c050002 	lui	a1,0x2
+    1b70:	34a50844 	ori	a1,a1,0x844
+    1b74:	0c000000 	jal	0 <mbus_intr>
+    1b78:	24040001 	li	a0,1
+    1b7c:	3043ffff 	andi	v1,v0,0xffff
+    1b80:	3c020010 	lui	v0,0x10
+    1b84:	3450624e 	ori	s0,v0,0x624e
+    1b88:	00008821 	move	s1,zero
+    1b8c:	080006f0 	j	1bc0 <em86xx_mbus_wait+0xec>
+    1b90:	3c120000 	lui	s2,0x0
+    1b94:	02020019 	multu	s0,v0
+    1b98:	00001010 	mfhi	v0
+    1b9c:	00000000 	nop
+    1ba0:	1440ffff 	bnez	v0,1ba0 <em86xx_mbus_wait+0xcc>
+    1ba4:	2442ffff 	addiu	v0,v0,-1
+    1ba8:	3c050002 	lui	a1,0x2
+    1bac:	34a50844 	ori	a1,a1,0x844
+    1bb0:	0c000000 	jal	0 <mbus_intr>
+    1bb4:	24040001 	li	a0,1
+    1bb8:	3043ffff 	andi	v1,v0,0xffff
+    1bbc:	26310001 	addiu	s1,s1,1
+    1bc0:	10600005 	beqz	v1,1bd8 <em86xx_mbus_wait+0x104>
+    1bc4:	24024e20 	li	v0,20000
+    1bc8:	1622fff2 	bne	s1,v0,1b94 <em86xx_mbus_wait+0xc0>
+    1bcc:	8e420000 	lw	v0,0(s2)
+    1bd0:	080006fe 	j	1bf8 <em86xx_mbus_wait+0x124>
+    1bd4:	02602821 	move	a1,s3
+    1bd8:	2a224e20 	slti	v0,s1,20000
+    1bdc:	10400006 	beqz	v0,1bf8 <em86xx_mbus_wait+0x124>
+    1be0:	02602821 	move	a1,s3
+    1be4:	08000759 	j	1d64 <em86xx_mbus_wait+0x290>
+    1be8:	00001021 	move	v0,zero
+    1bec:	24020005 	li	v0,5
+    1bf0:	16c2000f 	bne	s6,v0,1c30 <em86xx_mbus_wait+0x15c>
+    1bf4:	02602821 	move	a1,s3
+    1bf8:	0c000000 	jal	0 <mbus_intr>
+    1bfc:	24040001 	li	a0,1
+    1c00:	3c050002 	lui	a1,0x2
+    1c04:	34a50844 	ori	a1,a1,0x844
+    1c08:	24040001 	li	a0,1
+    1c0c:	0c000000 	jal	0 <mbus_intr>
+    1c10:	00408021 	move	s0,v0
+    1c14:	3c040000 	lui	a0,0x0
+    1c18:	24840000 	addiu	a0,a0,0
+    1c1c:	32050007 	andi	a1,s0,0x7
+    1c20:	0c000000 	jal	0 <mbus_intr>
+    1c24:	00403021 	move	a2,v0
+    1c28:	08000714 	j	1c50 <em86xx_mbus_wait+0x17c>
+    1c2c:	24040001 	li	a0,1
+    1c30:	24040001 	li	a0,1
+    1c34:	0c000000 	jal	0 <mbus_intr>
+    1c38:	02602821 	move	a1,s3
+    1c3c:	3c040000 	lui	a0,0x0
+    1c40:	24840000 	addiu	a0,a0,0
+    1c44:	0c000000 	jal	0 <mbus_intr>
+    1c48:	30450007 	andi	a1,v0,0x7
+    1c4c:	24040001 	li	a0,1
+    1c50:	0c000000 	jal	0 <mbus_intr>
+    1c54:	02a02821 	move	a1,s5
+    1c58:	24040001 	li	a0,1
+    1c5c:	26a50004 	addiu	a1,s5,4
+    1c60:	0c000000 	jal	0 <mbus_intr>
+    1c64:	00409021 	move	s2,v0
+    1c68:	24040001 	li	a0,1
+    1c6c:	26a50008 	addiu	a1,s5,8
+    1c70:	0c000000 	jal	0 <mbus_intr>
+    1c74:	00408821 	move	s1,v0
+    1c78:	24040001 	li	a0,1
+    1c7c:	02602821 	move	a1,s3
+    1c80:	0c000000 	jal	0 <mbus_intr>
+    1c84:	00408021 	move	s0,v0
+    1c88:	3c040000 	lui	a0,0x0
+    1c8c:	02203021 	move	a2,s1
+    1c90:	24840000 	addiu	a0,a0,0
+    1c94:	02402821 	move	a1,s2
+    1c98:	02003821 	move	a3,s0
+    1c9c:	0c000000 	jal	0 <mbus_intr>
+    1ca0:	afa20010 	sw	v0,16(sp)
+    1ca4:	3c040000 	lui	a0,0x0
+    1ca8:	02c02821 	move	a1,s6
+    1cac:	0c000000 	jal	0 <mbus_intr>
+    1cb0:	24840000 	addiu	a0,a0,0
+    1cb4:	3c02fffd 	lui	v0,0xfffd
+    1cb8:	34425000 	ori	v0,v0,0x5000
+    1cbc:	02a21021 	addu	v0,s5,v0
+    1cc0:	00022982 	srl	a1,v0,0x6
+    1cc4:	2ca20004 	sltiu	v0,a1,4
+    1cc8:	10400004 	beqz	v0,1cdc <em86xx_mbus_wait+0x208>
+    1ccc:	26c6fffb 	addiu	a2,s6,-5
+    1cd0:	2cc20003 	sltiu	v0,a2,3
+    1cd4:	14400006 	bnez	v0,1cf0 <em86xx_mbus_wait+0x21c>
+    1cd8:	3c030000 	lui	v1,0x0
+    1cdc:	3c040000 	lui	a0,0x0
+    1ce0:	0c000000 	jal	0 <mbus_intr>
+    1ce4:	24840000 	addiu	a0,a0,0
+    1ce8:	08000755 	j	1d54 <em86xx_mbus_wait+0x280>
+    1cec:	02602821 	move	a1,s3
+    1cf0:	00061080 	sll	v0,a2,0x2
+    1cf4:	00451021 	addu	v0,v0,a1
+    1cf8:	24630000 	addiu	v1,v1,0
+    1cfc:	00021080 	sll	v0,v0,0x2
+    1d00:	00431021 	addu	v0,v0,v1
+    1d04:	8c510000 	lw	s1,0(v0)
+    1d08:	3c120002 	lui	s2,0x2
+    1d0c:	24040001 	li	a0,1
+    1d10:	364590a0 	ori	a1,s2,0x90a0
+    1d14:	0c000000 	jal	0 <mbus_intr>
+    1d18:	02203021 	move	a2,s1
+    1d1c:	0000000f 	sync
+    1d20:	3c10a000 	lui	s0,0xa000
+    1d24:	8e000000 	lw	zero,0(s0)
+    1d28:	00000000 	nop
+    1d2c:	3c06ff00 	lui	a2,0xff00
+    1d30:	34c6ff00 	ori	a2,a2,0xff00
+    1d34:	02263024 	and	a2,s1,a2
+    1d38:	364590a0 	ori	a1,s2,0x90a0
+    1d3c:	0c000000 	jal	0 <mbus_intr>
+    1d40:	24040001 	li	a0,1
+    1d44:	0000000f 	sync
+    1d48:	8e000000 	lw	zero,0(s0)
+    1d4c:	00000000 	nop
+    1d50:	02602821 	move	a1,s3
+    1d54:	0c000000 	jal	0 <mbus_intr>
+    1d58:	24040001 	li	a0,1
+    1d5c:	30420007 	andi	v0,v0,0x7
+    1d60:	2c420001 	sltiu	v0,v0,1
+    1d64:	8fbf0034 	lw	ra,52(sp)
+    1d68:	8fb60030 	lw	s6,48(sp)
+    1d6c:	8fb5002c 	lw	s5,44(sp)
+    1d70:	8fb40028 	lw	s4,40(sp)
+    1d74:	8fb30024 	lw	s3,36(sp)
+    1d78:	8fb20020 	lw	s2,32(sp)
+    1d7c:	8fb1001c 	lw	s1,28(sp)
+    1d80:	8fb00018 	lw	s0,24(sp)
+    1d84:	03e00008 	jr	ra
+    1d88:	27bd0038 	addiu	sp,sp,56
+    1d8c:	00000000 	nop
+Disassembly of section .fixup:
+
+00000000 <.fixup>:
+   0:	08000368 	j	da0 <__invoke_copy_to_user_dma+0x184>
+   4:	2402fff2 	li	v0,-14
+   8:	08000374 	j	dd0 <__invoke_copy_to_user_dma+0x1b4>
+   c:	2402fff2 	li	v0,-14
+  10:	0800054a 	j	1528 <__invoke_copy_from_user_dma+0x1e0>
+  14:	2403fff2 	li	v1,-14
+  18:	08000557 	j	155c <__invoke_copy_from_user_dma+0x214>
+  1c:	2404fff2 	li	a0,-14
diff -Naur linux-2.6.25.8/arch/mips/tangox/platform.c linux-2.6.25.8-clean/arch/mips/tangox/platform.c
--- linux-2.6.25.8/arch/mips/tangox/platform.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/platform.c	2008-06-30 21:53:32.000000000 -0400
@@ -0,0 +1,191 @@
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+#include <linux/mtd/physmap.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#endif
+
+#define TANGOX_EHCI_BASE_ADDR           /*NON_CACHED*/(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR           /*NON_CACHED*/(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE  /*NON_CACHED*/(REG_BASE_host_interface + 0x1700)
+#define TANGOX_EHCI_IRQ                 IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT
+#define TANGOX_OHCI_IRQ                 IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT
+
+/* OHCI (USB full speed host controller) */
+static struct resource tangox_usb_ohci_resources[] = {
+	[0] = {
+		.start		= TANGOX_OHCI_BASE_ADDR,
+		.end		= TANGOX_OHCI_BASE_ADDR + 0xFF,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= TANGOX_OHCI_IRQ,
+		.end		= TANGOX_OHCI_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct platform_device tangox_usb_ohci_device = {
+	.name		= "tangox-ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(tangox_usb_ohci_resources),
+	.resource	= tangox_usb_ohci_resources,
+};
+
+/* EHCI (USB high speed host controller) */
+static struct resource tangox_usb_ehci_resources[] = {
+	[0] = {
+		.start		= TANGOX_EHCI_BASE_ADDR,
+		.end		= TANGOX_EHCI_BASE_ADDR + 0xFF,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= TANGOX_EHCI_IRQ,
+		.end		= TANGOX_EHCI_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+
+static struct platform_device tangox_usb_ehci_device = {
+	.name		= "tangox-ehci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(tangox_usb_ehci_resources),
+	.resource	= tangox_usb_ehci_resources,
+};
+
+#define XENV_MAX_FLASH    4
+#define XENV_MAX_FLASH_PARTITIONS   16
+static struct mtd_partition *mtd_parts[XENV_MAX_FLASH] = { NULL, NULL, NULL, NULL };
+static unsigned int p_cnts[XENV_MAX_FLASH] = { 0, 0, 0, 0 };
+static unsigned int f_sizes[XENV_MAX_FLASH] = { 0, 0, 0, 0 };
+
+extern int tangox_flash_get_info(int cs, unsigned int *size, unsigned int *part_count);
+extern int tangox_flash_get_parts(int cs, unsigned int offset[], unsigned int size[]);
+
+static struct physmap_flash_data tangox_flash_data = {
+	.parts    = NULL,
+	.nr_parts = 0,
+	.width = 2, /* To be checked by PBI registers */
+};
+
+static struct resource tangox_flash_resource[XENV_MAX_FLASH] = {
+    {
+	.start = 0x48000000,
+	.end = 0, /* Found in XENV */
+	.flags = IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device tangox_flash = {
+	.name          = "physmap-flash",
+	.id            = 0,
+	.dev           = { .platform_data = &tangox_flash_data, },
+	.resource      = &tangox_flash_resource,
+	.num_resources = 1,
+};
+
+static struct platform_device *tangox_platform_devices[] __initdata = {
+	&tangox_usb_ohci_device,
+	&tangox_usb_ehci_device,
+	&tangox_flash,
+};
+
+static int __init tangox_update_platform_flash(void)
+{
+	int cs;
+	int part_num = 0;
+	unsigned long csconfig = gbus_read_uint32(pGBus, REG_BASE_host_interface + PB_CS_config) & 0xf;
+
+	for (cs = 0; cs < 1; cs++) { // for now implement only 1 instead of XENV_MAX_FLASH 
+		/* Check XENV for availability */
+		f_sizes[cs] = p_cnts[cs] = 0;
+
+		tangox_flash_get_info(cs+2, &f_sizes[cs], &p_cnts[cs]);
+		if (f_sizes[cs] == 0)
+			continue;
+		else {
+			tangox_flash_resource[cs].end = tangox_flash_resource[cs].start + f_sizes[cs] - 1;
+			tangox_flash_data.width = ((csconfig >> cs) & 0x1) ? 1 : 2;
+		}
+
+		printk(KERN_INFO "physmap flash device CS%d: %lx at %lx\n", 
+				cs, f_sizes[cs], tangox_flash_resource[cs].start);
+
+#ifdef CONFIG_MTD_PARTITIONS
+		if (p_cnts[cs] > 0) {
+			int p, pcnt;
+			struct mtd_partition *part_ptr;
+			unsigned int offsets[XENV_MAX_FLASH_PARTITIONS];
+			unsigned int szs[XENV_MAX_FLASH_PARTITIONS];
+
+			if ((mtd_parts[cs] = (struct mtd_partition *)kmalloc(
+					sizeof(struct mtd_partition) * p_cnts[cs], GFP_KERNEL)) == NULL) {
+				printk(KERN_NOTICE "Out of memory.\n");
+				return -ENOMEM;
+			}
+			memset(mtd_parts[cs], 0, sizeof(struct mtd_partition) * p_cnts[cs]);
+			tangox_flash_get_parts(cs+2, offsets, szs);
+
+			printk(KERN_NOTICE "Using physmap partition definition\n");
+
+			/* Initialize each partition */
+			for (pcnt = 0, part_ptr = mtd_parts[cs], p = 0; p < p_cnts[cs]; p++) {
+				if (((szs[p] & 0x7fffffff) + offsets[p]) > f_sizes[cs]) {
+					printk(KERN_NOTICE "CS%d-Part%d (offset:0x%x, size:0x%x) outside physical map, removed.\n", 
+							cs, p + 1, offsets[p], szs[p] & 0x7fffffff);
+						continue;
+				}
+				part_ptr->size = szs[p] & 0x7fffffff;
+				part_ptr->offset = offsets[p];
+				if (part_ptr->size & 0x80000000)
+					part_ptr->mask_flags = MTD_WRITEABLE;
+				part_ptr->name = (char *)kmalloc(16, GFP_KERNEL); 
+				if (part_ptr->name != NULL) 
+					sprintf(part_ptr->name, "CS%d-Part%d", cs, p + 1);
+				pcnt++;
+				part_ptr++;
+			}
+			p_cnts[cs] = pcnt;
+
+			if (p_cnts[cs] > 0) {
+				printk(KERN_NOTICE "Adding partition #%d-#%d\n", part_num, part_num + p_cnts[cs] - 1);
+				tangox_flash_data.parts=mtd_parts[cs];
+				tangox_flash_data.nr_parts=p_cnts[cs];
+				part_num += p_cnts[cs];
+			}
+		}
+#endif
+	}
+	return 0;
+
+}
+
+int __init tangox_platform_init(void)
+{
+    tangox_update_platform_flash();
+    printk(KERN_INFO "Adding platform devices\n");
+	return platform_add_devices(tangox_platform_devices, ARRAY_SIZE(tangox_platform_devices));
+}
+
+arch_initcall(tangox_platform_init);
diff -Naur linux-2.6.25.8/arch/mips/tangox/prom.c linux-2.6.25.8-clean/arch/mips/tangox/prom.c
--- linux-2.6.25.8/arch/mips/tangox/prom.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/prom.c	2008-06-27 16:25:33.000000000 -0400
@@ -0,0 +1,616 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <linux/module.h>
+
+#include "setup.h"
+
+#ifdef CONFIG_TANGO3
+#include "xenv.h"
+#include "xenvkeys.h"
+#endif
+
+/*
+ * em8xxx_sys_frequency may be used later in the serial  code, DON'T mark
+ * it as initdata
+ */
+unsigned long em8xxx_sys_frequency;
+unsigned long em8xxx_cpu_frequency;
+unsigned long em8xxx_kmem_start;
+unsigned long em8xxx_kmem_size;
+#ifdef CONFIG_TANGO3
+unsigned long phy_remap;
+unsigned long max_remap_size;
+#endif
+
+unsigned long tangox_chip_id(void);
+int is_tango2_chip(void);
+int is_tango3_chip(void);
+int is_tango3_es2(void);
+
+/*
+ * we will restore remap registers before rebooting
+ */
+#ifdef CONFIG_TANGO2
+unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+unsigned long em8xxx_remap_registers[8];
+#endif
+
+/*
+ * helper to access base registers
+ */
+#define RD_BASE_REG32(r)	\
+		gbus_readl(REG_BASE_system_block + (r))
+
+/*
+ * return system type (/proc/cpuinfo)
+ */
+const char *get_system_type(void)
+{
+	return "Sigma Designs TangoX";
+}
+
+/*
+ * return system frequency
+ */
+#ifdef CONFIG_TANGOX_SYS_FREQUENCY
+unsigned long tangox_get_sysclock(void)
+{
+	return(CONFIG_TANGOX_SYS_FREQUENCY);
+}
+#else
+unsigned long tangox_get_sysclock(void)
+{
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	unsigned long sys_clkgen_pll, sysclk_mux, sysclk_premux;
+	unsigned long n, m, freq, div, k, mux;
+
+	k = m = sys_clkgen_pll = 0;
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	sysclk_premux = RD_BASE_REG32(SYS_sysclk_premux);
+
+	switch (sysclk_premux & 0x3) {
+		case 0:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen0_pll);
+			m = (sys_clkgen_pll >> 16) & 0x1f;
+			k = (sys_clkgen_pll >> 14) & 0x3;
+			break;
+		case 1:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen1_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 2:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen2_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 3:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen3_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+	}
+	n = sys_clkgen_pll & 0x000003ff;
+
+	/* Not using XTAL_IN, cannot calculate */
+	if ((sys_clkgen_pll & 0x07000000) != 0x01000000)
+		return(0);
+
+	/* Calculate the divider */
+	mux = (sysclk_mux >> 8) & 0xf;
+	if (mux == 0) /* Get system clock frequency */
+		div = 2;
+	else if ((mux == 1) || ((mux >= 8) && (mux < 0xc)))
+		div = 4;
+	else if ((mux >= 2) && (mux < 8))
+		div = 3;
+	else
+		return(0); /* Wrong divider setting */
+
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = ((TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2)) /
+			(div * (1 << k));
+	else
+		freq = TANGOX_BASE_FREQUENCY / div;
+#else
+	unsigned long sys_clkgen_pll, sysclk_mux, n, m, freq, div;
+
+	sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen_pll);
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	n = sys_clkgen_pll & 0x000003ff;
+	m = (sys_clkgen_pll & 0x003f0000) >> 16;
+
+	/* Calculate the divider */
+	if ((sysclk_mux & 0x300) == 0x000) /* Get system clock frequency */
+		div = 2;
+	else if ((sysclk_mux & 0x300) == 0x100)
+		div = 4;
+	else
+		div = 3;
+
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = ((TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2)) / div;
+	else
+		freq = TANGOX_BASE_FREQUENCY / div;
+#endif
+	return(freq);
+}
+#endif
+
+/*
+ * return cpu frequency
+ */
+#ifdef CONFIG_TANGOX_CPU_FREQUENCY
+unsigned long tangox_get_cpuclock(void)
+{
+	return(CONFIG_TANGOX_CPU_FREQUENCY);
+}
+#else
+unsigned long tangox_get_cpuclock(void)
+{
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	unsigned long sys_clkgen_pll, sysclk_mux, sysclk_premux;
+	unsigned long n, m, freq, div, k, mux;
+
+	k = m = sys_clkgen_pll = 0;
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	sysclk_premux = RD_BASE_REG32(SYS_sysclk_premux);
+
+	switch(sysclk_premux & 0x3) {
+		case 0:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen0_pll);
+			m = (sys_clkgen_pll >> 16) & 0x1f;
+			k = (sys_clkgen_pll >> 14) & 0x3;
+			break;
+		case 1:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen1_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 2:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen2_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 3:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen3_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+	}
+	n = sys_clkgen_pll & 0x000003ff;
+
+	/* Not using XTAL_IN, cannot calculate */
+	if ((sys_clkgen_pll & 0x07000000) != 0x01000000)
+		return(0);
+
+	/* Calculate the divider */
+	mux = (sysclk_mux >> 8) & 0xf;
+	if ((mux == 3) || (mux == 4) || (mux == 6)) /* Get CPU frequency */
+		div = 3;
+	else if ((mux == 8) || (mux == 0xa))
+		div = 4;
+	else if ((mux == 0) || (mux == 1) || (mux == 2) ||
+		 (mux == 5) || (mux == 7) ||
+		 (mux == 9) || (mux == 0xb))
+		div = 2;
+	else
+		return(0); /* Wrong divider setting */
+
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = ((TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2)) /
+			(div * (1 << k));
+	else
+		freq = TANGOX_BASE_FREQUENCY / div;
+#else
+	unsigned long sys_clkgen_pll, sysclk_mux, n, m, freq, div;
+
+	sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen_pll);
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	n = sys_clkgen_pll & 0x000003ff;
+	m = (sys_clkgen_pll & 0x003f0000) >> 16;
+
+	if ((sysclk_mux & 0x300) == 0x300) /* Get CPU frequency */
+		div = 3;
+	else
+		div = 2;
+
+	/* Calculate the divider */
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = ((TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2)) / div;
+	else
+		freq = TANGOX_BASE_FREQUENCY / div;
+#endif
+	return(freq);
+}
+#endif
+
+
+extern int do_syslog(int type, char * buf, int len);
+extern int __init xenv_config(void);
+extern void __init tangox_device_info(void);
+extern const char *tangox_xenv_cmdline(void);
+
+#ifdef CONFIG_TANGO3
+static inline unsigned long fixup_dram_address(unsigned long addr)
+{
+	if ((addr >= 0x10000000) && (addr < 0x20000000))
+		addr = (addr - 0x10000000) + 0x80000000; /* to DRAM0 */
+	else if ((addr >= 0x20000000) && (addr < 0x30000000))
+		addr = (addr - 0x20000000) + 0xc0000000; /* to DRAM1 */
+	return(addr);
+}
+#endif
+
+void __init prom_init(void)
+{
+	extern char _text;
+	unsigned long offset, em8xxx_kmem_end;
+	int clksel, xenv_res, i;
+	char *revStr = NULL;
+#ifdef CONFIG_TANGO2
+	memcfg_t *m;
+#endif
+
+	/*
+	 * save remap registers for reboot time
+	 */
+	for (i = 0; 
+#ifdef CONFIG_TANGO2
+		i < 5; 
+#elif defined(CONFIG_TANGO3)
+		i < 8; 
+#endif
+		i++) {
+		em8xxx_remap_registers[i] = gbus_readl(REG_BASE_cpu_block + CPU_remap + (i * 4));
+	}
+
+	/* 
+	 * Set remap so that 0x1fc00000 and 0x0 back to they should be...
+	 */
+	gbus_writel(REG_BASE_cpu_block + CPU_remap, 0x1fc00000);
+	gbus_writel(REG_BASE_cpu_block + CPU_remap1, 0x0);
+	iob();
+
+#ifdef CONFIG_TANGO3
+#define REMAP_IDX	(((CPU_REMAP_SPACE-CPU_remap2_address)/0x04000000)+2)
+	phy_remap = fixup_dram_address(em8xxx_remap_registers[REMAP_IDX]); 
+	max_remap_size = 0x04000000; /* minimum 64MB */
+	if (phy_remap != em8xxx_remap_registers[REMAP_IDX]) { /* fix up needed */ 
+		gbus_writel(REG_BASE_cpu_block + CPU_remap + REMAP_IDX * 4, phy_remap);
+		iob();
+	}
+	for (i = REMAP_IDX + 1; i < 8; i++) {
+		unsigned long newaddr = fixup_dram_address(em8xxx_remap_registers[i]);
+		if (newaddr == (phy_remap + (0x04000000 * (i - REMAP_IDX)))) {
+			max_remap_size += 0x04000000;
+			if (newaddr != em8xxx_remap_registers[i]) { /* fix up needed */
+				gbus_writel(REG_BASE_cpu_block + CPU_remap + i * 4, newaddr);
+				iob();
+			}
+		}
+	}
+	printk("Physcal map 0x%08lx to 0x%08x, max size is 0x%08lx\n",
+		phy_remap, CPU_REMAP_SPACE, max_remap_size);
+#endif
+	
+#if defined(CONFIG_TANGO2_SMP863X)
+	printk("Configured for SMP863%c (revision %s), ",
+#if defined(CONFIG_TANGO2_ES1)
+			'0', "ES1"
+#elif defined(CONFIG_TANGO2_ES2)
+			'0', "ES2"
+#elif defined(CONFIG_TANGO2_ES3)
+			'0', "ES3"
+#elif defined(CONFIG_TANGO2_ES4)
+			'4', "ES4"
+#elif defined(CONFIG_TANGO2_ES5)
+			'4', "ES5"
+#elif defined(CONFIG_TANGO2_ES6)
+			'x', "ES6+/RevA+"
+#elif defined(CONFIG_TANGO2_SD)
+			'x', "SD"
+#endif
+	      );
+#elif defined(CONFIG_TANGO3_SMP865X)
+	printk("Configured for SMP864x/SMP865x (revision %s), ",
+#if defined(CONFIG_TANGO3_ES1)
+			"ES1"
+#elif defined(CONFIG_TANGO3_ES2)
+			"ES2"
+#elif defined(CONFIG_TANGO3_ES3)
+			"ES3"
+#endif
+	      );
+#else
+#error Unsupported platform.
+#endif
+	printk("detected SMP%lx (revision ", (tangox_chip_id()>>16)&0xffff);
+	if (is_tango2_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x81: /* ES1-3 */
+				revStr = "ES1-3";
+				break;
+			case 0x82: /* ES4-5 */
+				revStr = "ES4-5";
+				break;
+			case 0x83: /* ES6/RevA */
+				revStr = "ES6/RevA";
+				break;
+			case 0x84: /* ES7/RevB */
+				revStr = "ES7/RevB";
+				break;
+			case 0x85: /* ES8 */
+				revStr = "ES8";
+				break;
+			case 0x86: /* ES9/RevC */
+				revStr = "ES9/RevC";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} else if (is_tango3_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x1: /* ES1 */
+				revStr = "ES1";
+				break;
+			case 0x2: /* ES2 */
+				revStr = "ES2";
+				break;
+			case 0x3: /* ES3 */
+				revStr = "ES3";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} else
+		revStr = "unknown";
+	
+	printk("%s).\n", revStr);
+	printk("Detected CPU/SYS Frequencies: %ld.%02ld/%ld.%02ldMHz\n",
+		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100);
+
+	/*
+	 * read xenv  configuration, we  need it quickly  to configure
+	 * console accordingly.
+	 *
+	 * NOTE: We  may stay STUCK in  this if safe  mode is required
+	 * and XENV is not valid !
+	 */
+	xenv_res = xenv_config();
+
+	/*
+	 * calculate cpu & sys frequency (may be needed for uart init)
+	 */
+	em8xxx_cpu_frequency = tangox_get_cpuclock();
+	em8xxx_sys_frequency = tangox_get_sysclock();
+
+	/*
+	 * program the right clock divider in both uart
+	 */
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	clksel = 0;
+#else
+	clksel = 1;
+#endif
+	gbus_writel(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL, clksel);
+	if (is_tango3_es2()) {
+		/* for hwbug#291 */
+		i = gbus_readl(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL);
+		gbus_writel(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL, i);
+	}
+	gbus_writel(REG_BASE_cpu_block + CPU_UART1_base + CPU_UART_CLKSEL, clksel);
+	if (is_tango3_es2()) {
+		/* for hwbug#291 */
+		i = gbus_readl(REG_BASE_cpu_block + CPU_UART1_base + CPU_UART_CLKSEL);
+		gbus_writel(REG_BASE_cpu_block + CPU_UART1_base + CPU_UART_CLKSEL, i);
+	}
+
+	/*
+	 * show KERN_DEBUG message on console
+	 */
+	do_syslog(8, NULL, 8);
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+	/* initialize uart and register early console */
+	prom_console_register();
+#endif
+
+	/* warn user if we use failsafe values for xenv */
+	if (xenv_res)
+		printk("Invalid XENV content, using failsafe values\n");
+	tangox_device_info();
+
+	/*
+	 * compute kernel memory start address/size
+	 * _text section gives kernel address start
+	 */
+	em8xxx_kmem_start = ((unsigned long)(&_text)) & PAGE_MASK;
+	em8xxx_kmem_size = (((CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE << 20) + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+
+#ifdef CONFIG_TANGO3
+	if (em8xxx_kmem_size > max_remap_size)
+		em8xxx_kmem_size = max_remap_size;
+
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(CPU_REMAP_SPACE);
+#else
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(MEM_BASE_dram_controller_0_alias);
+#endif
+
+#ifdef CONFIG_TANGO3
+	/* Get information from LR_XENV2_RO and put information into LR_XENV2_RW */
+	xenv_set((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_KERNEL_END, &em8xxx_kmem_end, 0, sizeof(em8xxx_kmem_end)); 
+#else
+	/*
+	 * check/fill the memcfg
+	 */
+	m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+	if (is_valid_memcfg(m) == 0) {
+		printk("Invalid MEMCFG, creating new one at 0x%08x.\n", MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+		memset(m, 0, sizeof (memcfg_t));
+		m->signature = MEMCFG_SIGNATURE;
+		m->dram0_size = TANGOX_SYSTEMRAM_ACTUALSIZE;
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+	} else {
+		printk("Valid MEMCFG found at 0x%08x.\n", MEM_BASE_dram_controller_0_alias + FM_MEMCFG);
+		m->kernel_end = em8xxx_kmem_end + 512*1024;
+		gen_memcfg_checksum(m);
+	}
+#endif
+
+	/*
+	 * tell kernel about available memory size/offset
+	 */
+#ifdef CONFIG_TANGO3
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(CPU_REMAP_SPACE);
+	add_memory_region(CPU_REMAP_SPACE + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#else
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(MEM_BASE_dram_controller_0_alias);
+	add_memory_region(MEM_BASE_dram_controller_0_alias + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#endif
+
+#ifndef CONFIG_TANGOX_IGNORE_CMDLINE
+	/*
+	 * set up correct linux command line according to XENV, memcfg
+	 * and YAMON args, if not told to ignore them
+	 */
+
+	/* If specified by xenv, override the command line */
+	if (tangox_xenv_cmdline())
+		strcpy(arcs_cmdline, tangox_xenv_cmdline());
+
+	/* If specified by memcfg, override the command line */
+//	if (m->linux_cmd != 0 && strlen((char *)KSEG1ADDR(m->linux_cmd)) > 0)
+//disabled. e.m. 2006feb3rd		strcpy(arcs_cmdline, (char *)KSEG1ADDR(m->linux_cmd));
+
+	/* take regular args given by bootloader */
+	if ((fw_arg0 > 1) && (fw_arg0 < 65)) { /* Up to 64 arguments */
+		int argc, i, pos;
+		char **argv;
+
+		argc = fw_arg0;
+		arcs_cmdline[0] = '\0';
+		argv = (char **) fw_arg1;
+		pos = 0;
+		for (i = 1; i < argc; i++) {
+			int len;
+
+			len = strlen(argv[i]);
+			if (pos + 1 + len + 1 > sizeof (arcs_cmdline))
+				break;
+			if (pos)
+				arcs_cmdline[pos++] = ' ';
+			strcpy(arcs_cmdline + pos, argv[i]);
+			pos += len;
+		}
+	}
+#endif /* CONFIG_TANGOX_IGNORE_CMDLINE */
+
+	mips_machtype = MACH_TANGOX;
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+EXPORT_SYMBOL(tangox_get_sysclock);
+EXPORT_SYMBOL(tangox_get_cpuclock);
+
+unsigned long tangox_chip_id(void)
+{
+	return (((gbus_readl(REG_BASE_host_interface + PCI_REG0) & 0xffff) << 16) |
+                        (gbus_readl(REG_BASE_host_interface + PCI_REG1) & 0xff));
+}
+
+int is_tango2_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return (chip == 0x8630) ? 1 : 0;
+}
+
+static inline int is_tango2_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	return (is_tango2_chip() && rev == revid) ? 1 : 0;
+}
+
+int is_tango2_es123(void)
+{
+	return(is_tango2_revision(0x81));
+}
+
+int is_tango2_es45(void)
+{
+	return(is_tango2_revision(0x82));
+}
+
+int is_tango2_es6(void)
+{
+	return(is_tango2_revision(0x83));
+}
+
+int is_tango2_es7(void)
+{
+	return(is_tango2_revision(0x84));
+}
+
+int is_tango2_es89(void)
+{
+	return(is_tango2_revision(0x85) || is_tango2_revision(0x86));
+}
+
+static inline int is_tango3_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	return (is_tango3_chip() && rev == revid) ? 1 : 0;
+}
+
+int is_tango3_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return ((chip == 0x8640) || (chip == 0x8650)) ? 1 : 0;
+}
+
+int is_tango3_es1(void)
+{
+	return(is_tango3_revision(0x1));
+}
+
+int is_tango3_es2(void)
+{
+	return(is_tango3_revision(0x2));
+}
+
+int is_tango3_es3(void)
+{
+	return(is_tango3_revision(0x3));
+}
+
+EXPORT_SYMBOL(tangox_chip_id);
+EXPORT_SYMBOL(is_tango2_chip);
+EXPORT_SYMBOL(is_tango3_chip);
+EXPORT_SYMBOL(is_tango2_es123);
+EXPORT_SYMBOL(is_tango2_es45);
+EXPORT_SYMBOL(is_tango2_es6);
+EXPORT_SYMBOL(is_tango2_es7);
+EXPORT_SYMBOL(is_tango2_es89);
+EXPORT_SYMBOL(is_tango3_es1);
+EXPORT_SYMBOL(is_tango3_es2);
+EXPORT_SYMBOL(is_tango3_es3);
+#ifdef CONFIG_TANGO3
+EXPORT_SYMBOL(phy_remap);
+EXPORT_SYMBOL(max_remap_size);
+#endif
+
diff -Naur linux-2.6.25.8/arch/mips/tangox/setup.c linux-2.6.25.8-clean/arch/mips/tangox/setup.c
--- linux-2.6.25.8/arch/mips/tangox/setup.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/setup.c	2008-11-19 17:07:17.000000000 -0500
@@ -0,0 +1,424 @@
+/*
+ * Copyright (C) 2007 Sigma Designs, inc.
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * arch/mips/tangox/setup.c
+ *     The setup file for tango2/tango3.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+#include <asm/time.h>
+#include <asm/serial.h>
+
+#include "setup.h"
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+extern unsigned long em86xx_tlb_dram1_map_base;
+extern unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)	\
+		gbus_readl(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		gbus_writel(REG_BASE_cpu_block + (r), (v))
+
+
+#ifdef CONFIG_TANGO2
+/*
+ * we use xrpc to reboot
+*/
+struct xrpc_block_header {
+	u32 callerid;
+	u32 xrpcid;
+
+	u32 param0;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+
+	u32 headerandblocksize;
+};
+
+#define XRPC_ID_REBOOT		19
+#define SOFT_IRQ_XRPC		(1 << 4)
+#endif
+
+void tangox_machine_restart(char *command)
+{
+	unsigned long tmp;
+	int i;
+#ifdef CONFIG_TANGO2
+ 	struct xrpc_block_header *pB;
+	unsigned long base_addr;
+	int loop;
+#endif
+
+        printk("Entered tangox_machine_restart\n");
+        local_irq_disable();
+
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+        /* Disable timer */
+	WR_CPU_REG32(CPU_time0_clr, 1);
+#endif
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	/* Resetting TangoX EHCI */
+	tmp = gbus_read_uint32(pGBus, REG_BASE_host_interface + 0x1410);
+	tmp &= ~1;
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x1410, tmp);
+	mdelay(5);
+
+	/* Resetting TangoX OHCI */
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x1514, 1<<31);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x1504, 0);
+	mdelay(5);
+
+	/* Resetting internal USB PHY in USB Control space */
+	tmp = gbus_read_uint32(pGBus, REG_BASE_host_interface + 0x1700);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x1700, tmp | 1);
+	udelay(30);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x1700, tmp);
+	mdelay(5);
+
+	/* Resetting internal OHCI in USB OHCI space*/
+	tmp = gbus_read_uint32(pGBus, REG_BASE_host_interface + 0x1508);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x1508, tmp | 0x01);
+
+	/* Reseting OHCI dpll, it says the bit is for simulation */
+	tmp = gbus_read_uint32(pGBus, REG_BASE_host_interface + 0x1700);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x1700, tmp | (1<<19));
+	mdelay(1);
+#endif
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) 
+	/* Resetting ethernet interface */
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x7018, 0);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x701c, 0);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + 0x7000, 1);
+	for (i = 0; (i < 10) && (gbus_read_uint32(pGBus, REG_BASE_host_interface + 0x7000) & 1); i++)
+		mdelay(1);
+
+	/* Resetting Video, MPEG0/MPEG1 blocks */ 
+	gbus_writel(REG_BASE_display_block + G2L_RESET_CONTROL, 3);
+	gbus_writel(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_writel(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_writel(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_writel(REG_BASE_display_block + G2L_RESET_CONTROL, 2);
+	gbus_writel(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Transport demux block */
+	gbus_writel(REG_BASE_demux_engine + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_writel(REG_BASE_demux_engine + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Audio0/1, host interface blocks */
+	gbus_writel(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_writel(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 3);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_writel(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_writel(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 2);
+	gbus_write_uint32(pGBus, REG_BASE_host_interface + G2L_RESET_CONTROL, 2);
+#endif
+
+	/* restore remap registers to boot state */
+	for (i = 0; 
+#ifdef CONFIG_TANGO2
+		i < 5; 
+#elif defined(CONFIG_TANGO3)
+		i < 8; 
+#endif
+		i++) {
+		gbus_writel(REG_BASE_cpu_block + CPU_remap + i * 4, em8xxx_remap_registers[i]);
+	}
+	iob();
+
+	/* Now to handle CPU side */
+
+#ifdef CONFIG_TANGO3
+	/* Using watchdog to trigger reset here */
+	gbus_writeb(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0x80); 
+	gbus_writeb(REG_BASE_system_block + SYS_watchdog_configuration, 0x1); /* Use XTAL_IN as source */
+
+	/* For ~100 usec delay */
+	gbus_writel(REG_BASE_system_block + SYS_watchdog_counter, TANGOX_BASE_FREQUENCY / 10000);
+	gbus_writeb(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0); /* Start counting */
+#else
+	/* nowhere to  jump, everything is  in xload format,  lets ask
+	 * xpu to reboot */
+	base_addr = DMEM_BASE_audio_engine_0;
+
+	pB = (struct xrpc_block_header *)base_addr;
+	gbus_writel((unsigned long)&pB->callerid, 0);
+	gbus_writel((unsigned long)&pB->headerandblocksize,
+		    (sizeof(struct xrpc_block_header) + 63) & ~63);
+	gbus_writel((unsigned long)&pB->xrpcid, XRPC_ID_REBOOT);
+	gbus_writel((unsigned long)&pB->param0, 0);
+	gbus_writel((unsigned long)&pB->param1, 0);
+	gbus_writel((unsigned long)&pB->param2, 0);
+	gbus_writel((unsigned long)&pB->param3, 0);
+	gbus_writel((unsigned long)&pB->param4, 0);
+
+	/* try to lock xrpc mutex for at most 1 sec */
+        while(gbus_readl((RMuint32)XRPC_MUTEX));
+/*	for (loop = 0; loop < 1000; loop++) {
+		if (!gbus_readl((RMuint32)XRPC_MUTEX))
+                {
+			printk("got xrpc mutex\n");
+			break;
+                }
+		mdelay(1);
+	}*/
+	gbus_writel(REG_BASE_cpu_block + LR_XPU_STAGE, (unsigned long)pB);
+
+	/* cross our fingers now */
+	gbus_writel(REG_BASE_irq_handler_block + CPU_irq_softset,
+		    SOFT_IRQ_XRPC);
+#endif
+        printk("infinite loop\n");
+	while (1);
+}
+
+void tangox_machine_halt(void)
+{
+	while (1);
+}
+
+void tangox_machine_power_off(void)
+{
+	while (1);
+}
+
+void __init plat_time_init(void)
+{
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+	mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+#else
+	/* FIXME:  we  will  need  to  unset this  if  we  reduce  cpu
+	 * frequency at runtime,  since gettimeoffset will then starts
+	 * to return bogus value */
+	mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+#endif
+	/* Clear heart beat counter */
+	WR_CPU_REG32(LR_HB_CPU, 0);
+}
+
+/*
+ * two variants for linux system timer , we can use internal cpu timer
+ * or hw timer0
+ */
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+/*
+ * CPU_time0_load
+ *  clock / HZ / (2 * prescale)
+ * CPU_time0_ctrl
+ *  PS(D2-3) : prescale. 0x00 = 1, 0x01 = 16, 0x10 = 256
+ *    There is a bug, and the actual prescale is 0x01 = 32, 0x10 = 512
+ *  M(D6) : periodic mode
+ *  E(D7) : enable
+ */
+/*#define TICKS_PER_SEC           em8xxx_sys_frequency
+#define TIMER_PRESCALE          32
+#define TIMER_PRESCALEBITS      5
+#define TIMER_RELOAD            ((TICKS_PER_SEC / HZ) >> (TIMER_PRESCALEBITS))
+
+#define TIMER_ENABLE            0x80    // D7
+#define TIMER_PERIODIC          0x40    // D6
+#define TIMER_PRESCALE_1        0x00    // D[2-3] = 00b
+#define TIMER_PRESCALE_32       0x04    // D[2-3] = 01b
+#define TIMER_PRESCALE_512      0x08    // D[2-3] = 10b
+
+static void tangox_timer_ack(void)
+{
+	gbus_writel(REG_BASE_cpu_block + CPU_time0_clr, 1);
+}
+*/
+/*
+ * Setup Timer0 as the source
+ */
+/*static void __init tangox_timer_setup(struct irqaction *irq)
+{*/
+	/* CPU_time0_load  register contains  just  16-bits value  So,
+	   take cate not the value to overflow */
+/*	WR_CPU_REG32(CPU_time0_load, TIMER_RELOAD);
+	WR_CPU_REG32(CPU_time0_ctrl, TIMER_ENABLE | TIMER_PERIODIC |
+		     TIMER_PRESCALE_32);
+	WR_CPU_REG32(CPU_time0_clr, 1);
+
+	setup_irq(LOG2_CPU_TIMER0_INT + IRQ_CONTROLLER_IRQ_BASE, irq);
+*/
+	/* set ack callback */
+/*	mips_timer_ack = tangox_timer_ack;*/
+
+	/* Clear heart beat counter */
+/*	WR_CPU_REG32(LR_HB_CPU, 0);
+}*/
+#else
+/*
+ * Setup CPU timer as source
+ */
+/*static void __init tangox_timer_setup(struct irqaction *irq)
+{
+	setup_irq(MIPS_CPU_IRQ_BASE + STATUSB_IP7 - STATUSB_IP0, irq);
+*/
+	/* Clear heart beat counter */
+/*	WR_CPU_REG32(LR_HB_CPU, 0);
+}*/
+#endif /* CONFIG_TANGOX_USE_CPU_CLOCK */
+
+
+/*
+ * setup remap registers, we may need  to use ioremap() so we can't do
+ * this in plat_setup, this function is set as arch_initcall().
+ */
+static int __init tangox_remap_setup(void)
+{
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+	memcfg_t *m;
+#endif
+
+#if defined(CONFIG_TANGO2) 
+	/*
+	 * Program CPU_remap so we can see full 256MB space in KSEG0 /
+	 * KSEG1
+	 */
+#if defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+	/*
+	 * Use TLB mapping to map the DRAM1 (size specified by memcfg)
+	 * into KSEG2
+	 */
+	m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0 + FM_MEMCFG);
+
+	if (m->dram1_size) {
+		em86xx_tlb_dram1_map_size = ((m->dram1_size > 0x20000000) ? 
+			0x20000000 : m->dram1_size); /* Max. 512MB */
+		em86xx_tlb_dram1_map_base =
+			(unsigned long)ioremap(MEM_BASE_dram_controller_1,
+					       m->dram1_size);
+		printk("tangox: creating TLB mapping for 0x%08x at 0x%08lx, "
+		       "size 0x%08lx.\n", MEM_BASE_dram_controller_1,
+		       em86xx_tlb_dram1_map_base, em86xx_tlb_dram1_map_size);
+	} else {
+		printk("tangox: dram1 size is 0, _not_ creating mapping\n");
+	}
+#else
+	/*
+	 * Use remap strategy (CPU_remap3/4 for 128MB resolution)
+	 */
+	printk("tangox: creating CPU mapping for 0x%08x at 0x%08x, "
+	       "size 0x%08x.\n", MEM_BASE_dram_controller_1,
+	       CPU_remap3_address, 0x08000000);
+
+	/*
+	 * remap dram controller 1 at 0x08000000 -> 0x0fffffff (128MB)
+	 * so Linux can see it in KSEG[01]
+	 */
+	gbus_writel(REG_BASE_cpu_block + CPU_remap3,
+		    MEM_BASE_dram_controller_1);
+	gbus_writel(REG_BASE_cpu_block + CPU_remap4,
+		    MEM_BASE_dram_controller_1 + 0x04000000);
+	iob();
+#endif
+#endif
+
+	return 0;
+}
+
+arch_initcall(tangox_remap_setup);
+
+extern int tangox_uart_enabled(int uart);
+extern int tangox_uart_baudrate(int uart);
+extern int tangox_uart_console_port(void);
+
+void __init plat_mem_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	int i;
+#endif
+
+	_machine_restart = tangox_machine_restart;
+	_machine_halt = tangox_machine_halt;
+	pm_power_off = tangox_machine_power_off;
+
+#ifdef CONFIG_SERIAL_8250
+	/*
+	 * register enable uart(s)
+	 */
+	if (tangox_uart_console_port()) { /* Console on UART1 */
+		for (i = 1; i >= 0; i--) {
+			struct uart_port uart;
+
+			if (!tangox_uart_enabled(i))
+				continue;
+
+			memset(&uart, 0, sizeof (uart));
+			uart.line = 1 - i; /* Reverse the order so it's UART1/UART0 instead of UART0/UART1 */
+			uart.uartclk = tangox_uart_baudrate(i) << 4;
+			uart.irq = IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_UART0_INT + i;
+			uart.flags = UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;
+			uart.membase = (unsigned char *)(REG_BASE_cpu_block +
+					CPU_UART0_base + i * 0x100);
+			uart.mapbase = (unsigned char *)(REG_BASE_cpu_block +
+					CPU_UART0_base + i * 0x100);
+			uart.iotype = UPIO_MEM;
+			uart.regshift = 2;
+
+			if (early_serial_setup(&uart))
+				printk("early_serial_setup failed\n");
+		}
+	} else {
+		for (i = 0; i < 2; i++) {
+			struct uart_port uart;
+
+			if (!tangox_uart_enabled(i))
+				continue;
+
+			memset(&uart, 0, sizeof (uart));
+			uart.line = i;
+			uart.uartclk = tangox_uart_baudrate(i) << 4;
+			uart.irq = IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_UART0_INT + i;
+			uart.flags = UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;
+			uart.membase = (unsigned char *)(REG_BASE_cpu_block +
+					CPU_UART0_base + i * 0x100);
+			uart.mapbase = (unsigned char *)(REG_BASE_cpu_block +
+					CPU_UART0_base + i * 0x100);
+			uart.iotype = UPIO_MEM;
+			uart.regshift = 2;
+
+			if (early_serial_setup(&uart))
+				printk("early_serial_setup failed\n");
+		}
+	}
+#endif
+
+	/*
+	 * set I/O /mem regions limit
+	 */
+	ioport_resource.start = 0;
+	ioport_resource.end = 0x80000000UL - 1;
+	iomem_resource.start = 0;
+	iomem_resource.end = 0x80000000UL - 1;
+
+}
diff -Naur linux-2.6.25.8/arch/mips/tangox/setup.h linux-2.6.25.8-clean/arch/mips/tangox/setup.h
--- linux-2.6.25.8/arch/mips/tangox/setup.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/setup.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,68 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * misc vars/func shared by platform setup code
+ */
+
+#ifndef __SETUP_H
+#define __SETUP_H
+
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <linux/interrupt.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/emhwlib_dram.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/memcfg.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <linux/interrupt.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/emhwlib_dram.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/hardware.h>
+#else
+#error "Unknown architecture"
+#endif
+
+/*
+ * in console.c
+ */
+void prom_console_register(void);
+
+/*
+ * in prom.c
+ */
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+#ifdef CONFIG_TANGO2
+extern unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+extern unsigned long em8xxx_remap_registers[8];
+#endif
+unsigned long tangox_get_cpuclock(void);
+unsigned long tangox_get_sysclock(void);
+
+/*
+ * in irq.c
+ */
+void tangox_dispatch(int ipline);
+
+/*
+ * in tangoxIRQ.S
+ */
+extern asmlinkage void tangoxIRQ(void);
+
+#endif
diff -Naur linux-2.6.25.8/arch/mips/tangox/sha.c linux-2.6.25.8-clean/arch/mips/tangox/sha.c
--- linux-2.6.25.8/arch/mips/tangox/sha.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/sha.c	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,130 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <asm/scatterlist.h>
+#include <asm/byteorder.h>
+#include <crypto/sha.h>
+
+#include "sha.h"
+
+static void tangosha1_init(struct sha1_ctx *sctx)
+{
+	static const struct sha1_ctx initstate = {
+	  0,
+	  { SHA1_H0, SHA1_H1, SHA1_H2, SHA1_H3, SHA1_H4 },
+	  { 0, }
+	};
+
+	*sctx = initstate;
+}
+
+static void tangosha1_update(struct sha1_ctx *sctx, const u8 *data,
+			unsigned int len)
+{
+	unsigned int partial, done;
+	const u8 *src;
+
+	partial = sctx->count & 0x3f;
+	sctx->count += len;
+	done = 0;
+	src = data;
+
+	if ((partial + len) > 63) {
+		u32 temp[SHA_WORKSPACE_WORDS];
+
+		if (partial) {
+			done = -partial;
+			memcpy(sctx->buffer + partial, data, done + 64);
+			src = sctx->buffer;
+		}
+
+		do {
+			sha_transform(sctx->state, src, temp);
+			done += 64;
+			src = data + done;
+		} while (done + 63 < len);
+
+		memset(temp, 0, sizeof(temp));
+		partial = 0;
+	}
+	memcpy(sctx->buffer + partial, src, len - done);
+}
+
+
+
+/* Add padding and return the message digest. */
+
+static void tangosha1_final(struct sha1_ctx *sctx, u8 *out)
+{
+	__be32 *dst = (__be32 *)out;
+	u32 i, index, padlen;
+	__be64 bits;
+	static const u8 padding[64] = { 0x80, };
+
+	bits = cpu_to_be64(sctx->count << 3);
+
+	/* Pad out to 56 mod 64 */
+	index = sctx->count & 0x3f;
+	padlen = (index < 56) ? (56 - index) : ((64+56) - index);
+	tangosha1_update(sctx, padding, padlen);
+
+	/* Append length */
+	tangosha1_update(sctx, (const u8 *)&bits, sizeof(bits));
+
+	/* Store state in digest */
+	for (i = 0; i < 5; i++)
+		dst[i] = cpu_to_be32(sctx->state[i]);
+
+	/* Wipe context */
+	memset(sctx, 0, sizeof *sctx);
+}
+
+#ifdef CONFIG_CRYPTO_SHA1
+void __init sha1_full(u8 *digest, const u8 *src, u32 len)
+{
+	struct sha1_ctx ctx;
+	int i;
+	u8 tmp;
+	tangosha1_init(&ctx);
+	tangosha1_update(&ctx, src, len);
+	tangosha1_final(&ctx, digest);
+
+	for (i = 0; i < SHA1_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA1_DIGEST_SIZE - i - 1];
+		digest[SHA1_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+void __init sha256_full(u8 *digest, const u8 *src, u32 len)
+{
+	struct sha256_ctx ctx;
+	struct crypto_tfm tfm = {NULL, NULL, NULL, &ctx};
+	int i;
+	u8 tmp;
+
+	sha256_init(&tfm);
+	sha256_update(&tfm, src, len);
+	sha256_final(&tfm, digest);
+
+	for (i = 0; i < SHA256_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA256_DIGEST_SIZE - i - 1];
+		digest[SHA256_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
diff -Naur linux-2.6.25.8/arch/mips/tangox/sha.h linux-2.6.25.8-clean/arch/mips/tangox/sha.h
--- linux-2.6.25.8/arch/mips/tangox/sha.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/sha.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,43 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SHA_H__
+#define __SHA_H__
+
+#ifdef CONFIG_CRYPTO_SHA1
+#define SHA1_DIGEST_SIZE        20
+
+struct sha1_ctx {
+	u64 count;
+        u32 state[5];
+        u8 buffer[64];
+};
+
+/*void sha1_init(struct crypto_tfm *tfm);
+void sha1_update(struct crypto_tfm *tfm, const u8 *data, unsigned int len);
+void sha1_final(struct crypto_tfm *tfm, u8 *out);*/
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+#define SHA256_DIGEST_SIZE      32
+
+struct sha256_ctx {
+	u32 count[2];
+        u32 state[8];
+        u8 buf[128];
+};
+
+void sha256_init(struct crypto_tfm *tfm);
+void sha256_update(struct crypto_tfm *tfm, const u8 *data, unsigned int len);
+void sha256_final(struct crypto_tfm *tfm, u8 *out);
+#endif
+
+#endif
+
diff -Naur linux-2.6.25.8/arch/mips/tangox/xenv.c linux-2.6.25.8-clean/arch/mips/tangox/xenv.c
--- linux-2.6.25.8/arch/mips/tangox/xenv.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/xenv.c	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,270 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include "setup.h"
+#include "xenv.h"
+#include "sha.h"
+
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#endif
+
+#if 0
+# define DPRINTK(fmt, args...)	printk(KERN_DEBUG "xenv: " fmt, ## args)
+#else
+# define DPRINTK(fmt, args...)
+#endif
+
+#if defined(CONFIG_TANGO2)
+#define XENV_DIGEST_SIZE   SHA1_DIGEST_SIZE
+void sha1_full(u8 *digest, const u8 *src, u32 len);
+#elif defined(CONFIG_TANGO3)
+#define XENV_DIGEST_SIZE   SHA256_DIGEST_SIZE
+void sha256_full(u8 *digest, const u8 *src, u32 len);
+#endif
+
+#define XENV_HDR_SIZE      (XENV_DIGEST_SIZE + 4)
+#define REC_SIZE(x)	   ((((u16)x[0] & 0xff) << 8) | ((u16)x[1] & 0xff))
+#define REC_ATTR(x)	   ((x[0] & 0xff) >> 4)
+
+#define xos_strlen(x)	   strlen(x)
+#define xos_strcmp(x,y)	   strcmp(x,y)
+#define xos_memcpy(x,y,z)  memcpy(x,y,z)
+
+void __init xenv_digest_full(u8 *digest, const u8 *src, u32 len)
+{
+#if defined(CONFIG_TANGO2)
+	sha1_full(digest, src, len);
+#elif defined(CONFIG_TANGO3)
+	sha256_full(digest, src, len);
+#endif
+}
+
+/*
+ * check for valid XENV at given address
+ */
+int __init xenv_isvalid(u32 *base, u32 maxsize)
+{
+	u32 env_size = base[0];
+	u32 hash[XENV_DIGEST_SIZE/4];
+
+	if ((24 <= env_size) && (env_size <= maxsize)) {
+		memset(hash, 0, sizeof (hash));
+		xenv_digest_full((u8 *)hash, (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+		if (memcmp((const u8 *)(base + 1), hash, XENV_DIGEST_SIZE) != 0) {
+			DPRINTK("corrupted\n");
+			return -1;
+		}
+
+		/* valid xenv ! */
+		return env_size;
+	}
+
+	DPRINTK("runaway %d\n", env_size);
+	return -1;
+}
+
+int __init xenv_foreach(u32 *base, u32 size,
+			void (*cb)(char *recordname, void *data, u32 datasize))
+{
+	int i;
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	/* loop on each record name */
+	while (i < size) {
+		u16 rec_size;
+		char *p, *recordname;
+		void *data;
+		u32 key_len, data_len;
+
+		p = (char *)base + i;
+		rec_size = REC_SIZE(p);
+		recordname = p + 2;
+		key_len = strlen(recordname);
+		data = recordname + key_len + 1;
+		data_len = rec_size - 2 - key_len - 1;
+
+		cb(recordname, data, data_len);
+		i += rec_size;
+	}
+
+	return -1;
+}
+
+#ifdef CONFIG_TANGO3
+/* Use this to set xenv to lrrw */
+static int __init xenv_lookup(RMuint32 *base,RMuint32 size,RMascii *recordname)
+{
+	RMascii *p;
+	int i;
+	int env_size;
+	
+	env_size=xenv_isvalid((u32 *)base,size);
+	
+	if (env_size<0) 
+		return -2;
+	
+	// RMDBGLOG((LOCALDBG, "[%s]\n",recordname));
+	
+	p=(RMascii *)base;
+	i=XENV_HDR_SIZE; 			// jump over header
+	
+	while(i<env_size){
+		RMuint16 rec_size=((p[i]&0xf)<<8) + (((RMuint16)p[i+1])&0xff);
+
+		if (!xos_strcmp(recordname, p+i+2)) 
+			return i;
+		
+		i+=rec_size;
+	}
+	
+	return -1;
+}
+
+/* Use this to get xenv to lrrw/lrro */
+int __init xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize)
+{
+	RMascii *p = (RMascii *)base;
+	RMuint32 data_len;
+	RMuint32 key_len;
+	RMuint32 env_size;
+	
+	int i;	
+	
+	env_size=base[0];
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -2 /* RM_ERROR */;
+	if(i==-1) 
+		return -1 /* RM_NOT_FOUND */;
+
+	// else we found the record
+	key_len=xos_strlen(recordname);
+	data_len=((p[i] & 0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+	data_len-=2+key_len+1;
+	
+	if(data_len>*datasize) {
+		*datasize=data_len;
+
+		// RMDBGLOG((ENABLE,"cannot store result\n"));
+		return -3 /* RM_INSUFFICIENT_SIZE */;
+	}
+	
+	*datasize=data_len;
+	xos_memcpy(dst, p+i+2+key_len+1, data_len);
+
+	// RMDBGLOG((LOCALDBG, "found [%s], length %d\n",recordname,*datasize));
+
+	return 0 /* RM_OK */;
+}
+
+int __init xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize)
+{
+	RMascii *p;
+	RMuint32 env_size;
+	RMuint32 rec_attr;
+	RMuint32 rec_size;
+	RMuint32 key_len;
+	int i;
+
+	// RMDBGLOG((LOCALDBG, "[%s], length %d\n", recordname,datasize));
+	
+	p=(RMascii *)base;
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -1 /* RM_ERROR */;
+	env_size=base[0];
+
+	if(i>=0) {
+		// RMDBGLOG((LOCALDBG, "deleting record\n"));
+		
+		rec_attr=p[i]>>4;
+		rec_size=((p[i]&0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+			
+#if 0
+		if ((rec_attr==XENV_ATTR_RO)&&src) {
+			// RMDBGLOG((ENABLE,"wanna change ro record\n"));
+			return RM_INVALIDMODE;
+		}
+		
+		if (rec_attr==XENV_ATTR_OTP) {
+			// RMDBGLOG((ENABLE,"wanna change/clear otp record\n"));
+			return RM_INVALIDMODE;
+		}
+#endif
+
+		// delete the record. Supposes memcpy is implemented increasing.
+		xos_memcpy(p+i, p+i+rec_size, env_size-(i+rec_size));
+		env_size-=rec_size;
+	}
+		
+	// add the record at the end if needed.
+	if(src) {
+		i=env_size;
+		key_len=xos_strlen(recordname);
+		rec_size=2+key_len+1+datasize;
+
+		if((i+rec_size)>=size)
+			return -3 /* RM_INSUFFICIENT_SIZE */;
+		
+		p[i]=((attr&0xf)<<4) | ((rec_size>>8)&0xf);
+		p[i+1]=rec_size&0xff;
+		
+		xos_memcpy(p+i+2, recordname, key_len+1);
+		xos_memcpy(p+i+2+key_len+1, src, datasize);
+		
+		env_size+=rec_size;
+	}
+	
+	base[0]=env_size;
+	//full_sha256(base+1,(const RMuint8 *)(base+9),env_size-36,0);
+	xenv_digest_full((u8 *)(base+1), (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+
+	return 0 /* RM_OK */;
+}
+#endif
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+void __init xenv_dump(u32 *base, u32 size)
+{
+	int i;
+	u32 records = 0;
+
+	printk("@%p\n", base);
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	while (i < size){
+		u8 rec_attr;
+		u16 rec_size;
+		char *p, *recordname, *x;
+		u32 key_len;
+
+		p = (char *)base + i;
+		rec_attr = REC_ATTR(p);
+		rec_size = REC_SIZE(p);
+		recordname = p + 2;
+		key_len = strlen(recordname);
+
+		printk("(0x%02x) [%s] =", rec_attr, recordname);
+		for (x = recordname + key_len + 1;
+		     x < recordname + rec_size - 2; x++)
+			printk(" %02x", (u8)*x);
+		printk(" .\n");
+
+		records++;
+		i += rec_size;
+	}
+
+	printk("%d records, %d bytes\n\n", records, size);
+}
+#endif
diff -Naur linux-2.6.25.8/arch/mips/tangox/xenv.h linux-2.6.25.8-clean/arch/mips/tangox/xenv.h
--- linux-2.6.25.8/arch/mips/tangox/xenv.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/xenv.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,97 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   xenv.h
+  @brief
+
+  The prototypes below act on a clear area respecting the xenv format.
+
+  (De)ciphering the  area, as well as committing  the changes (writing
+  the area to flash) are trivial add-ons on top of this API.
+
+  The underlying  implementation is not optimized for  speed (read and
+  write in  O(nrecords)). There  is no fragmentation  (data completely
+  rearranged at each write).
+
+  It is  not advised to repeatedly  act on flash stored  data, for the
+  device does  not support  unlimited read/write operations  (refer to
+  spec)
+
+  Power  loss when  committing the  changes cause  loss of  the stored
+  data.  This  can be avoided  by storing the  same data twice  to two
+  different sectors.
+
+  --------------------------------------------------------------------------
+  Specification   of   a   secure   storage   on   serial   flash   of
+  reboot-persistent data (xenv format)
+
+  We  describe a  way  to  concatenate (at  most  4KByte area  (12bits
+  limit)) variable  length records identified  by a string,  the `key'
+  (working much like Windows registry)
+
+  Page, seen as a byte array, is
+
+  0          4                   24                 env_size         4KB
+  | env_size | SHA-1 of following | rec0 | rec1 | .. | recn | xx xx .. |
+
+  The SHA-1 extent is env_size-24.
+
+  Description of a rec (bytes):
+
+  |4bits   12bits (2bytes)   | variable, NULL terminated | variable         |
+  attr     total record size   record name (string)        record value
+
+  attr =
+   XENV_ATTR_RW
+   XENV_ATTR_RO can be written once only but can be deleted
+   XENV_ATTR_OTP this record can be written once only and cannot be deleted
+  --------------------------------------------------------------------------
+
+  @author Emmanuel Michon
+  @date   2005-05-17
+*/
+
+#ifndef __XENV_H__
+#define __XENV_H__
+
+#include "setup.h"
+
+#define MAX_XENV_SIZE   16384
+
+/**
+   Check for compliance with xenv format
+
+   May be corrupted by:
+   - forgot to format
+   - power loss during sflash write
+   - intrusion
+
+   @param base
+   @param size
+   @return -ReturnValue-: env_size>=0 if valid, -1 if not.
+*/
+int xenv_isvalid(u32 *base, u32 maxsize);
+
+int xenv_foreach(u32 *base, u32 size,
+		 void (*cb)(char *recordname, void *data, u32 datasize));
+
+int xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize);
+int xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize);
+
+void xenv_dump(u32 *base, u32 size);
+
+#ifdef CONFIG_TANGO3
+/*
+ * XENV sizes LRRO/LRRW
+ */
+#define MAX_LR_XENV2_RO 768
+#define MAX_LR_XENV2_RW 768
+#endif
+
+#endif // __XENV_H__
diff -Naur linux-2.6.25.8/arch/mips/tangox/xenv_config.c linux-2.6.25.8-clean/arch/mips/tangox/xenv_config.c
--- linux-2.6.25.8/arch/mips/tangox/xenv_config.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/xenv_config.c	2008-10-17 20:04:36.000000000 -0400
@@ -0,0 +1,669 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * Check and  read full xenv config  at boot if valid,  else will stop
+ * boot process or use failsafe values.
+ */
+
+#include "setup.h"
+#include "xenv.h"
+#include "xenvkeys.h"
+
+#include <linux/module.h>
+#include <asm/bootinfo.h>
+
+/*
+ * use CPU_remap1 to access XENV content
+ */
+#define TMP_REMAPPED_REG   CPU_remap1
+#define TMP_REMAPPED_BASE  CPU_remap1_address
+#define TMP_REMAPPED_SIZE  0x00010000
+#define TMP_REMAPPED_MASK  ~(TMP_REMAPPED_SIZE-1)
+
+/*
+ * cached values of xenv content
+ */
+#define XENV_MAX_FLASH_PARTITIONS   16
+
+/*
+ * default is  to have one  partition on each  flash at offset  0 that
+ * span all the flash. If CONFIG_TANGOX_XENV_DEF_CSx_SIZE is set to 0,
+ * cs will be ignored.
+ */
+#ifdef CONFIG_TANGOX_XENV_READ_SAFE
+/* The data will be filled from XENV later */
+static u32 cs_flash_size[4] = { 0, 0, 0, 0 };
+static u32 flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = { { 0 }, { 0 }, { 0 }, { 0 }, };
+static u32 enabled_devices = 0;
+static u32 uart_baudrate = 0;
+static u32 uart_baudrates[2] = { 0, 0 };
+static u32 uart_used_ports = 0;
+static u32 pcidev_irq_route[4] = { 0, 0, 0, 0 };
+static u32 uart_console_port = 0;
+#else
+static u32 cs_flash_size[4] = {
+	CONFIG_TANGOX_XENV_DEF_CS0_SIZE,
+	CONFIG_TANGOX_XENV_DEF_CS1_SIZE,
+	CONFIG_TANGOX_XENV_DEF_CS2_SIZE,
+	CONFIG_TANGOX_XENV_DEF_CS3_SIZE
+};
+
+static u32 flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = {
+	{ CONFIG_TANGOX_XENV_DEF_CS0_SIZE },
+	{ CONFIG_TANGOX_XENV_DEF_CS1_SIZE },
+	{ CONFIG_TANGOX_XENV_DEF_CS2_SIZE },
+	{ CONFIG_TANGOX_XENV_DEF_CS3_SIZE },
+};
+
+static u32 enabled_devices =
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID1 << PCI1_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID2 << PCI2_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID3 << PCI3_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID4 << PCI4_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ENET 
+	(CONFIG_TANGOX_XENV_DEF_ENET << ETHERNET_SHIFT) |
+#else
+	0 | 
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_FIP 
+	(CONFIG_TANGOX_XENV_DEF_FIP << FIP_SHIFT) |
+#else 
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CM 
+	(CONFIG_TANGOX_XENV_DEF_I2CM << I2CM_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CS 
+	(CONFIG_TANGOX_XENV_DEF_I2CS << I2CS_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_BMIDE 
+	(CONFIG_TANGOX_XENV_DEF_BMIDE << BMIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ISAIDE 
+	(CONFIG_TANGOX_XENV_DEF_ISAIDE << ISAIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_IR 
+	(CONFIG_TANGOX_XENV_DEF_IR << IR_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCIHOST
+	(CONFIG_TANGOX_XENV_DEF_PCIHOST << PCIHOST_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_USB 
+	(CONFIG_TANGOX_XENV_DEF_USB << USB_SHIFT)
+#else
+	0
+#endif
+	;
+
+static u32 uart_baudrate = CONFIG_TANGOX_XENV_DEF_BAUDRATE;
+static u32 uart_baudrates[2] = { CONFIG_TANGOX_XENV_DEF_BAUDRATE, CONFIG_TANGOX_XENV_DEF_BAUDRATE };
+
+static u32 uart_used_ports = 
+#ifdef CONFIG_TANGOX_XENV_DEF_UART0
+		1 +
+#else
+		0 +
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_UART1
+		1;
+#else
+		0;
+#endif
+
+static u32 pcidev_irq_route[4] = { 
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+	CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+#else
+	0
+#endif
+};
+
+static u32 uart_console_port = CONFIG_TANGOX_XENV_DEF_CONSOLE_UART_PORT;
+#endif
+
+static u32 cs_flash_parts[4] = { 1, 1, 1, 1 };
+static u32 flash_parts_offset[4][XENV_MAX_FLASH_PARTITIONS] = { { 0 }, { 0 }, { 0 }, { 0 }, };
+static u32 scard_off_pin = 0;
+static u32 scard_cmd_pin = 0;
+static u32 scard_5v_pin = 0;
+#ifdef CONFIG_TANGO3
+static u32 scard1_off_pin = 0;
+static u32 scard1_cmd_pin = 0;
+static u32 scard1_5v_pin = 0;
+#endif
+static u32 isaide_timing_slot = 0;
+static u32 isaide_irq = 0;
+
+static u32 xenv_gbus_addr = 0;
+
+/* mac address to use if xenv is not readable  */
+static const u8 def_mac_address[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x01 };
+static u8 mac_address[6];
+#ifdef CONFIG_TANGO3
+static u8 mac_address1[6];
+#endif
+
+static char xenv_cmdline[CL_SIZE] = { 0 };
+
+static u32 gpioled = 24;
+static u32 hdmioutput = 0;
+
+#ifdef CONFIG_TANGOX_XENV_READ
+/*
+ * called for each entry found in xenv
+ */
+void __init xenv_val_cb(char *recordname, void *data, u32 datasize)
+{
+	char buf[64];
+	int i;
+
+#define CHECK_AND_STORE(_key, _reqlen, _var)				\
+	if (!strcmp(_key, recordname) && datasize <= _reqlen)	{	\
+		memcpy(&_var, data, _reqlen);				\
+		return;							\
+	}
+
+	CHECK_AND_STORE("sagetv.hdmi", 4, hdmioutput);
+	CHECK_AND_STORE("sagetv.led", 4, gpioled);
+
+	CHECK_AND_STORE(XENV_KEY_ENABLED_DEVICES, 4, enabled_devices);
+	CHECK_AND_STORE(XENV_KEY_DEF_BAUDRATE, 4, uart_baudrate);
+	CHECK_AND_STORE(XENV_KEY_UART_USED_PORTS, 4, uart_used_ports);
+	CHECK_AND_STORE(XENV_KEY_CONSOLE_UART_PORT, 4, uart_console_port);
+
+	if (uart_console_port == 0) /* for backward compatibility */
+		uart_used_ports |= 1;
+
+	for (i = 0; i < 2; i++) {
+		sprintf(buf, XENV_KEYS_UART_BAUDRATE, i);
+		CHECK_AND_STORE(buf, 4, uart_baudrates[i]);
+	}
+
+	if (uart_baudrate == 0)
+		uart_baudrate = 115200; /* default 115200 */
+	if (uart_baudrates[0] == 0)
+		uart_baudrates[0] = uart_baudrate;
+	if (uart_baudrates[1] == 0)
+		uart_baudrates[1] = uart_baudrate;
+
+	for (i = 1; i < 5; i++) {
+		sprintf(buf, XENV_KEYS_PCI_IRQ_ROUTE, i);
+		CHECK_AND_STORE(buf, 4, pcidev_irq_route[i - 1]);
+	}
+
+	CHECK_AND_STORE(XENV_KEY_SCARD_OFF, 4, scard_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_5V, 4, scard_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_CMD, 4, scard_cmd_pin);
+#ifdef CONFIG_TANGO3
+	CHECK_AND_STORE(XENV_KEY_SCARD1_OFF, 4, scard1_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_5V, 4, scard1_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_CMD, 4, scard1_cmd_pin);
+#endif
+
+	for (i = 0; i < 4; i++) {
+		int j;
+
+		sprintf(buf, XENV_KEYS_CS_SIZE, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_size[i]);
+
+		sprintf(buf, XENV_KEYS_CS_PARTS, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_parts[i]);
+
+		for (j = 1; j < XENV_MAX_FLASH_PARTITIONS; j++) {
+
+			sprintf(buf, XENV_KEYS_CS_PART_SIZE, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_size[i][j - 1]);
+
+			sprintf(buf, XENV_KEYS_CS_PART_OFFSET, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_offset[i][j - 1]);
+		}
+	}
+
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_IRQ_ROUTE, 4, isaide_irq);
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_TIMING_SLOT, 4, isaide_timing_slot);
+
+	if (!strcmp(recordname, XENV_KEY_LINUX_CMD) &&
+	    datasize <= sizeof (xenv_cmdline) - 1) {
+		memcpy(xenv_cmdline, data, datasize);
+		xenv_cmdline[datasize] = 0;
+	}
+}
+
+/*
+ * try to read config from XENV
+ */
+static int __init xenv_read_content(void)
+{
+	unsigned long xenv_addr;
+	int xenv_size;
+	uint32_t mac_lo, mac_hi;
+
+	/*
+	 * fetch XENV address
+	 */
+#ifdef CONFIG_TANGO3
+	unsigned int size, tmp;
+	xenv_gbus_addr = xenv_addr = gbus_readl(REG_BASE_cpu_block + LR_ZBOOTXENV_LOCATION);
+#else
+	xenv_gbus_addr = xenv_addr = gbus_readl(REG_BASE_cpu_block + LR_XENV_LOCATION);
+#endif
+	if (!xenv_addr)
+		return 1;
+
+	/*
+	 * got the xenv address in  gbus form, now convert it in remap
+	 * form so we can access it
+	 */
+	gbus_writel(REG_BASE_cpu_block + TMP_REMAPPED_REG, xenv_addr & TMP_REMAPPED_MASK);
+	iob();
+	xenv_addr = KSEG1ADDR(TMP_REMAPPED_BASE) + (xenv_addr & (TMP_REMAPPED_SIZE-1));
+
+	/*
+	 * check xenv sanity
+	 */
+	xenv_size = xenv_isvalid((u32 *)xenv_addr, MAX_XENV_SIZE);
+	if (xenv_size < 0) {
+		xenv_gbus_addr = xenv_addr = 0;
+		return 1;
+	}
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+	xenv_dump((u32 *)xenv_addr, xenv_size);
+#endif
+
+	/*
+	 * ok, we can start to load each wanted value
+	 */
+	xenv_foreach((u32 *)xenv_addr, xenv_size, xenv_val_cb);
+
+	/*
+	 * load remaining values
+	 */
+#ifdef CONFIG_TANGO3
+	/* Getting information from LR_XENV2_RW */
+	mac_hi = mac_lo = 0x0;
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int))) 
+			mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+
+	mac_hi = mac_lo = 0x0;
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int))) 
+			mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address1, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address1 + 2, &mac_lo, 4);
+#else
+	mac_hi = gbus_readl(REG_BASE_cpu_block + LR_ETH_MAC_HI);
+	mac_lo = gbus_readl(REG_BASE_cpu_block + LR_ETH_MAC_LO);
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+#endif
+
+	return 0;
+}
+#endif
+
+/*
+ * load default values and try to fetch xenv content
+ */
+int __init xenv_config(void)
+{
+#ifndef CONFIG_TANGOX_XENV_READ
+	/* will use default values */
+	return 0;
+#else
+	/*
+	 * try to load XENV content
+	 */
+	if (xenv_read_content() == 0) {
+		/* ok */
+		return 0;
+	}
+
+#ifndef CONFIG_TANGOX_XENV_READ_SAFE
+	/* fallback to failsafe values */
+	return 1;
+#else
+	/* stop boot process */
+	while (1)
+		cpu_relax();
+	/* not reached */
+	return 1;
+#endif
+
+#endif /* !CONFIG_TANGOX_XENV_READ */
+}
+
+
+/*
+ * helpers to access xenv configuration cached data
+ */
+
+/*
+ * enabled device query function
+ */
+#define BUILD_ENABLED(name, shift)					\
+int tangox_##name##_enabled(void)					\
+{									\
+	return (((enabled_devices >> shift) & 1) != 0) ? 1 : 0;	\
+} \
+EXPORT_SYMBOL(tangox_##name##_enabled);
+
+BUILD_ENABLED(isaide, ISAIDE_SHIFT)
+BUILD_ENABLED(bmide, BMIDE_SHIFT)
+BUILD_ENABLED(ir, IR_SHIFT)
+BUILD_ENABLED(fip, FIP_SHIFT)
+BUILD_ENABLED(usb, USB_SHIFT)
+BUILD_ENABLED(sdio, SDIO_SHIFT)
+BUILD_ENABLED(i2cm, I2CM_SHIFT)
+BUILD_ENABLED(i2cs, I2CS_SHIFT)
+BUILD_ENABLED(pci_host, PCIHOST_SHIFT)
+BUILD_ENABLED(sata, SATA_SHIFT)
+BUILD_ENABLED(gnet, GNET_SHIFT)
+
+int tangox_scard_enabled(int i)					
+{									
+#ifdef CONFIG_TANGO3
+	if (i != 0)
+		return((enabled_devices >> SCARD1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> SCARD_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_ethernet_enabled(int i)					
+{									
+#ifdef CONFIG_TANGO3
+	if (i != 0)
+		return((enabled_devices >> ETHERNET1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> ETHERNET_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_pcidev_enabled(int idsel)
+{
+	if (!tangox_pci_host_enabled())
+		return 0;
+
+	idsel--;
+	return (((enabled_devices >> (idsel + PCI1_SHIFT)) & 1) != 0) ? 1 : 0;
+}
+
+int tangox_pcidev_irq_map(int pci_idsel, int int_num)
+{
+	int route;
+	int irq;
+
+	route = pcidev_irq_route[pci_idsel - 1];
+
+	/* int_num: 0-3 = INTA-D */
+	irq = (int)((route >> (int_num * 8)) & 0x3);
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_irq_map(void)
+{
+	int irq = 0;
+
+	if (tangox_isaide_enabled() == 0)
+		return(-1);
+	irq = isaide_irq;
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_cs_select(void)
+{
+        int i;
+        unsigned long cs_config = (gbus_readl(REG_BASE_host_interface + PB_CS_config) >> 12) & 0xf;
+
+        if (tangox_isaide_enabled() == 0)
+                return(-1);
+
+        for (i = 0; i < 4; i++) {
+                if ((cs_config & 0x1) != 0)
+                        return(i);
+                else
+                        cs_config >>= 1;
+        }
+        return(-1);
+}
+
+int tangox_isaide_timing_slot(void)
+{
+        return(isaide_timing_slot & 0x7);
+}
+
+EXPORT_SYMBOL(tangox_isaide_irq_map);
+EXPORT_SYMBOL(tangox_isaide_cs_select);
+EXPORT_SYMBOL(tangox_isaide_timing_slot);
+EXPORT_SYMBOL(tangox_scard_enabled);
+EXPORT_SYMBOL(tangox_ethernet_enabled);
+
+int tangox_ethernet_getmac(int idx, unsigned char *mac)
+{
+#ifdef CONFIG_TANGO3
+	if (idx != 0) {
+		/* filter broadcast & multicast addresses */
+		if (mac_address1[0] == 0x01 || mac_address1[0] == 0xff)
+			memcpy(mac, def_mac_address, 6);
+		else
+			memcpy(mac, mac_address1, 6);
+		return 0;
+	}
+#endif
+	/* filter broadcast & multicast addresses */
+	if (mac_address[0] == 0x01 || mac_address[0] == 0xff)
+		memcpy(mac, def_mac_address, 6);
+	else
+		memcpy(mac, mac_address, 6);
+	return 0;
+}
+
+int tangox_uart_baudrate(int uart)
+{
+	return uart_baudrates[uart];
+}
+
+int tangox_uart_console_port(void)
+{
+	return uart_console_port;
+}
+
+int tangox_uart_enabled(int uart)
+{
+	return (((uart_used_ports >= 2) || (uart_console_port == uart)) ? 1 : 0);
+}
+
+int tangox_flash_get_info(int cs, unsigned int *size, unsigned int *part_count)
+{
+	if (cs > 3)
+		return 1;
+
+	*size = cs_flash_size[cs];
+	*part_count = 0;
+	if (cs_flash_size[cs] > 0)
+		*part_count = cs_flash_parts[cs];
+
+	return 0;
+}
+
+int tangox_flash_get_parts(int cs, unsigned int offset[], unsigned int size[])
+{
+	int i;
+
+	if (!cs_flash_size[cs])
+		return 1;
+
+	for (i = 0; i < cs_flash_parts[cs]; i++) {
+		offset[i] = flash_parts_offset[cs][i];
+		size[i] = flash_parts_size[cs][i];
+	}
+
+	return 0;
+}
+
+const char *tangox_xenv_cmdline(void)
+{
+	/* remove "" from command line */
+	if (xenv_cmdline[0] == '"') {
+		int len;
+
+		len = strlen(xenv_cmdline);
+		if (xenv_cmdline[len - 1] == '"')
+			xenv_cmdline[len - 1] = 0;
+		return xenv_cmdline + 1;
+	}
+	return xenv_cmdline;
+}
+
+int tangox_get_scard_info(int scard_no, int *pin_5v, int *pin_cmd, int *pin_off)
+{
+#ifdef CONFIG_TANGO3
+	if (scard_no != 0) {
+		*pin_5v = scard1_5v_pin;
+		*pin_off = scard1_off_pin;
+		*pin_cmd = scard1_cmd_pin;
+		return 0;
+	}
+#endif
+	*pin_5v = scard_5v_pin;
+	*pin_off = scard_off_pin;
+	*pin_cmd = scard_cmd_pin;
+	return 0;
+}
+
+/*
+ * show enabled devices according to xenv content
+ */
+void __init tangox_device_info(void)
+{
+	int i;
+
+	if (!xenv_gbus_addr) 
+		return;
+
+	printk(KERN_INFO "SMP863x/SMP865x Enabled Devices under Linux/"
+	       "XENV 0x%08x = 0x%08x\n", xenv_gbus_addr, enabled_devices);
+
+	printk(KERN_INFO);
+	if (tangox_isaide_enabled())
+		printk(" ISA/IDE");
+	if (tangox_bmide_enabled())
+		printk(" BM/IDE");
+	if (tangox_pci_host_enabled())
+		printk(" PCIHost");
+	if (tangox_ethernet_enabled(0))
+		printk(" Ethernet");
+#ifdef CONFIG_TANGO3
+	if (tangox_ethernet_enabled(1))
+		printk(" Ethernet1");
+#endif
+	if (tangox_ir_enabled())
+		printk(" IR");
+	if (tangox_fip_enabled())
+		printk(" FIP");
+	if (tangox_i2cm_enabled())
+		printk(" I2CM");
+	if (tangox_i2cs_enabled())
+		printk(" I2CS");
+	if (tangox_sdio_enabled())
+		printk(" SDIO");
+	if (tangox_usb_enabled())
+		printk(" USB");
+	for (i = 1; i <= 6; i++) {
+		if (tangox_pcidev_enabled(i))
+			printk(" PCIDev%d", i);
+	}
+	if (tangox_sata_enabled())
+		printk(" SATA");
+	if (tangox_scard_enabled(0))
+		printk(" SCARD");
+#ifdef CONFIG_TANGO3
+	if (tangox_scard_enabled(1))
+		printk(" SCARD1");
+#endif
+	if (tangox_gnet_enabled())
+		printk(" GNET");
+	printk("\n");
+}
+
+EXPORT_SYMBOL(tangox_ethernet_getmac);
+EXPORT_SYMBOL(tangox_get_scard_info);
+
+int tangox_get_hdmioutput(void)
+{
+    return hdmioutput;
+}
+
+int tangox_get_gpioled(void)
+{
+    return gpioled;
+}
+
+EXPORT_SYMBOL(tangox_get_hdmioutput);
+EXPORT_SYMBOL(tangox_get_gpioled);
+
diff -Naur linux-2.6.25.8/arch/mips/tangox/xenvkeys.h linux-2.6.25.8-clean/arch/mips/tangox/xenvkeys.h
--- linux-2.6.25.8/arch/mips/tangox/xenvkeys.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/arch/mips/tangox/xenvkeys.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,182 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* 
+ * The keys defined in XENV, more can be added.
+ */
+
+#ifndef __XENV_KEYS_H__
+#define __XENV_KEYS_H__
+
+#define XENV_KEY_BOARD_ID           "a.board_id"
+#define XENV_KEY_CHIP_REV           "a.chip_rev"
+
+#define XENV_KEY_PREMUX             "a.premux"
+#define XENV_KEY_AVCLK_MUX          "a.avclk_mux"
+#define XENV_KEY_HOSTCLK_MUX        "a.hostclk_mux"
+#define XENV_KEY_IRQ_RISE_EDGE_LO   "a.irq_rise_edge_lo"
+#define XENV_KEY_IRQ_FALL_EDGE_LO   "a.irq_fall_edge_lo"
+#define XENV_KEY_GPIO_IRQ_MAP       "a.gpio_irq_map"
+
+#define XENV_KEY_DEF_BAUDRATE       "a.baudrate"
+#define XENV_KEY_CONSOLE_UART_PORT  "a.uart_console_port"
+#define XENV_KEY_UART_USED_PORTS    "a.uart_used_ports"
+
+#define XENV_KEY_PB_CS_CONFIG       "a.pb_cs_config"
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_PB_CS_CONFIG1      "a.pb_cs_config1"
+#define XENV_KEY_PB_CS_CTRL         "a.pb_cs_ctrl"
+#endif
+#define XENV_KEY_DEF_TIMING         "a.pb_def_timing"
+#define XENV_KEY_PB_TIMING0         "a.pb_timing0"
+#define XENV_KEY_PB_USE_TIMING0     "a.pb_use_timing0"
+#define XENV_KEY_PB_TIMING1         "a.pb_timing1"
+#define XENV_KEY_PB_USE_TIMING1     "a.pb_use_timing1"
+#define XENV_KEY_PB_TIMING2         "a.pb_timing2"
+#define XENV_KEY_PB_USE_TIMING2     "a.pb_use_timing2"
+#define XENV_KEY_PB_TIMING3         "a.pb_timing3"
+#define XENV_KEY_PB_USE_TIMING3     "a.pb_use_timing3"
+#define XENV_KEY_PB_TIMING4         "a.pb_timing4"
+#define XENV_KEY_PB_USE_TIMING4     "a.pb_use_timing4"
+#define XENV_KEY_PB_TIMING5         "a.pb_timing5"
+#define XENV_KEY_PB_USE_TIMING5     "a.pb_use_timing5"
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+#define XENV_KEY_IRQ_RISE_EDGE_HI   "a.irq_rise_edge_hi"
+#define XENV_KEY_IRQ_FALL_EDGE_HI   "a.irq_fall_edge_hi"
+#endif
+
+#define XENV_KEY_ENABLED_DEVICES    "a.enable_devices"
+
+#define XENV_KEY_ETH_MAC            "a.eth_mac"
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_ETH1_MAC           "a.eth1_mac"
+#endif
+
+#define XENV_KEY_SCARD_OFF          "a.scard_off_pin"
+#define XENV_KEY_SCARD_5V           "a.scard_5v_pin"
+#define XENV_KEY_SCARD_CMD          "a.scard_cmd_pin"
+
+#ifdef CONFIG_TANGO3
+#define XENV_KEY_SCARD1_OFF         "a.scard1_off_pin"
+#define XENV_KEY_SCARD1_5V          "a.scard1_5v_pin"
+#define XENV_KEY_SCARD1_CMD         "a.scard1_cmd_pin"
+#endif
+
+#define XENV_KEY_ISAIDE_IRQ_ROUTE   "a.isaide_irq_route"
+#define XENV_KEY_ISAIDE_TIMING_SLOT "a.isaide_timing_slot"
+
+#define XENV_KEY_GPIO_DIR           "a.gpio_dir"
+#define XENV_KEY_GPIO_DATA          "a.gpio_data"
+
+#define XENV_KEY_LINUX_CMD          "a.linux_cmd"
+
+#define XENV_KEY_Z_BOOT_DEF         "z.default_boot"
+
+#define XENV_KEY_Z_PROD_TEST        "z.dt"
+#define XENV_KEY_Z_PROD_LOOPS       "z.prod_loops"
+#define XENV_KEY_Z_PROD_FTEST       "z.prod_ftest"
+#define XENV_KEY_Z_PROD_FSTART      "z.prod_fstart"
+#define XENV_KEY_Z_PROD_FEND        "z.prod_fend"
+#define XENV_KEY_Z_PROD_FSTEP       "z.prod_fstep"
+#define XENV_KEY_Z_PROD_RWIN        "z.prod_rwindow"
+#define XENV_KEY_Z_PROD_WWIN        "z.prod_wwindow"
+#define XENV_KEY_Z_PROD_CL          "z.prod_cl"
+#define XENV_KEY_Z_PROD_NBLOCKS     "z.prod_nblocks"
+
+#define XENV_KEY_YAMON_ENV          "y.env"
+#define XENV_KEY_YAMON_IPADDR       "y.ipaddr"
+#define XENV_KEY_YAMON_SUBNET       "y.subnetmask"
+#define XENV_KEY_YAMON_GATEWAY      "y.gateway"
+#define XENV_KEY_YAMON_START        "y.start"
+#define XENV_KEY_YAMON_STARTDELAY   "y.startdelay"
+
+#define XENV_KEYS_PCI_IRQ_ROUTE     "a.pcidev%d_irq_route"
+#define XENV_KEYS_CD_FREQUENCY      "a.cd%d_freq"
+#define XENV_KEYS_CD_DIV            "a.cd%d_div"
+#define XENV_KEYS_UART_GPIO_MODE    "a.uart%d_gpio_mode"
+#define XENV_KEYS_UART_GPIO_DIR     "a.uart%d_gpio_dir"
+#define XENV_KEYS_UART_GPIO_DATA    "a.uart%d_gpio_data"
+#define XENV_KEYS_UART_BAUDRATE     "a.uart%d_baudrate"
+#define XENV_KEYS_GPIO_PULSE        "a.gpio%d_pulse"
+
+#define XENV_KEYS_Z_BOOT_LOCATION   "z.boot%d"
+
+#define XENV_KEYS_CS_SIZE           "l.cs%d_size"
+#define XENV_KEYS_CS_PARTS          "l.cs%d_parts"
+
+#define XENV_KEYS_CS_PART_SIZE      "l.cs%d_part%d_size"
+#define XENV_KEYS_CS_PART_OFFSET    "l.cs%d_part%d_offset" 
+
+#ifndef CONFIG_SIGBLOCK_SUPPORT
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+#ifdef CONFIG_TANGO3
+#define SCARD1_SHIFT		19
+#define ETHERNET1_SHIFT		20
+#endif
+#endif
+
+/* Only used internally for LR_XENV2_RW and LR_XENV2_RO. Will be prefixed with z. when read off pfla */
+#ifdef CONFIG_TANGO3
+/* lrrw */
+#define XENV_LRRW_ETH_MACL	     "lrrw.maclo"
+#define XENV_LRRW_ETH_MACH	     "lrrw.machi"
+#define XENV_LRRW_ETH1_MACL	     "lrrw.mac1lo"
+#define XENV_LRRW_ETH1_MACH	     "lrrw.mac1hi"
+#define XENV_LRRW_KERNEL_END	     "lrrw.kend"
+
+#define XENV_LRRW_0_UZDATA_OFFSET    "lrrw.0.uzdata_offset"
+#define XENV_LRRW_0_ZDATA_OFFSET     "lrrw.0.zdata_offset"
+#define XENV_LRRW_0_DSP_OFFSET       "lrrw.0.dsp_offset"
+#define XENV_LRRW_0_XPU_OFFSET       "lrrw.0.xpu_offset"
+#define XENV_LRRW_1_UZDATA_OFFSET    "lrrw.1.uzdata_offset"
+#define XENV_LRRW_1_ZDATA_OFFSET     "lrrw.1.zdata_offset"
+#define XENV_LRRW_1_DSP_OFFSET       "lrrw.1.dsp_offset"
+#define XENV_LRRW_1_XPU_OFFSET       "lrrw.1.xpu_offset"
+
+#define XENV_LRRW_CHANNEL_INDEX_GA   "lrrw.channel_index_ga"
+#define XENV_LRRW_CHANNEL_INDEX_SIZE "lrrw.channel_index_size"
+#define XENV_LRRW_IOS_GA             "lrrw.ios_ga"
+#define XENV_LRRW_IOS_SIZE           "lrrw.ios_size"
+#define XENV_LRRW_XOS_PUBLIC_GA      "lrrw.xos_public_ga"
+#define XENV_LRRW_XOS_PUBLIC_SIZE    "lrrw.xos_public_size"
+#define XENV_LRRW_IHAPI_GA           "lrrw.ihapi_ga"
+#define XENV_LRRW_MM_VERSION         "lrrw.mm_version"
+
+/* For handshaking and setup purpose */
+#define XENV_HS_RUAMM0_OFFSET	     "a.ruamm0_offset"
+#define XENV_HS_RUAMM1_OFFSET	     "a.ruamm1_offset"
+#define XENV_HS_XOS_PUBLIC_SIZE      "a.xos_public_size"
+#define XENV_HS_IOS_SIZE	     "a.ios_size"
+
+/* lrro */
+#define XENV_LRRO_LOCKED	     "lrro.locked"
+
+#endif
+
+#endif
+
diff -Naur linux-2.6.25.8/crypto/sha1_generic.c linux-2.6.25.8-clean/crypto/sha1_generic.c
--- linux-2.6.25.8/crypto/sha1_generic.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/crypto/sha1_generic.c	2008-06-26 14:59:44.000000000 -0400
@@ -31,7 +31,11 @@
         u8 buffer[64];
 };
 
+#ifdef CONFIG_TANGOX
+void sha1_init(struct crypto_tfm *tfm)
+#else
 static void sha1_init(struct crypto_tfm *tfm)
+#endif
 {
 	struct sha1_ctx *sctx = crypto_tfm_ctx(tfm);
 	static const struct sha1_ctx initstate = {
@@ -43,8 +47,13 @@
 	*sctx = initstate;
 }
 
+#ifdef CONFIG_TANGOX
+void sha1_update(struct crypto_tfm *tfm, const u8 *data,
+			unsigned int len)
+#else
 static void sha1_update(struct crypto_tfm *tfm, const u8 *data,
 			unsigned int len)
+#endif
 {
 	struct sha1_ctx *sctx = crypto_tfm_ctx(tfm);
 	unsigned int partial, done;
@@ -77,8 +86,14 @@
 }
 
 
+
 /* Add padding and return the message digest. */
+
+#ifdef CONFIG_TANGOX
+void sha1_final(struct crypto_tfm *tfm, u8 *out)
+#else
 static void sha1_final(struct crypto_tfm *tfm, u8 *out)
+#endif
 {
 	struct sha1_ctx *sctx = crypto_tfm_ctx(tfm);
 	__be32 *dst = (__be32 *)out;
diff -Naur linux-2.6.25.8/crypto/sha256_generic.c linux-2.6.25.8-clean/crypto/sha256_generic.c
--- linux-2.6.25.8/crypto/sha256_generic.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/crypto/sha256_generic.c	2008-06-26 14:59:44.000000000 -0400
@@ -235,7 +235,11 @@
 	sctx->count[1] = 0;
 }
 
+#ifdef CONFIG_TANGOX
+void sha256_init(struct crypto_tfm *tfm)
+#else
 static void sha256_init(struct crypto_tfm *tfm)
+#endif
 {
 	struct sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 	sctx->state[0] = SHA256_H0;
@@ -249,8 +253,13 @@
 	sctx->count[0] = sctx->count[1] = 0;
 }
 
+#ifdef CONFIG_TANGOX
+void sha256_update(struct crypto_tfm *tfm, const u8 *data,
+			  unsigned int len)
+#else
 static void sha256_update(struct crypto_tfm *tfm, const u8 *data,
 			  unsigned int len)
+#endif
 {
 	struct sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 	unsigned int i, index, part_len;
@@ -282,7 +291,11 @@
 	memcpy(&sctx->buf[index], &data[i], len-i);
 }
 
+#ifdef CONFIG_TANGOX
+void sha256_final(struct crypto_tfm *tfm, u8 *out)
+#else
 static void sha256_final(struct crypto_tfm *tfm, u8 *out)
+#endif
 {
 	struct sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 	__be32 *dst = (__be32 *)out;
diff -Naur linux-2.6.25.8/drivers/char/Kconfig linux-2.6.25.8-clean/drivers/char/Kconfig
--- linux-2.6.25.8/drivers/char/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/char/Kconfig	2008-11-12 13:17:58.000000000 -0500
@@ -412,6 +412,35 @@
 
 source "drivers/serial/Kconfig"
 
+config TANGOX_IR
+       tristate "SMP86xx IR remote support" if TANGOX
+       default m
+       help
+         Support Infra-Red remote controller interface for SMP86xx.
+
+config TANGOX_FIP
+       tristate "SMP863x/SMP865x Front Panel support" if TANGOX
+       default m
+       help
+         Support Front Panel interface for SMP863x/SMP865x.
+
+choice
+       prompt "SMP863x/SMP865x reference platform"
+       depends on TANGOX_FIP
+       default TANGOX_FIP_REF1
+
+config TANGOX_FIP_REF1
+       bool "Ref1"
+       help
+         For reference platform 1.
+
+config TANGOX_FIP_REF2
+       bool "Ref2"
+       help
+         For reference platform 2.
+
+endchoice
+
 config UNIX98_PTYS
 	bool "Unix98 PTY support" if EMBEDDED
 	default y
diff -Naur linux-2.6.25.8/drivers/char/Makefile linux-2.6.25.8-clean/drivers/char/Makefile
--- linux-2.6.25.8/drivers/char/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/char/Makefile	2008-11-12 13:13:04.000000000 -0500
@@ -97,6 +97,8 @@
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_TANGOX_IR) += irkernel.o
+obj-$(CONFIG_TANGOX_FIP) += fipkernel.o
 
 obj-$(CONFIG_MWAVE)		+= mwave/
 obj-$(CONFIG_AGP)		+= agp/
diff -Naur linux-2.6.25.8/drivers/char/fipkernel.c linux-2.6.25.8-clean/drivers/char/fipkernel.c
--- linux-2.6.25.8/drivers/char/fipkernel.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/char/fipkernel.c	2008-11-12 13:21:40.000000000 -0500
@@ -0,0 +1,1312 @@
+/*****************************************
+ *  Copyright  2001-2007
+ *  Sigma Designs, Inc. All Rights Reserved
+ *  Proprietary and Confidential
+ *  Modified for KiSS Front Panel support
+ *  By Stefan Hallas Andersen
+ ******************************************/
+
+#ifdef __KERNEL__ 
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/fip.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/fip.h>
+#endif
+#else
+#include "version.h"
+#include "config.h"
+#include "io.h"
+#endif /* __KERNEL__ */
+
+extern int tangox_fip_enabled(void);
+
+/* chip specific register definitions */
+
+/* EM85XX */
+#if 0
+#define	FIP_BASE				0x00500D00
+#define	FIP_COMMAND				0x00
+#define	FIP_DISPLAY_DATA			0x04
+#define	FIP_LED_DATA				0x08
+#define	FIP_KEY_DATA1				0x0C
+#define	FIP_KEY_DATA2				0x10
+#define	FIP_SWITCH_DATA				0x14
+#define	FIP_CLK_DIV				0x20
+#define	FIP_TRISTATE_MODE			0x24
+
+#define FIP_TRISTATE_MODE_MASK			0x2
+#define FIP_DIVIDER				40
+#endif
+
+#ifndef CONFIG_TANGOX
+#error "Only TANGOX is supported/tested."
+#endif
+
+/* TANGOX */
+#define	FIP_BASE				(REG_BASE_system_block + 0x500)
+#define	FIP_COMMAND				0x40
+#define	FIP_DISPLAY_DATA			0x44
+#define	FIP_LED_DATA				0x48
+#define	FIP_KEY_DATA1				0x4c
+#define	FIP_KEY_DATA2				0x50
+#define	FIP_SWITCH_DATA				0x54
+#define FIP_CONFIG				0x58
+#define FIP_INT					0x5c
+
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define FIP_DIVIDER				27	/* default value */
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define FIP_DIVIDER				54	/* default value */
+#endif
+
+#define FIP_BUSY				0x200
+#define FIP_ENABLE				0x400
+
+/* FIP commands							*/
+#define	FIP_CMD_DISP_MODE_08DIGITS_20SEGMENTS		0x00
+#define	FIP_CMD_DISP_MODE_09DIGITS_19SEGMENTS		0x08
+#define	FIP_CMD_DISP_MODE_10DIGITS_18SEGMENTS		0x09
+#define	FIP_CMD_DISP_MODE_11DIGITS_17SEGMENTS		0x0a
+#define	FIP_CMD_DISP_MODE_12DIGITS_16SEGMENTS		0x0b
+#define	FIP_CMD_DISP_MODE_13DIGITS_15SEGMENTS		0x0c
+#define	FIP_CMD_DISP_MODE_14DIGITS_14SEGMENTS		0x0d
+#define	FIP_CMD_DISP_MODE_15DIGITS_13SEGMENTS		0x0e
+#define	FIP_CMD_DISP_MODE_16DIGITS_12SEGMENTS		0x0f
+#define	FIP_CMD_DATA_SET_RW_MODE_WRITE_DISPLAY		0x40
+#define	FIP_CMD_DATA_SET_RW_MODE_WRITE_LED_PORT		0x41
+#define	FIP_CMD_DATA_SET_RW_MODE_READ_KEYS		0x42
+#define	FIP_CMD_DATA_SET_RW_MODE_READ_SWITCHES		0x43
+#define	FIP_CMD_DATA_SET_ADR_MODE_INCREMENT_ADR		0x40
+#define	FIP_CMD_DATA_SET_ADR_MODE_FIXED_ADR		0x44
+#define	FIP_CMD_DATA_SET_OP_MODE_NORMAL_OPERATION	0x40
+#define	FIP_CMD_DATA_SET_OP_MODE_TEST_MODE		0x48
+#define	FIP_CMD_ADR_SETTING				0xC0
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_1_16		0x80
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_2_16		0x81
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_4_16		0x82
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_10_16		0x83
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_11_16		0x84
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_12_16		0x85
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_13_16		0x86
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_14_16		0x87
+#define	FIP_CMD_DISP_CTRL_TURN_DISPLAY_OFF_MASK		0x87
+#define	FIP_CMD_DISP_CTRL_TURN_DISPLAY_ON		0x88
+
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define FIP_DISPLAY_MODE	0xa
+#define MAX_FIP_RAM		23
+#define NUM_SYMBOLS		23
+#define NUM_CHARACTERS		72
+#define NUM_DIGITS		7
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define FIP_DISPLAY_MODE	0x0a
+#define MAX_FIP_RAM		0x2f
+#define NUM_SYMBOLS		206
+#define NUM_CHARACTERS		69
+#define NUM_X_CHARACTERS	12
+#define NUM_DIGITS		8
+#define NUM_X_DIGITS		4
+#endif
+
+#define L_OFF			-1	//means light is or should be off
+#define FIP_NO_CLEAR		0x0004
+
+#if defined(CONFIG_TANGOX_FIP_REF1)
+/*
+  14 SEGMENT LCD (EXTENDED CHARACTERS MAP)
+
+     a 
+   -----
+f |\j| /| b 
+  |i\|/k|
+  g-- --h
+e |n/|\l| c
+  |/m| \|
+   -----
+     d   
+*/
+#define DIGIT_L(b7,b6,c,l,m,n,e,d)	((b7 << 7) | (b6 << 6) | (c << 5) | (l << 4) | (m << 3) | (n << 2) | (e << 1) | d)
+#define DIGIT_H(g,h,i,j,k,a,b,f)	((g << 7) | (h << 6) | (i << 5) | (j << 4) | (k << 3) | (a << 2) | (b << 1) | f)
+
+/* sequence must match fipcharacters */
+static const char fipcharactersmap[NUM_CHARACTERS+1] = " +-/0123456789<>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\-abcdefghijklmnopqrstuvwxyz|_";
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define DIGIT_L(M,C,E,R,P,B,D,U)	((M << 7) | (C << 6) | (E << 5) | (R << 4) | (P << 3) | (B << 2) | (D << 1) | U)
+#define DIGIT_H(A,B,F,H,J,K,G,S)	((A << 7) | (B << 6) | (F << 5) | (H << 4) | (J << 3) | (K << 2) | (G << 1) | S)
+// Following definition is for Title/Track/Chaspter digits
+#define DIGIT_X(A,B,F,G,C,E,D,U)		((A << 7) | (B << 6) | (F << 5) | (G << 4) | (C << 3) | (E << 2) | (D << 1) | U)
+ 
+static const char fipcharactersmap[NUM_CHARACTERS+1] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
+static const char fipxcharactersmap[NUM_X_CHARACTERS+1] = "0123456789- ";
+#endif
+
+/* we use the inverted mask for clearing a digit without clearing other things */
+static const char fipcharactermask[2] = {
+#if defined(CONFIG_TANGOX_FIP_REF1)
+	DIGIT_L(1,1,0,0,0,0,0,0), 
+	DIGIT_H(0,0,0,0,0,0,0,0)
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+	DIGIT_L(0,0,0,0,0,0,0,0), 
+	DIGIT_H(0,0,0,0,0,0,0,0)
+#endif
+};
+
+#if defined(CONFIG_TANGOX_FIP_REF1)
+/* the format is lower byte, higher byte */
+static const char fipcharacters[NUM_CHARACTERS][2] = {
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(0,0,0,0,0,0,0,0)},	//
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(1,1,0,1,0,0,0,0)},	// +
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// -
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,1,0,0,0)},	// /
+
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,1,1,1)},	// 0
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,0,0,0,0)},	// 1
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,1,0)},	// 2
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,1,0)},	// 3
+	{DIGIT_L(0,0,1,0,0,0,0,0), DIGIT_H(1,1,0,0,0,0,1,1)},	// 4
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// 5
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// 6
+	{DIGIT_L(0,0,1,0,0,0,0,0), DIGIT_H(0,0,0,0,0,1,1,0)},	// 7
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// 8
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// 9
+
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,0,0,1,0,0,0)},	// <
+	{DIGIT_L(0,0,0,0,0,1,0,0), DIGIT_H(0,0,0,1,0,0,0,0)},	// >
+
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// A
+	{DIGIT_L(0,0,1,0,1,0,0,1), DIGIT_H(0,1,0,1,0,1,1,0)},	// B
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(0,0,0,0,0,1,0,1)},	// C
+	{DIGIT_L(0,0,1,0,1,0,0,1), DIGIT_H(0,0,0,1,0,1,1,0)},	// D
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// E
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,0,1)},	// F
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// G
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,0,1,1)},	// H
+	{DIGIT_L(0,0,0,0,1,0,0,1), DIGIT_H(0,0,0,1,0,1,0,0)},	// I
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(0,0,0,0,0,0,1,0)},	// J
+	{DIGIT_L(0,0,0,1,0,0,1,0), DIGIT_H(1,0,0,0,1,0,0,1)},	// K
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,0,1)},	// L
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(0,0,1,0,1,0,1,1)},	// M
+	{DIGIT_L(0,0,1,1,0,0,1,0), DIGIT_H(0,0,1,0,0,0,1,1)},	// N
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,1,1,1)},	// O
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// P
+	{DIGIT_L(0,0,1,1,0,0,1,1), DIGIT_H(0,0,0,0,0,1,1,1)},	// Q
+	{DIGIT_L(0,0,0,1,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// R
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// S
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,0,1,0,0)},	// T
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,1,1)},	// U
+	{DIGIT_L(0,0,1,1,0,0,0,0), DIGIT_H(0,0,1,0,0,0,1,0)},	// V
+	{DIGIT_L(0,0,1,1,0,1,1,0), DIGIT_H(0,0,0,0,0,0,1,1)},	// W
+	{DIGIT_L(0,0,0,1,0,1,0,0), DIGIT_H(0,0,1,0,1,0,0,0)},	// X
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,1,0,1,0,0,0)},	// Y
+	{DIGIT_L(0,0,0,0,0,1,0,1), DIGIT_H(0,0,0,0,1,1,0,0)},	// Z
+
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,1,0,0,0,0,0)},	// Slash
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// -
+
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// a
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,1)},	// b
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// c
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,1,0)},	// d
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// e
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,0,0,0,0,1,0,1)},	// f
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// g
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,0,0,1)},	// h
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,0,0,0,0)},	// i
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(0,0,0,0,0,0,0,0)},	// j
+	{DIGIT_L(0,0,0,1,1,0,0,0), DIGIT_H(0,1,0,1,0,0,0,0)},	// k
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,0,1)},	// l
+	{DIGIT_L(0,0,1,0,1,0,1,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// m
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// n
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// o
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// p
+	{DIGIT_L(0,0,1,0,0,0,0,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// q
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,0,0,0,0,0,0,0)},	// r
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// s
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,0,0,0,0,0,0,1)},	// t
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,0,0)},	// u
+	{DIGIT_L(0,0,1,1,0,0,0,0), DIGIT_H(0,0,0,0,0,0,0,0)},	// v
+	{DIGIT_L(0,0,1,1,0,1,1,0), DIGIT_H(0,0,0,0,0,0,0,0)},	// w
+	{DIGIT_L(0,0,0,1,1,0,0,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// x
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,1,0,0,0)},	// y
+	{DIGIT_L(0,0,0,0,1,0,0,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// z
+
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,0,0,0,0)},	// |
+	{DIGIT_L(0,0,0,0,0,0,0,1), DIGIT_H(0,0,0,0,0,0,0,0)}	// _
+};
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+/* the format is lower byte, higher byte */
+static const char fipcharacters[NUM_CHARACTERS][2] = {
+	{DIGIT_L(0,1,1,0,0,0,1,1), DIGIT_H(1,1,1,0,0,0,0,0)},	// 0
+	{DIGIT_L(0,0,0,0,1,0,0,1), DIGIT_H(0,0,0,0,1,0,0,1)},	// 1
+	{DIGIT_L(1,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,1,1)},	// 2
+	{DIGIT_L(1,1,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// 3
+	{DIGIT_L(1,1,0,0,0,0,0,1), DIGIT_H(0,1,1,0,0,0,1,1)},	// 4
+	{DIGIT_L(1,1,0,0,0,0,1,1), DIGIT_H(1,0,1,0,0,0,1,1)},	// 5
+	{DIGIT_L(1,1,1,0,0,0,1,1), DIGIT_H(1,0,1,0,0,0,1,1)},	// 6
+	{DIGIT_L(0,1,0,0,0,0,0,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// 7
+	{DIGIT_L(1,1,1,0,0,0,1,1), DIGIT_H(1,1,1,0,0,0,1,1)},	// 8
+	{DIGIT_L(1,1,0,0,0,0,0,1), DIGIT_H(1,1,1,0,0,0,1,1)},	// 9
+	{DIGIT_L(1,1,1,0,0,0,0,0), DIGIT_H(1,1,1,0,0,0,1,1)},	// A
+	{DIGIT_L(1,1,0,0,1,0,1,0), DIGIT_H(1,1,0,0,1,0,0,1)},	// B
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,0,1,0,0,0,0,0)},	// C
+	{DIGIT_L(0,1,0,0,1,0,1,0), DIGIT_H(1,1,0,0,1,0,0,1)},	// D
+	{DIGIT_L(1,0,1,0,0,0,1,0), DIGIT_H(1,0,1,0,0,0,1,1)},	// E
+	{DIGIT_L(0,0,1,0,0,0,0,0), DIGIT_H(1,0,1,0,0,0,1,1)},	// F
+	{DIGIT_L(1,1,1,0,0,0,1,0), DIGIT_H(1,0,1,0,0,0,0,0)},	// G
+	{DIGIT_L(1,1,1,0,0,0,0,0), DIGIT_H(0,1,1,0,0,0,1,1)},	// H
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,1,0,0,1)},	// I
+	{DIGIT_L(0,1,1,0,0,0,1,0), DIGIT_H(0,1,0,0,0,0,0,0)},	// J
+	{DIGIT_L(0,0,1,0,0,1,0,0), DIGIT_H(0,0,1,0,0,1,1,1)},	// K
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(0,0,1,0,0,0,0,0)},	// L
+	{DIGIT_L(0,1,1,0,0,0,0,0), DIGIT_H(0,1,1,1,0,1,0,1)},	// M
+	{DIGIT_L(0,1,1,0,0,1,0,0), DIGIT_H(0,1,1,1,0,0,0,1)},	// N
+	{DIGIT_L(0,1,1,0,0,0,1,0), DIGIT_H(1,1,1,0,0,0,0,0)},	// O
+	{DIGIT_L(1,0,1,0,0,0,0,0), DIGIT_H(1,1,1,0,0,0,1,1)},	// P
+	{DIGIT_L(0,1,1,0,0,1,1,0), DIGIT_H(1,1,1,0,0,0,0,0)},	// Q
+	{DIGIT_L(1,0,1,0,0,1,0,0), DIGIT_H(1,1,1,0,0,0,1,1)},	// R
+	{DIGIT_L(1,1,0,0,0,0,1,0), DIGIT_H(1,0,1,0,0,0,1,1)},	// S
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(1,0,0,0,1,0,0,1)},	// T
+	{DIGIT_L(0,1,1,0,0,0,1,0), DIGIT_H(0,1,1,0,0,0,0,0)},	// U
+	{DIGIT_L(0,0,1,1,0,0,0,0), DIGIT_H(0,0,1,0,0,1,0,1)},	// V
+	{DIGIT_L(0,1,1,1,0,1,0,0), DIGIT_H(0,1,1,0,0,0,0,1)},	// W
+	{DIGIT_L(0,0,0,1,0,1,0,0), DIGIT_H(0,0,0,1,0,1,0,0)},	// X
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,0,1,0,1)},	// Y
+	{DIGIT_L(0,0,0,1,0,0,1,0), DIGIT_H(1,0,0,0,0,1,0,1)},	// Z
+	{0,0},							// Space
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,1,0,0,1)},	// !
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(0,0,1,0,1,0,0,0)},	// "
+	{DIGIT_L(1,0,0,1,1,0,0,0), DIGIT_H(0,0,0,1,1,0,1,1)},	// #
+	{DIGIT_L(1,1,0,0,1,0,1,0), DIGIT_H(1,0,1,0,1,0,1,1)},	// $
+	{DIGIT_L(0,1,0,1,0,0,0,0), DIGIT_H(0,0,1,0,0,1,0,1)},	// %
+	{DIGIT_L(0,0,1,0,1,0,1,0), DIGIT_H(1,0,0,1,0,1,1,1)},	// &
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(0,0,0,0,0,1,0,0)},	// '
+	{DIGIT_L(0,0,0,0,0,1,0,0), DIGIT_H(0,0,0,0,0,1,0,0)}, 	// (
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,0,1,0,0,0,0)}, 	// )
+	{DIGIT_L(1,0,0,1,1,1,0,0), DIGIT_H(0,0,0,1,1,1,1,1)}, 	// *
+	{DIGIT_L(1,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,1,0,1,1)}, 	// +
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,0,0,0,0,0,0)}, 	// ,
+	{DIGIT_L(1,0,0,0,0,0,0,0), DIGIT_H(0,0,0,0,0,0,1,1)}, 	// -
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(0,0,0,0,0,0,0,1)}, 	// .
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,0,0,0,1,0,1)}, 	// /
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,0,0,0,1)}, 	// :
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,0,0,0,0,0,1)}, 	// ;
+	{DIGIT_L(0,0,0,0,0,1,0,0), DIGIT_H(0,0,0,0,0,1,0,1)}, 	// <
+	{DIGIT_L(1,0,0,0,0,0,1,0), DIGIT_H(0,0,0,0,0,0,1,1)}, 	// =
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,0,1,0,0,0,1)}, 	// >
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(1,0,1,0,0,1,0,1)}, 	// ?
+	{DIGIT_L(1,0,1,0,0,0,1,0), DIGIT_H(1,1,1,0,1,1,0,1)}, 	// @
+	{DIGIT_L(0,0,0,1,0,0,1,0), DIGIT_H(1,0,0,1,0,0,0,0)}, 	// [
+	{DIGIT_L(0,0,0,0,0,1,0,0), DIGIT_H(0,0,0,1,0,0,0,1)}, 	// / 
+	{DIGIT_L(0,1,0,0,0,0,1,0), DIGIT_H(1,1,0,0,0,0,0,0)}, 	// ]
+	{DIGIT_L(0,0,0,1,0,1,0,0), DIGIT_H(0,0,0,0,0,0,0,1)}, 	// ^
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(0,0,0,0,0,0,0,0)}, 	// _
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(0,0,0,1,0,0,0,0)}, 	// `
+	{DIGIT_L(0,0,0,1,0,0,1,0), DIGIT_H(1,0,0,1,0,0,1,0)}, 	// {
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,1,0,0,1)}, 	// |
+	{DIGIT_L(1,0,0,0,0,1,1,0), DIGIT_H(1,0,0,0,0,1,0,1)}, 	// }
+	{DIGIT_L(1,0,0,0,0,0,0,0), DIGIT_H(0,0,0,0,0,0,1,0)}	// ~
+};
+
+static const char fipxcharacters[NUM_X_CHARACTERS] = {
+	DIGIT_X(1,1,1,0,1,1,1,1),	// 0
+	DIGIT_X(0,1,0,0,1,0,0,1),	// 1
+	DIGIT_X(1,1,0,1,0,1,1,1),	// 2
+	DIGIT_X(1,1,0,1,1,0,1,1),	// 3
+	DIGIT_X(0,1,1,1,1,0,0,1),	// 4
+	DIGIT_X(1,0,1,1,1,0,1,1),	// 5
+	DIGIT_X(1,0,1,1,1,1,1,1),	// 6
+	DIGIT_X(1,1,0,0,1,0,0,1),	// 7
+	DIGIT_X(1,1,1,1,1,1,1,1),	// 8
+	DIGIT_X(1,1,1,1,1,0,1,1),	// 9
+	DIGIT_X(0,0,0,1,0,0,0,0),	// -
+	DIGIT_X(0,0,0,0,0,0,0,0)	// 
+};
+#endif
+
+#if defined(CONFIG_TANGOX_FIP_REF1)
+/* this array is used to display individual symbols
+   the format is [byte position][bit to turn on] - both zero based */
+static const char fipsymbols[NUM_SYMBOLS][2] = {
+	{0, 0}, 	/* DVD */
+	{0, 1}, 	/* PLAY */
+	{0, 2}, 	/* DTS */
+	{0, 3}, 	/* MP3 */
+	{0, 4}, 	/* DOLBY DIGITAL */
+	{0, 5}, 	/* MPEG4 */
+	{0, 6},		/* PAUSE */
+	{0, 7}, 	/* DVI */
+	{1, 0}, 	/* TWIRL1 */
+	{1, 1}, 	/* TWIRL2 */
+	{1, 2}, 	/* TWIRL3 */
+	{1, 3}, 	/* TWIRL4 */
+	{1, 4}, 	/* TWIRL5 */
+	{1, 5}, 	/* TWIRL6 */
+	{1, 6}, 	/* ALL */
+	{1, 7}, 	/* REPEAT */
+	{9, 6},		/* COLON_MIN_SEC */
+	{9, 7}, 	/* R1080 */
+	{12, 7}, 	/* R720 */
+	{15, 6}, 	/* COLON_HOUR_MIN */
+	{15, 7}, 	/* R480 */
+	{18, 7}, 	/* PAL */
+	{21, 7},	/* NTSC */
+};
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+/* this array is used to display individual symbols
+   the format is [byte position][bit to turn on] - both zero based */
+static const char fipsymbols[NUM_SYMBOLS][2] = {
+	{0, 1},		// DVD
+	{0, 2},		// VCD
+	{0, 4},		// MP3
+	{0, 8}, 	// CD
+	{29, 1}, 	// Title
+	{27, 1}		// Track
+};
+#endif
+
+/* The buffer size defines the size of circular buffer to keep the FIP keys */
+#define BUF_SIZE		2
+
+/* Wait period, to avoid bouncing or repeatation? */
+#define WAIT_PERIOD		100
+
+/* Default brightness level */
+#define BRIGHTNESS		0x7
+
+/* The number of key polling per second */
+#define POLL_PER_SECOND		10
+
+#ifdef __KERNEL__
+/* The major device number and name */
+#define FIP_DEV_MAJOR		0
+
+#define DRIVER_VERSION         "1.15"
+
+MODULE_DESCRIPTION("TANGOX front panel fip driver\n");
+MODULE_AUTHOR("TANGOX standalone team");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
+/* Wait queue, may be used if block mode is on */
+DECLARE_WAIT_QUEUE_HEAD(fip_wq);
+
+static int major_num = FIP_DEV_MAJOR;
+static int buffer_size = BUF_SIZE;
+static int wait_period = WAIT_PERIOD;
+static int brightness = BRIGHTNESS;
+static unsigned int poll_per_sec = POLL_PER_SECOND;
+module_param(major_num, int, 0);
+module_param(buffer_size, int, 0);
+module_param(wait_period, int, 0);
+module_param(brightness, int, 0);
+module_param(poll_per_sec, int, 0);
+
+/* Some prototypes */
+static int fip_open(struct inode *, struct file *);
+static int fip_release(struct inode *, struct file *);
+static int fip_read(struct file *, char *, size_t, loff_t *);
+static int fip_write(struct file *, const char *, size_t, loff_t *);
+static int fip_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+static unsigned int fip_poll(struct file *, struct poll_table_struct *);
+static int fip_irq = LOG2_CPU_FRONTPANEL_INT + IRQ_CONTROLLER_IRQ_BASE;
+static irqreturn_t fip_isr(int irq, void *dev_id);
+static void fip_poll_key(unsigned long devid);
+
+static struct timer_list fip_timer;
+#if 0
+static struct tq_struct immediate;
+#endif
+
+static void fip_write_text(const int position, const char *text, const int flags);
+static int fip_show_hms(int hour, int minute, int second);
+static void fip_display_symbol(const int symbol, const int on);
+static int fip_display_character(const int position, const char character);
+static void fip_display_raw(const int byte, const int bit, const int on); 
+static int is_fip_busy(void);
+static int is_fip_busy_nowait(void);
+static void fip_clear(void);
+
+#else /* For Bootloader */
+
+void fip_write_text(const int position, const char *text, const int flags);
+void fip_display_symbol(const int symbol, const int on);
+int fip_display_character(const int position, const char character);
+void fip_display_raw(const int byte, const int bit, const int on); 
+int is_fip_busy(void);
+void fip_clear(void);
+int fip_init(void);
+int fip_exit(void);
+
+/* Some external functions from bootloader core */
+void em86xx_usleep(int usec);
+int uart_printf(const char *fmt, ...);
+int strlen(const char *str);
+
+#endif /* __KERNEL__ */
+
+#define FIP_DEV_NAME		"fip"
+
+static void fip_write_reg(unsigned int offset, unsigned int val);
+static unsigned int fip_read_reg(unsigned int offset);
+
+#ifdef __KERNEL__ 
+#define CMDQ_SIZE	256
+
+/* Private data structure */
+struct cmd_request {
+	unsigned int cmd;
+	unsigned int data;
+};
+
+struct fip_private {
+	unsigned long *buffer;		/* Circular buffer */
+	unsigned p_idx;			/* Index of producer */
+	unsigned c_idx; 		/* Index of consumer */
+	unsigned ref_cnt;		/* Reference count */
+	spinlock_t lock;		/* Spin lock */
+	unsigned char b_mode;		/* Blocking mode or not */
+	unsigned long last_jiffies;	/* Timestamp for last reception */
+#ifdef ENABLE_WRITE_INTR
+	struct cmd_request cmds[CMDQ_SIZE];
+	unsigned cmd_pidx;
+	unsigned cmd_cidx;
+	unsigned cmdq_empty;
+#endif
+};
+
+static struct file_operations fip_fops = {
+	open: fip_open,
+	read: fip_read,
+	ioctl: fip_ioctl,
+	poll: fip_poll,
+	write: fip_write,
+	release: fip_release,
+	owner: THIS_MODULE,
+};
+
+static void fip_push_key(struct fip_private *priv, unsigned long key);
+#ifdef ENABLE_WRITE_INTR
+static void fip_issue_command(struct fip_private *priv);
+static void fip_queue_command(unsigned int cmd, unsigned int data);
+#endif
+
+/* Global data */
+static struct fip_private fip_priv;
+#endif /* __KERNEL__ */
+
+static char *fip_devname = FIP_DEV_NAME;
+static unsigned long fip_base = (unsigned long)FIP_BASE;
+static char fipram[MAX_FIP_RAM] = {0};
+
+#ifdef __KERNEL__
+
+static irqreturn_t fip_isr(int irq, void *dev_id)
+{
+	struct fip_private *priv = (struct fip_private *)dev_id;
+	unsigned long stat;
+	unsigned long key;
+
+	if (irq == fip_irq) {
+		//gbus_write_uint32(pGBus, REG_BASE_CPU + CPU_edge_rawstat,  IRQMASKOF(irq));
+		stat = (fip_read_reg(FIP_INT) & 0x3);
+		fip_write_reg(FIP_INT, stat); /* Clear the interrupt */
+
+		if (!is_fip_busy_nowait()) {
+			if (stat & 0x2) {
+				key = fip_read_reg(FIP_KEY_DATA1);
+				fip_push_key(priv, key);
+			}
+#ifdef ENABLE_WRITE_INTR
+			fip_issue_command(priv);
+#endif
+		}
+		return IRQ_HANDLED;
+	} else {
+		printk("Unknown IRQ %d\n", irq);
+		return IRQ_NONE;
+	}
+
+}
+
+static void fip_poll_key(unsigned long devid)
+{
+	struct fip_private *priv = (struct fip_private *)devid;
+
+	/* Sending command, and later ISR will pick up the interrupt and read
+           the key */
+	if (!is_fip_busy_nowait()) {
+		fip_write_reg(FIP_COMMAND, FIP_CMD_DATA_SET_RW_MODE_READ_KEYS);
+#ifdef ENABLE_WRITE_INTR
+		if (priv->cmdq_empty != 0) {
+			fip_issue_command(priv);
+		}
+#endif
+	}
+
+	if (priv->ref_cnt != 0) {
+		mod_timer(&fip_timer, jiffies + (HZ / poll_per_sec));
+#if 0
+		queue_task(&immediate, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
+#endif
+	}
+}
+
+/* Produce data */
+static void fip_push_key(struct fip_private *priv, unsigned long key)
+{
+	unsigned pidx;
+	static unsigned long oldkey = 0;
+
+	spin_lock(&priv->lock);
+
+	if ((key == 0) || (key == 0xffffffff)) {
+		oldkey = 0;
+		goto out;
+	} else if (time_after(priv->last_jiffies + wait_period, jiffies) 
+			&& (key == oldkey))
+		goto out;
+	else
+		priv->last_jiffies = jiffies;
+	
+	printk(KERN_DEBUG "%s: got data 0x%08lx\n", fip_devname, key);
+
+	pidx = priv->p_idx;	/* Save the old index before proceeding */
+
+	/* Save it to buffer */
+	if (((priv->p_idx + 1) % buffer_size) == priv->c_idx) {
+		/* Adjust consumer index since buffer is full */
+		/* Keep the latest one and drop the oldest one */
+		priv->c_idx = (priv->c_idx + 1) % buffer_size;
+
+		printk(KERN_WARNING "%s: buffer full\n", fip_devname);
+	}
+
+	priv->buffer[priv->p_idx] = oldkey = key;
+	priv->p_idx = (priv->p_idx + 1) % buffer_size;
+
+	/* Buffer was empty and block mode is on, wake up the reader */
+	if ((priv->b_mode != 0) && (priv->c_idx == pidx))
+		wake_up_interruptible(&fip_wq);
+
+out:
+	spin_unlock(&priv->lock);
+}
+
+/* Reading from driver's buffer, note that it can return read size
+   less than specified */
+static int fip_consume(void *dev_id, unsigned long *buf, int count)
+{
+	struct fip_private *priv = (struct fip_private *)dev_id;
+	int cnt = 0;
+	unsigned long flags;
+
+	/* If block mode is on, check the emptiness of buffer */
+	if (priv->b_mode != 0) {
+		/* Sleep when buffer is empty */
+		wait_event_interruptible(fip_wq, priv->c_idx != priv->p_idx);
+	}
+	if (signal_pending(current))
+		return(cnt);
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	/* Get the data out and adjust consumer index */
+	for (cnt = 0; (priv->c_idx != priv->p_idx) && (cnt < count); cnt++) {
+		*buf = priv->buffer[priv->c_idx];
+		priv->c_idx = (priv->c_idx + 1) % buffer_size;
+		buf++;
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return(cnt);
+}
+
+/* Poll function */
+static unsigned int fip_poll(struct file *fptr, struct poll_table_struct *ptable){
+	struct fip_private *priv = (struct fip_private *)fptr->private_data;
+	unsigned int mask = 0;
+
+	poll_wait(fptr, &fip_wq, ptable);
+	if (priv->c_idx != priv->p_idx)
+		mask |= (POLLIN | POLLRDNORM);
+	return(mask);
+}
+
+#ifdef ENABLE_WRITE_INTR
+static void fip_issue_command(struct fip_private *priv)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (priv->cmd_pidx == priv->cmd_cidx) {
+		priv->cmdq_empty = 1;
+		goto out;
+	} else if (!is_fip_busy_nowait()) {
+		priv->cmdq_empty = 0;
+		fip_wait_ready();
+		fip_write_reg(FIP_DISPLAY_DATA, priv->cmds[priv->cmd_cidx].data);
+		fip_wait_ready();
+		fip_write_reg(FIP_COMMAND, priv->cmds[priv->cmd_cidx].cmd);
+		fip_wait_ready();
+		priv->cmd_cidx = ((priv->cmd_cidx + 1) % CMDQ_SIZE);
+		if (priv->cmd_pidx == priv->cmd_cidx) 
+			priv->cmdq_empty = 1;
+	}
+out:
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+#endif
+
+static int fip_open(struct inode *inode_ptr, struct file *fptr)
+{
+	/* This device is exclusive, that is, only one process can use it */
+	if (fip_priv.ref_cnt != 0) {
+		printk(KERN_WARNING "%s: exclusive access only\n", fip_devname);
+		return(-EIO);
+	} 
+
+	/* Set the block mode and increase reference count */
+	fip_priv.ref_cnt++;
+	fip_priv.b_mode = ((fptr->f_flags & O_NONBLOCK) ? 0 : 1);
+	fip_priv.last_jiffies = jiffies;
+
+	/* Flush the buffer */
+	fip_priv.p_idx = fip_priv.c_idx = 0;
+
+	fptr->f_op = &fip_fops;
+	fptr->private_data = (void *)&fip_priv;
+
+	fip_timer.function = fip_poll_key;
+	fip_timer.data = (unsigned long)&fip_priv;
+	fip_timer.expires = jiffies + (HZ / poll_per_sec);
+	add_timer(&fip_timer);
+
+#if 0
+	immediate.sync = 0;
+	immediate.data = (void *)&fip_priv;
+	immediate.routine = fip_poll_key;
+	queue_task(&immediate, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+#endif
+
+	fip_clear();
+	return(0);
+}
+
+static int fip_release(struct inode *inode_ptr, struct file *fptr) 
+{
+	unsigned long start = 0;
+
+	/* Adjust reference count */
+	fip_priv.ref_cnt--;
+
+	/* Wait for timer expiration */
+	for (start = jiffies; time_after(start + 2 * (HZ / poll_per_sec), jiffies););
+	del_timer_sync(&fip_timer);
+	return(0);
+}
+
+static int fip_read(struct file *fptr, char *bufptr, size_t size, loff_t *fp)
+{
+	unsigned long buf[buffer_size];
+	int count = 0;
+
+	/* Check the alignment */
+	if (size % sizeof(unsigned long)) {
+		printk(KERN_WARNING "%s: read size not aligned to %d\n",
+			fip_devname, sizeof(unsigned long));
+		return(-EIO);
+	}
+
+	count = fip_consume(fptr->private_data, &buf[0], 
+			size / sizeof(unsigned long)) * sizeof(unsigned long);
+
+	/* Get the data to user */
+	if (count && copy_to_user(bufptr, (char *)&buf[0], count)) 
+		return(-EFAULT);
+
+	return(count);
+}
+
+static int fip_write(struct file *fptr, const char *bufptr, size_t size, loff_t *fp)
+{
+	fip_wait_ready();
+	fip_write_text(0, bufptr, FIP_CENTER); 
+	fip_wait_ready();
+	return(size);
+}
+
+static int fip_ioctl(struct inode *inode, struct file *fptr, unsigned int cmd, unsigned long arg)
+{
+	int on = 0;
+	int symbol;
+	int i, j, k;
+
+	switch(cmd) {
+		case FIP_IOCSHOWSYMBOL:
+			on = ((arg & 0x80000000)) == 0 ? 0 : 1;
+			symbol = (int)(arg & 0xff);
+			fip_display_symbol(symbol, on);
+			break;
+		case FIP_IOCSHOWHMS:
+			k = (int)(arg & 0xff);
+			j = (int)((arg >> 8) & 0xff);
+			i = (int)((arg >> 16) & 0xff);
+			fip_show_hms(i, j, k);
+			break;
+		case FIP_IOCDISPCHAR:
+			k = (int)(arg & 0xff);
+			j = (int)((arg >> 8) & 0xff);
+			fip_display_character(j, k);
+			break;
+		case FIP_IOCDISPRAW:
+			on = ((arg & 0x80000000)) == 0 ? 0 : 1;
+			k = (int)(arg & 0xff);
+			j = (int)((arg >> 8) & 0xff);
+			fip_display_raw(j, k, on);
+			break;
+		case FIP_IOCDISPTEXT:
+			printk("%s: ioctl FIP_IOCDISPTEXT not implemented.\n", fip_devname);
+			return(-EIO);
+		case FIP_IOCCLEAR:
+			fip_clear();
+			break;
+		case FIP_IOCGETFPTYPE:
+			{
+				unsigned long *ptr = (unsigned long *)arg;
+				unsigned long type = 0;
+#if defined(CONFIG_TANGOX_FIP_REF1)
+				type = 1;
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+				type = 2;
+#else
+				return(-EIO);
+#endif
+				if (copy_to_user(ptr, (char *)&type, sizeof(unsigned long))) 
+					return(-EFAULT);
+			}
+			break;
+		default:
+			return(-EIO);
+	}
+	return(0);
+}
+
+#endif /* __KERNEL__ */
+
+/* Micro-second sleep */
+static void fip_usleep(unsigned usec)
+{
+#ifdef __KERNEL__
+	udelay(usec);
+#else
+	em86xx_usleep(usec);
+#endif /* __KERNEL__ */
+}
+
+static unsigned int fip_read_reg(unsigned int offset)
+{
+//	unsigned int val = *((volatile unsigned int *)(fip_base + offset));
+	unsigned int val = gbus_read_uint32(pGBus, fip_base + offset);
+	return(val);
+}
+
+static void fip_write_reg(unsigned int offset, unsigned int val)
+{
+	fip_wait_ready();
+//	*((volatile unsigned int *)(fip_base + offset)) = val;
+	gbus_write_uint32(pGBus, fip_base + offset, val);
+	fip_wait_ready();
+}
+
+#ifdef __KERNEL__
+#ifdef ENABLE_WRITE_INTR
+/* To queue the write request */
+static void fip_queue_command(unsigned int cmd, unsigned int data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&fip_priv.lock, flags);
+	if (((fip_priv.cmd_pidx + 1) % CMDQ_SIZE) == fip_priv.cmd_cidx) {
+		printk(KERN_ERR "Command queue full.\n");
+		fip_issue_command(&fip_priv);
+	} else {
+		fip_priv.cmds[fip_priv.cmd_pidx].cmd = cmd;
+		fip_priv.cmds[fip_priv.cmd_pidx].data = data;
+		fip_priv.cmd_pidx = ((fip_priv.cmd_pidx + 1) % CMDQ_SIZE);
+	}
+	spin_unlock_irqrestore(&fip_priv.lock, flags);
+}
+#endif
+#endif
+
+#ifdef __KERNEL__
+static int is_fip_busy_nowait(void)
+{
+	return((fip_read_reg(FIP_CONFIG) & FIP_BUSY) != 0);
+}
+#endif
+
+#ifdef __KERNEL__
+static
+#endif /* __KERNEL__ */
+int is_fip_busy(void)
+{
+#if defined(CONFIG_TANGOX_FIP_REF1)
+	fip_usleep(10);
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+	fip_usleep(20);
+#endif
+	return((fip_read_reg(FIP_CONFIG) & FIP_BUSY) != 0);
+}
+
+#ifdef __KERNEL__
+static
+#endif /* __KERNEL__ */
+void fip_wait_ready(void)
+{
+	while (is_fip_busy());
+#if defined(CONFIG_TANGOX_FIP_REF2)
+	fip_usleep(20);
+#endif
+}
+
+static void fip_user_display(int adr, int data)
+{
+#ifdef __KERNEL__
+#ifdef ENABLE_WRITE_INTR
+	fip_wait_ready();
+	fip_queue_command(FIP_CMD_ADR_SETTING | (adr), data);
+#else
+	fip_wait_ready();
+	fip_write_reg(FIP_DISPLAY_DATA, data);
+	fip_write_reg(FIP_COMMAND, FIP_CMD_ADR_SETTING | (adr));
+#endif
+#else
+	fip_wait_ready();
+	fip_write_reg(FIP_DISPLAY_DATA, data);
+	fip_wait_ready();
+	fip_write_reg(FIP_COMMAND, FIP_CMD_ADR_SETTING | (adr));
+	fip_wait_ready();
+#endif
+}
+
+#ifdef __KERNEL__
+static
+#endif /* __KERNEL__ */
+int fip_display_character(const int position, const char character) 
+{
+	int i, byte1, byte2;
+	unsigned char current_contents0, current_contents1;
+#if defined(CONFIG_TANGOX_FIP_REF1)
+	const int min_pos = 1;
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+	const int min_pos = 0;
+#endif
+	
+	if ((position < min_pos) || (position > NUM_DIGITS)) {
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "%s: position %d not available/supported.\n",
+				fip_devname, position);
+#else
+		uart_printf("%s: position %d not available/supported.\n",
+				fip_devname, position);
+#endif /* __KERNEL__ */
+		return(0);
+	}
+
+	for (i = 0; i < NUM_CHARACTERS; i++) {
+		if (character == fipcharactersmap[i]) {
+			byte1 = 24 - (3 * position);
+			byte2 = 25 - (3 * position);
+
+			current_contents0 = fipram[byte1];
+			current_contents1 = fipram[byte2];
+
+			/* clear */	
+			fipram[byte1] &= fipcharactermask[0];
+			fipram[byte2] &= fipcharactermask[1];
+			
+			/* set new bits */
+			fipram[byte1] |= fipcharacters[i][0];
+			fipram[byte2] |= fipcharacters[i][1];
+
+			/* display if necessary */
+			if (current_contents0 != fipram[byte1])
+				fip_user_display(byte1, fipram[byte1]);
+			if (current_contents1 != fipram[byte2])
+				fip_user_display(byte2, fipram[byte2]);
+			return(1);
+		}
+	}
+#ifdef __KERNEL__
+	printk(KERN_DEBUG "%s: character '%c' not available/supported.\n", fip_devname, character);
+#else
+	uart_printf("%s: character '%c' not available/supported.\n", fip_devname, character);
+#endif /* __KERNEL__ */
+	return(0);
+}
+
+#ifdef __KERNEL__
+static
+#endif /* __KERNEL__ */
+void fip_clear(void)
+{
+	register int i;
+
+	for (i = 0; i < MAX_FIP_RAM; i++) {
+		fipram[i] = 0;
+		fip_user_display(i, fipram[i]);
+	}
+}
+
+#ifdef __KERNEL__
+static
+#endif /* __KERNEL__ */
+void fip_display_raw(const int byte, const int bit, const int on) 
+{
+	unsigned char current_contents;
+	current_contents = fipram[byte];
+	if (on != 0)
+		fipram[byte] |= (1 << bit);
+	else
+		fipram[byte] &= ~(1 << bit);
+
+	/* display only if necessary */
+	if (current_contents != fipram[byte])
+		fip_user_display(byte, fipram[byte]);
+}
+
+#ifdef __KERNEL__
+static
+#endif /* __KERNEL__ */
+void fip_display_symbol(const int symbol, const int on) 
+{
+	if ((symbol < 0) || (symbol >= NUM_SYMBOLS)) {
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "%s: symbol #%d not available/supported.\n", fip_devname, symbol);
+#else
+		uart_printf("%s: symbol #%d not available/supported.\n", fip_devname, symbol);
+#endif /* __KERNEL__ */
+		return;
+	}
+
+#if defined(CONFIG_TANGOX_FIP_REF1)
+	fip_display_raw(fipsymbols[symbol][0], fipsymbols[symbol][1], on);
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+	//0-99 displays tra/chap number field (0-99)
+	//100-199 displays title number field (0-99)
+	//200 clears all in this area
+	//201-206 displays symbols without effecting other fields
+	if (symbol > 200) {
+		 //fip_display_raw(fipsymbols[symbol-200][0], fipsymbols[symbol-200][1], on);
+		 switch(symbol) {
+		 	case 201:
+				fip_user_display(0, 1);
+				break;
+			case 202:
+				fip_user_display(0, 2);
+				break;
+			case 203:
+				fip_user_display(0, 4);
+				break;
+			case 204:
+				fip_user_display(0, 8);
+				break;
+			case 205:
+				fip_user_display(27, 1);
+				break;
+			case 206:
+				fip_user_display(29, 1);
+				break;
+		 }
+	} else if (symbol == 200) { 
+		fipram[27] = fipxcharacters[11];
+		fipram[28] = fipxcharacters[11];
+		fipram[30] = fipxcharacters[11];
+		fipram[31] = fipxcharacters[11];
+		fip_user_display(27, fipram[27]);
+		fip_user_display(28, fipram[28]);	
+		fip_user_display(30, fipram[30]);
+		fip_user_display(31, fipram[31]);
+			
+	} else if (symbol >= 100) { 
+		fipram[27] = fipxcharacters[(symbol-100)/10];
+		fipram[28] = fipxcharacters[(symbol-100)%10];
+		fip_user_display(27, fipram[27]);
+		fip_user_display(28, fipram[28]);
+	} else if (symbol >= 0) {
+		fipram[30] = fipxcharacters[symbol/10];
+		fipram[31] = fipxcharacters[symbol%10];	
+		fip_user_display(30, fipram[30]);
+		fip_user_display(31, fipram[31]);	
+	}
+#endif
+}
+
+#ifdef __KERNEL__
+static
+#endif /* __KERNEL__ */
+void fip_write_text(const int position, const char *text, const int flags) 
+{
+	int x, i, j;
+	int textLen = strlen (text);
+
+#if defined(CONFIG_TANGOX_FIP_REF1)
+	if (flags & FIP_CENTER)
+		x = (position > 0) ? position - textLen / 2 : (NUM_DIGITS - textLen) / 2 + 1;
+	else if (flags & FIP_RIGHT)
+		x = (position > 0) ? position - textLen : NUM_DIGITS - textLen + 1;
+	else 
+		x = (position > 0) ? position : 1;
+	if (x < 1)
+		x = 1;
+
+	if ((flags & FIP_NO_CLEAR) == 0) {
+		/* clear colons */
+		fip_display_symbol(COLON_HOUR_MIN_FIP_ON, 0);
+		fip_display_symbol(COLON_MIN_SEC_FIP_ON, 0);
+	}
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+	if (flags & FIP_CENTER)
+		x = (position >= 0) ? position - textLen / 2 : (NUM_DIGITS - textLen) / 2 + 1;
+	else if (flags & FIP_RIGHT)
+		x = (position >= 0) ? position - textLen : NUM_DIGITS - textLen + 1;
+	else 
+		x = (position >= 0) ? position : 1;
+	if (x < 1)
+		x = 1;
+#endif
+
+	/* show/write text */
+	j = 0;
+	for (i = 1; i <= NUM_DIGITS; i++) {
+		if ((i < x) || (i >= (x+textLen)))
+			fip_display_character(i, ' ');
+		else if (!fip_display_character(i, text[j++])) {
+#ifdef __KERNEL__
+			printk(KERN_DEBUG "%s: cannot show text '%s'.\n", fip_devname, text);
+#else
+			uart_printf("%s: cannot show text '%s'.\n", fip_devname, text);
+#endif /* __KERNEL__ */
+			break;
+		}
+	}
+}
+
+#ifdef __KERNEL__ 
+static 
+#endif /* __KERNEL__ */
+int fip_show_hms(int hour, int minute, int second)
+{
+	if (hour < L_OFF || minute < L_OFF || second < L_OFF ||
+		hour > 99 || minute > 59 || second > 59) {
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "%s: parameters passed not in valid range\n", fip_devname);
+#else
+		uart_printf("%s: parameters passed not in valid range\n", fip_devname);
+#endif
+		return(1);
+	}
+ 
+#if defined(CONFIG_TANGOX_FIP_REF1)
+	// hour
+	fip_display_character(1, ' ');
+	fip_display_character(2, (hour==L_OFF) ? ' ' : hour/10 + '0');
+	fip_display_character(3, (hour==L_OFF) ? ' ' : hour%10 + '0');
+
+	// minute 
+	fip_display_character(4, (minute==L_OFF) ? ' ' : minute/10 + '0');
+	fip_display_character(5, (minute==L_OFF) ? ' ' : minute%10 + '0');
+
+	// second
+	fip_display_character(6, (second==L_OFF) ? ' ' : second/10 + '0');
+	fip_display_character(7, (second==L_OFF) ? ' ' : second%10 + '0');
+
+	// show colons if needed
+	fip_display_symbol(COLON_HOUR_MIN_FIP_ON, (hour == L_OFF) ? 0 : 1);
+	fip_display_symbol(COLON_MIN_SEC_FIP_ON, ((hour == L_OFF) && (minute == L_OFF)) ? 0 : 1);
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+	// hour
+	fip_display_character(0, (hour==L_OFF) ? ' ' : hour/10 + '0');
+	fip_display_character(1, (hour==L_OFF) ? ' ' : hour%10 + '0');
+
+	// minute 
+	fip_display_character(2, (minute==L_OFF) ? ' ' : minute/10 + '0');
+	fip_display_character(3, (minute==L_OFF) ? ' ' : minute%10 + '0');
+
+	// second
+	fip_display_character(4, (second==L_OFF) ? ' ' : second/10 + '0');
+	fip_display_character(5, (second==L_OFF) ? ' ' : second%10 + '0');
+	fip_display_character(6, ' ');
+	fip_display_character(7, ' ');
+#endif
+	return(0);
+}
+
+#ifdef __KERNEL__ 
+static 
+#endif /* __KERNEL__ */
+int fip_init(void)
+{
+	static int initflag = 0;
+
+	if (initflag != 0)
+		return(0);
+
+#ifdef __KERNEL__
+	/* Disable FIP and interrupt first */
+	fip_wait_ready();
+	fip_write_reg(FIP_CONFIG, 0);
+	fip_wait_ready();
+
+#ifdef ENABLE_WRITE_INTR
+	/* Enable FIP and interrupts (read: 0x20000, write: 0x10000) */
+	fip_write_reg(FIP_CONFIG, (FIP_DIVIDER | FIP_ENABLE | 0x30000));
+#else
+	/* Enable FIP and interrupts (read: 0x20000) */
+	fip_write_reg(FIP_CONFIG, (FIP_DIVIDER | FIP_ENABLE | 0x20000));
+#endif
+#else
+	fip_wait_ready();
+	/* Enable FIP wthout enabling interrupt */
+	fip_write_reg(FIP_CONFIG, (FIP_DIVIDER | FIP_ENABLE));
+#endif /* __KERNEL__ */
+	fip_wait_ready();
+
+	/* Clear exisiting IRQ, if any */
+	fip_write_reg(FIP_INT, 0x3);
+	fip_wait_ready();
+
+	/* select display mode */
+	fip_write_reg(FIP_COMMAND, FIP_DISPLAY_MODE);
+	fip_wait_ready();
+
+	/* select brightness of display and turn it on */
+	fip_write_reg(FIP_COMMAND, FIP_CMD_DISP_CTRL_TURN_DISPLAY_ON | brightness);
+	fip_wait_ready();
+
+	/* select write to display and fixed addressing */
+	fip_write_reg(FIP_COMMAND, FIP_CMD_DATA_SET_ADR_MODE_FIXED_ADR);
+	fip_wait_ready();
+
+	fip_clear();
+	fip_wait_ready();
+	initflag = 1;
+	return(0);
+}
+
+#ifdef __KERNEL__ 
+static 
+#endif /* __KERNEL__ */
+int fip_exit(void)
+{
+	fip_clear();
+
+	/* Disable FIP and interrupt */
+	fip_write_reg(FIP_CONFIG, 0);
+	fip_wait_ready();
+	return(0);
+}
+
+#ifndef __KERNEL__ 
+unsigned long fip_readkey(void)
+{
+	unsigned long key = 0L;
+
+	fip_wait_ready();
+	fip_write_reg(FIP_COMMAND, FIP_CMD_DATA_SET_RW_MODE_READ_KEYS);
+	key = fip_read_reg(FIP_KEY_DATA1); 
+	return(key);
+}
+#endif /* __KERNEL__ */
+
+#ifdef __KERNEL__
+int __init fip_init_module(void)
+{
+	int status = 0;
+
+	if (tangox_fip_enabled() == 0)
+		return(0);
+
+	/* Initialize private data structure */
+	memset(&fip_priv, 0, sizeof(struct fip_private)); 
+#ifdef ENABLE_WRITE_INTR
+	fip_priv.cmdq_empty = 1;
+#endif
+	spin_lock_init(&fip_priv.lock);
+
+	if (buffer_size < 1) {
+		printk(KERN_ERR "%s: buffer size (%d) error\n", fip_devname,
+			buffer_size); 
+		return(-EIO);
+	} 
+	if ((fip_priv.buffer = kmalloc(buffer_size * sizeof(unsigned long), GFP_KERNEL)) == NULL) {
+		printk(KERN_ERR "%s: out of memory for buffer\n", fip_devname); 
+		return(-ENOMEM);
+	}
+
+	/* Register device, and may be allocating major# */
+	status = register_chrdev(major_num, fip_devname, &fip_fops);
+	if (status < 0) {
+		printk(KERN_ERR "%s: cannot get major number\n", fip_devname); 
+		if (fip_priv.buffer != NULL)
+			kfree(fip_priv.buffer);
+		return(status);
+	} else if (major_num == 0)
+		major_num = status;	/* Dynamic major# allocation */
+
+	/* Hook up ISR */
+	if (request_irq(fip_irq, fip_isr, IRQF_SHARED, fip_devname, &fip_priv) != 0) {
+		printk(KERN_ERR "%s: cannot register IRQ (%d)\n", fip_devname,
+			fip_irq);
+		unregister_chrdev(major_num, fip_devname);	
+		if (fip_priv.buffer != NULL)
+			kfree(fip_priv.buffer);
+		return(-EIO);
+	}
+
+	fip_init();
+	init_timer(&fip_timer);
+
+	printk("SMP863x %s (%d:0): driver loaded (buffer_size = %d)\n", 
+		fip_devname, major_num, buffer_size);
+	return(0);
+}
+
+void __exit fip_cleanup_module(void)
+{
+	if (tangox_fip_enabled() == 0)
+		return;
+
+	unregister_chrdev(major_num, fip_devname);
+	free_irq(fip_irq, &fip_priv);
+
+	if (fip_priv.buffer != NULL)
+		kfree(fip_priv.buffer);
+
+	fip_exit();
+
+	printk(KERN_DEBUG "%s: driver unloaded\n", fip_devname);
+}
+
+module_init(fip_init_module);
+module_exit(fip_cleanup_module);
+
+#endif /* __KERNEL__ */
+
diff -Naur linux-2.6.25.8/drivers/char/irkernel.c linux-2.6.25.8-clean/drivers/char/irkernel.c
--- linux-2.6.25.8/drivers/char/irkernel.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/char/irkernel.c	2008-12-12 21:34:49.000000000 -0500
@@ -0,0 +1,768 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/poll.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/ir.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/ir.h>
+#endif
+
+/* For all SMP86xx, it's always there */
+#if defined(CONFIG_TANGO2_SMP863X) || defined(CONFIG_TANGO3_SMP865X)
+#define WITH_RC5_CONTROL
+/* For SMP863xES4 or above, it's always there */
+#if (defined(CONFIG_TANGO2_SMP863X) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3_SMP865X)
+#define WITH_RC6_CONTROL
+#endif
+#endif
+
+//#define DEBUG_IR
+//#define ALL_KEYS_REPEATABLE
+
+#define SYS_gpio_base		SYS_gpio_dir
+
+/* NEC Control */
+#define IR_NEC_CTRL             (REG_BASE_system_block + SYS_gpio_base + 0x18)
+#define IR_NEC_CAPTURE_DATA    	(REG_BASE_system_block + SYS_gpio_base + 0x1c)
+
+#ifdef WITH_RC5_CONTROL
+/* RC5 Control */
+#define IR_RC5_CTRL             (REG_BASE_system_block + SYS_gpio_base + 0x20)
+#define IR_RC5_DECODE_CLK_DIV  	(REG_BASE_system_block + SYS_gpio_base + 0x24)
+#define IR_RC5_DECODER_DATA    	(REG_BASE_system_block + SYS_gpio_base + 0x28)
+#define IR_RC5_INT_STATUS    	(REG_BASE_system_block + SYS_gpio_base + 0x2c)
+#endif /* WITH_RC5_CONTROL */
+
+#ifdef WITH_RC6_CONTROL
+/* RC6 Control */
+#define RC6_DWORDS		5	/* 5 dwords = 20 bytes */
+#define IR_RC6_CTRL             (REG_BASE_system_block + SYS_gpio_base + 0xe0)
+#define IR_RC6_T_CTRL           (REG_BASE_system_block + SYS_gpio_base + 0xe4)
+#define IR_RC6_DATA_OUT0        (REG_BASE_system_block + SYS_gpio_base + 0xe8)
+#define IR_RC6_DATA_OUT1        (REG_BASE_system_block + SYS_gpio_base + 0xec)
+#define IR_RC6_DATA_OUT2        (REG_BASE_system_block + SYS_gpio_base + 0xf0)
+#define IR_RC6_DATA_OUT3        (REG_BASE_system_block + SYS_gpio_base + 0xf4)
+#define IR_RC6_DATA_OUT4        (REG_BASE_system_block + SYS_gpio_base + 0xf8)
+#endif
+
+/* The buffer size defines the size of circular buffer to keep the IR data */
+#ifdef WITH_RC6_CONTROL
+#define BUF_SIZE		6 	/* Minimum 20 bytes */
+#else
+#define BUF_SIZE		2
+#endif
+
+/* Wait period, to avoid bouncing? */
+#define WAIT_PERIOD		10
+
+/* Max. size of key table */
+#define MAX_KEYS		32
+
+/* The major device number and name */
+#define IR_DEV_MAJOR		0
+#define IR_DEV_NAME		"ir"
+
+#define DRIVER_VERSION         "1.17"
+
+MODULE_DESCRIPTION("TANGOX ir remote driver\n");
+MODULE_AUTHOR("TANGOX standalone team");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
+#ifdef WITH_RC5_CONTROL
+static int rc5_clk_div = 48006;	/* 48006 = 1.778ms, 36018 = 1.334ms, */
+				/* 59994 = 2.222ms */
+module_param(rc5_clk_div, int, 0);
+#endif /* WITH_RC5_CONTROL */
+
+static int wait_period = ((((WAIT_PERIOD * HZ) / 1000) == 0) ? 1 : ((WAIT_PERIOD * HZ) / 1000));
+module_param(wait_period, int, 0);
+static int wp_var; /* Variable wait period */
+
+static int buffer_size = BUF_SIZE;
+module_param(buffer_size, int, 0);
+
+static int max_keys = MAX_KEYS;
+module_param(max_keys, int, 0);
+
+static int major_num = IR_DEV_MAJOR;
+module_param(major_num, int, 0);
+
+static int repeat_sends_zero = 0;
+module_param(repeat_sends_zero, int, 0);
+
+/* Wait queue, may be used if block mode is on */
+DECLARE_WAIT_QUEUE_HEAD(ir_wq);
+
+/* Private data structure */
+struct ir_private {
+	unsigned long *buffer;		/* Circular buffer */
+	unsigned long *key_table;	/* Table for repetition keys */
+	unsigned p_idx;			/* Index of producer */
+	unsigned c_idx; 		/* Index of consumer */
+	unsigned ref_cnt;		/* Reference count */
+	spinlock_t lock;		/* Spin lock */
+	unsigned char b_mode;		/* Blocking mode or not */
+	unsigned long last_jiffies;	/* Timestamp for last reception */
+	unsigned int num_keys;		/* Number of keys in the table */
+};
+
+/* Some prototypes */
+static int ir_open(struct inode *, struct file *);
+static int ir_release(struct inode *, struct file *);
+static int ir_read(struct file *, char *, size_t, loff_t *);
+static int ir_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+static unsigned int ir_poll(struct file *, struct poll_table_struct *);
+
+/* Global data */
+static struct ir_private ir_priv;
+static char *ir_devname = IR_DEV_NAME;
+static int ir_irq = LOG2_CPU_INFRARED_INT + IRQ_CONTROLLER_IRQ_BASE;
+
+static struct file_operations ir_fops = {
+	open: ir_open,
+	read: ir_read,
+	ioctl: ir_ioctl,
+	poll: ir_poll,
+	release: ir_release,
+	owner: THIS_MODULE,
+};
+
+/* Check to see if we can find the key in the repetition key table */
+static int ir_findkey(struct ir_private *priv, unsigned long key)
+{
+#ifdef ALL_KEYS_REPEATABLE
+	return(key);
+#else
+	register unsigned int i;
+	unsigned long *ptr = priv->key_table;
+
+	for (i = 0; i < priv->num_keys; i++, ptr++)
+		if (key == *ptr)
+			return(key);
+	return(0);
+#endif
+}
+
+/* Produce data */
+static void ir_produce(struct ir_private *priv, unsigned long status)
+{
+	static unsigned long old_key = 0;
+	static unsigned long save_key = 0;
+	unsigned long data = 0;
+	unsigned pidx;
+	int repeat_key = 0;
+#ifdef WITH_RC6_CONTROL
+	static unsigned long save_rc6_key[RC6_DWORDS];	/* Only used for RC6 */
+#endif
+
+	spin_lock(&priv->lock);
+
+#ifdef WITH_RC6_CONTROL
+	if ((status & 0x80000000) != 0) {	// RC6 Data in IRQ
+		unsigned long dx[RC6_DWORDS];
+		dx[0] = gbus_read_uint32(pGBus, IR_RC6_DATA_OUT0);
+		dx[1] = gbus_read_uint32(pGBus, IR_RC6_DATA_OUT1);
+		dx[2] = gbus_read_uint32(pGBus, IR_RC6_DATA_OUT2);
+		dx[3] = gbus_read_uint32(pGBus, IR_RC6_DATA_OUT3);
+		dx[4] = gbus_read_uint32(pGBus, IR_RC6_DATA_OUT4);
+#ifdef DEBUG_IR
+		printk(KERN_DEBUG "D0-4: 0x%08lx 0x%08lx 0x%08lx 0x%08lx 0x%08lx\n", dx[0], 
+				dx[1], dx[2], dx[3], dx[4]);
+#endif
+		if ((dx[0] & 0x1f) != 0x1c) { 
+#ifdef DEBUG_IR
+			printk(KERN_DEBUG "Not acceptable RC6 code 0x%08lx\n", dx[0]);
+#endif
+			goto out;	/* Not valid */
+		} else if (time_after(priv->last_jiffies + wait_period, jiffies) && 
+			(memcmp(&save_rc6_key, &dx, sizeof(unsigned long) * RC6_DWORDS) == 0)) {
+			/* Throw away this key if this is the same key and came too
+		   	   fast */
+#ifdef DEBUG_IR
+			printk(KERN_DEBUG "%s: same data\n", ir_devname);
+#endif
+			save_key = 0;
+			goto out;
+		} 
+
+		/* Save the key */
+		memcpy(&save_rc6_key, &dx, sizeof(unsigned long) * RC6_DWORDS);
+
+		priv->last_jiffies = jiffies;
+		pidx = priv->p_idx;	/* Save the old index before proceeding */
+
+		/* Save it to buffer */
+		if (((priv->p_idx + 1) % buffer_size) == priv->c_idx) {
+			/* Adjust consumer index since buffer is full */
+			/* Keep the latest one and drop the oldest one */
+			priv->c_idx = (priv->c_idx + 1) % buffer_size;
+			printk(KERN_WARNING "%s: buffer full\n", ir_devname);
+		} else if (((priv->p_idx + 2) % buffer_size) == priv->c_idx) {
+			/* Adjust consumer index since buffer is full */
+			/* Keep the latest one and drop the oldest ones */
+			priv->c_idx = (priv->c_idx + 2) % buffer_size;
+			printk(KERN_WARNING "%s: buffer full\n", ir_devname);
+		} else if (((priv->p_idx + 3) % buffer_size) == priv->c_idx) {
+			/* Adjust consumer index since buffer is full */
+			/* Keep the latest one and drop the oldest ones */
+			priv->c_idx = (priv->c_idx + 3) % buffer_size;
+			printk(KERN_WARNING "%s: buffer full\n", ir_devname);
+		} else if (((priv->p_idx + 4) % buffer_size) == priv->c_idx) {
+			/* Adjust consumer index since buffer is full */
+			/* Keep the latest one and drop the oldest ones */
+			priv->c_idx = (priv->c_idx + 4) % buffer_size;
+			printk(KERN_WARNING "%s: buffer full\n", ir_devname);
+		} else if (((priv->p_idx + 5) % buffer_size) == priv->c_idx) {
+			/* Adjust consumer index since buffer is full */
+			/* Keep the latest one and drop the oldest ones */
+			priv->c_idx = (priv->c_idx + 5) % buffer_size;
+			printk(KERN_WARNING "%s: buffer full\n", ir_devname);
+		}
+
+/*		priv->buffer[priv->p_idx] = dx[0];
+		priv->p_idx = (priv->p_idx + 1) % buffer_size;*/
+		priv->buffer[priv->p_idx] = dx[1]<<4; // Experimental support for miniclient... JFT
+		priv->p_idx = (priv->p_idx + 1) % buffer_size;
+/*		priv->buffer[priv->p_idx] = dx[2];
+		priv->p_idx = (priv->p_idx + 1) % buffer_size;
+		priv->buffer[priv->p_idx] = dx[3];
+		priv->p_idx = (priv->p_idx + 1) % buffer_size;
+		priv->buffer[priv->p_idx] = dx[4];
+		priv->p_idx = (priv->p_idx + 1) % buffer_size;*/
+
+		/* Buffer was empty and block mode is on, wake up the reader */
+		if ((priv->b_mode != 0) && (priv->c_idx == pidx)) 
+			wake_up_interruptible(&ir_wq);
+
+		goto out;
+	}
+#endif
+
+#ifdef WITH_RC5_CONTROL
+	if (status & 0x00000001) {	// RC5 IRQ
+		data = gbus_read_uint32(pGBus, IR_RC5_DECODER_DATA);
+		gbus_write_uint32(pGBus, IR_RC5_DECODER_DATA, 0);
+		if ((data & 0x80000000) != 0)  /* Invalid RC5 decoder data */
+			goto out;
+	} else if (status & 0x00000002) {	// NEC IRQ
+		data = gbus_read_uint32(pGBus, IR_NEC_CAPTURE_DATA);
+		gbus_write_uint32(pGBus, IR_NEC_CAPTURE_DATA, 0);
+	} else
+		goto out;
+#else
+	data = gbus_read_uint32(pGBus, IR_NEC_CAPTURE_DATA);
+	gbus_write_uint32(pGBus, IR_NEC_CAPTURE_DATA, 0);
+#endif
+
+	/* Discard not used data if needed */
+	if (data == 0) {
+		if (save_key == 0)
+			goto out;
+		old_key = 0;
+#ifdef DEBUG_IR
+		printk(KERN_DEBUG "%s: no data\n", ir_devname);
+#endif
+		if (time_after(priv->last_jiffies + wp_var, jiffies)) {
+#ifdef DEBUG_IR
+			printk(KERN_DEBUG "%s: repetition too fast\n", ir_devname);
+#endif
+			goto out; 	/* Key repeats too fast, drop it */
+		} else if (time_before(priv->last_jiffies + (wait_period * 4), jiffies)) {
+#ifdef DEBUG_IR
+			printk(KERN_DEBUG "%s: got slow repetition, glitch?\n", ir_devname);
+#endif
+			save_key = 0;	/* Disallow key repitition */
+			goto out;	/* Repeat too slow, drop it */
+		} else if (ir_findkey(priv, save_key) == 0) {
+#ifdef DEBUG_IR
+			printk(KERN_DEBUG "%s: not repeatable key 0x%lx\n", ir_devname, save_key);
+#endif
+			goto out; /* If the key is not in the table, drop it */
+		}
+
+#ifdef DEBUG_IR
+		printk(KERN_DEBUG "%s: got repeated key 0x%lx\n", ir_devname, save_key);
+#endif
+		data = save_key; /* Valid repeated key */
+		repeat_key = 1;
+	} else if (time_after(priv->last_jiffies + wait_period, jiffies) && 
+			(data == old_key)) {
+		/* Throw away this key if this is the same key and came too
+		   fast */
+#ifdef DEBUG_IR
+		printk(KERN_DEBUG "%s: same data\n", ir_devname);
+#endif
+		save_key = 0;
+		goto out;
+	} 
+
+	/* Shrink the wait time for repeat key if current one is repeated */
+	wp_var = (repeat_key ? (wait_period / 2) : wait_period); 
+	priv->last_jiffies = jiffies;
+	save_key = old_key = data;
+
+#ifdef DEBUG_IR
+	printk(KERN_DEBUG "%s: got data 0x%08lx\n", ir_devname, data);
+#endif
+
+	pidx = priv->p_idx;	/* Save the old index before proceeding */
+
+	if (repeat_sends_zero && repeat_key)
+		data = 0; /* clear the data */
+
+	/* Save it to buffer */
+	if (((priv->p_idx + 1) % buffer_size) == priv->c_idx) {
+		/* Adjust consumer index since buffer is full */
+		/* Keep the latest one and drop the oldest one */
+		priv->c_idx = (priv->c_idx + 1) % buffer_size;
+
+		printk(KERN_WARNING "%s: buffer full\n", ir_devname);
+	}
+
+	priv->buffer[priv->p_idx] = data;
+	priv->p_idx = (priv->p_idx + 1) % buffer_size;
+
+	/* Buffer was empty and block mode is on, wake up the reader */
+	if ((priv->b_mode != 0) && (priv->c_idx == pidx)) 
+		wake_up_interruptible(&ir_wq);
+
+out:
+	spin_unlock(&priv->lock);
+}
+
+/* ISR for IR device */
+static irqreturn_t ir_isr(int irq, void *dev_id)
+{
+	struct ir_private *priv = (struct ir_private *)dev_id;
+	unsigned long status = 0;
+
+	if (priv != &ir_priv)		/* Paranoid check */
+		return IRQ_NONE;
+
+	// gbus_write_uint32(pGBus, REG_BASE_CPU + CPU_edge_rawstat, IRQMASKOF(ir_irq));
+	
+#ifdef WITH_RC6_CONTROL 
+	status = gbus_read_uint32(pGBus, IR_RC6_CTRL);
+	if ((status & 0xc0000000) != 0) {
+		gbus_write_uint32(pGBus, IR_RC6_CTRL, status); /* Clear interrupt */
+#ifdef DEBUG_IR
+		if ((status & 0x40000000) != 0) 
+			printk(KERN_DEBUG "RC6 Err IRQ (0x%08lx)\n", status);
+#endif
+		if ((status & 0x80000000) != 0) {
+			/* We have RC6 data */
+#ifdef DEBUG_IR
+			printk(KERN_DEBUG "RC6 Datain IRQ (0x%08lx)\n", status);
+#endif
+			ir_produce(priv, status);
+
+#ifdef WITH_RC5_CONTROL
+			/* Force to clear RC5 interrupt status */
+			status = gbus_read_uint32(pGBus, IR_RC5_INT_STATUS);
+			if ((status & 0x00000003) != 0)
+				gbus_write_uint32(pGBus, IR_RC5_INT_STATUS, status); /* Clear interrupt if any */
+#endif
+			return IRQ_HANDLED;
+		} 
+	}
+#endif
+
+#ifdef WITH_RC5_CONTROL
+	status = gbus_read_uint32(pGBus, IR_RC5_INT_STATUS);
+#ifdef DEBUG_IR
+	if ((status & 0x00000001) != 0) {
+		/* RC5 interrupt */
+		printk(KERN_DEBUG "RC5 IRQ (0x%08lx)\n", status);
+	}
+	if ((status & 0x00000002) != 0) {
+		/* NEC interrupt */
+		printk(KERN_DEBUG "NEC IRQ (0x%08lx)\n", status);
+	}
+#endif
+	gbus_write_uint32(pGBus, IR_RC5_INT_STATUS, status); /* Clear interrupt */
+	status &= 0x00000003;
+#endif /* WITH_RC5_CONTROL */
+
+	ir_produce(priv, status);
+	return IRQ_HANDLED;
+}
+
+/* Reading from driver's buffer, note that it can return read size
+   less than specified */
+static int ir_consume(void *dev_id, unsigned long *buf, int count)
+{
+	struct ir_private *priv = (struct ir_private *)dev_id;
+	int cnt = 0;
+	unsigned long flags;
+
+	/* If block mode is on, check the emptiness of buffer */
+	if (priv->b_mode != 0) {
+		/* Sleep when buffer is empty */
+		wait_event_interruptible(ir_wq, priv->c_idx != priv->p_idx);
+	}
+	if (signal_pending(current))
+		return(cnt);
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	/* Get the data out and adjust consumer index */
+	for (cnt = 0; (priv->c_idx != priv->p_idx) && (cnt < count); cnt++) {
+		*buf = priv->buffer[priv->c_idx];
+		priv->c_idx = (priv->c_idx + 1) % buffer_size;
+		buf++;
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return(cnt);
+}
+
+/* Reading data */
+static int ir_read(struct file *fptr, char *bufptr, size_t size, loff_t *fp)
+{
+	unsigned long buf[buffer_size];
+	int count;
+
+	/* Check the alignment */
+	if (size % sizeof(unsigned long)) {
+		printk(KERN_WARNING "%s: read size not aligned to %d\n",
+			ir_devname, sizeof(unsigned long));
+		return(-EIO);
+	}
+
+	count = ir_consume(fptr->private_data, &buf[0], 
+			size / sizeof(unsigned long)) * sizeof(unsigned long);
+
+	/* Get the data to user */
+	if (count && copy_to_user(bufptr, (char *)&buf[0], count)) 
+		return(-EFAULT);
+
+	return(count);
+}
+
+extern int tangox_get_gpioled();
+
+/* ioctl function */
+static int ir_ioctl(struct inode *inode, struct file *fptr, unsigned int cmd, unsigned long arg)
+{
+	unsigned long *ptr = (unsigned long *)arg;
+	unsigned long key_no = 0;
+	struct ir_private *priv = (struct ir_private *)fptr->private_data;
+	unsigned long flags;
+
+	if (ptr == NULL && cmd!=FIP_IOCSHOWLED)
+		return(-EIO);
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	switch(cmd) {
+		case IR_IOCSETREPEATKEYS: /* Set the repetition keys */
+			if (copy_from_user(&key_no, ptr, sizeof(unsigned long))) {
+				spin_unlock_irqrestore(&priv->lock, flags);
+				return(-EFAULT);
+			} else if ((key_no <= 0) || (key_no > max_keys)) {
+				spin_unlock_irqrestore(&priv->lock, flags);
+				return(-EIO);
+			} else
+				priv->num_keys = key_no;
+			copy_from_user(priv->key_table, ptr + 1, sizeof(unsigned long) * key_no);
+			break;
+		case IR_IOCGETREPEATKEYS: /* Get the repetition keys */
+			key_no = priv->num_keys;
+			copy_to_user(ptr, &key_no, sizeof(unsigned long));
+			if (key_no > 0)
+				copy_to_user(ptr + 1, priv->key_table, sizeof(unsigned long) * key_no);
+			break;
+		case IR_IOCSETWAITPERIOD:
+			wait_period = wp_var = ((((arg * HZ) / 1000) == 0) ? 1 : ((arg * HZ) / 1000));
+			break;
+		case IR_IOCGETWAITPERIOD: {
+				int wp = (wait_period * 1000) / HZ;
+				copy_to_user(ptr, &wp, sizeof(int));
+			}
+			break;
+		case FIP_IOCSHOWLED:
+			if(tangox_get_gpioled()<16)
+				gbus_write_uint32(pGBus, REG_BASE_system_block + SYS_gpio_dir, 
+					GPIO_DIR_OUTPUT(tangox_get_gpioled()));
+			else
+				gbus_write_uint32(pGBus, REG_BASE_host_interface + ETH_gpio_dir2, 
+					GPIO_DIR_OUTPUT(tangox_get_gpioled()-16));
+			if(arg==12)
+			{
+				if(tangox_get_gpioled()<16)
+					gbus_write_uint32(pGBus, REG_BASE_system_block + SYS_gpio_data, 
+						GPIO_DATA_SET(tangox_get_gpioled()));
+				else
+					gbus_write_uint32(pGBus, REG_BASE_host_interface + ETH_gpio_data2, 
+						GPIO_DATA_SET(tangox_get_gpioled()-16));
+			}
+			else if(arg==4)
+			{
+				if(tangox_get_gpioled()<16)
+					gbus_write_uint32(pGBus, REG_BASE_system_block + SYS_gpio_data, 
+						GPIO_DATA_CLEAR(tangox_get_gpioled()));
+				else
+					gbus_write_uint32(pGBus, REG_BASE_host_interface + ETH_gpio_data2, 
+						GPIO_DATA_CLEAR(tangox_get_gpioled()-16));
+			}
+			else if(arg==0)
+			{
+				if(tangox_get_gpioled()<16)
+					gbus_write_uint32(pGBus, REG_BASE_system_block + SYS_gpio_data, 
+						GPIO_DATA_SET(tangox_get_gpioled()));
+				else
+					gbus_write_uint32(pGBus, REG_BASE_host_interface + ETH_gpio_data2, 
+						GPIO_DATA_SET(tangox_get_gpioled()-16));
+			}
+			else
+			{
+				if(tangox_get_gpioled()<16)
+					gbus_write_uint32(pGBus, REG_BASE_system_block + SYS_gpio_data, 
+						GPIO_DATA_SET(tangox_get_gpioled()));
+				else
+					gbus_write_uint32(pGBus, REG_BASE_host_interface + ETH_gpio_data2, 
+						GPIO_DATA_SET(tangox_get_gpioled()-16));
+			}
+			break;
+		default:
+			spin_unlock_irqrestore(&priv->lock, flags);
+                        return(-EIO);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return(0);
+}
+
+/* Poll function */
+static unsigned int ir_poll(struct file *fptr, struct poll_table_struct *ptable)
+{
+	struct ir_private *priv = (struct ir_private *)fptr->private_data;
+	unsigned int mask = 0;
+	unsigned long flags;
+
+	poll_wait(fptr, &ir_wq, ptable);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	if (priv->c_idx != priv->p_idx)
+		mask |= (POLLIN | POLLRDNORM);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return(mask);
+}
+
+/* Open the device */
+static int ir_open(struct inode *inode_ptr, struct file *fptr)
+{
+	/* This device is exclusive, that is, only one process can use it */
+	if (ir_priv.ref_cnt != 0) {
+		printk(KERN_WARNING "%s: exclusive access only\n", ir_devname);
+		return(-EIO);
+	/* This device is read-only */
+	} else if ((fptr->f_flags & O_ACCMODE) != O_RDONLY) {
+		printk(KERN_WARNING "%s: read-only device\n", ir_devname);
+		return(-EIO);
+	} 
+
+	/* Set the block mode and increase reference count */
+	ir_priv.ref_cnt++;
+	ir_priv.b_mode = ((fptr->f_flags & O_NONBLOCK) ? 0 : 1);
+	ir_priv.last_jiffies = jiffies;
+
+	/* Flush the buffer */
+	ir_priv.p_idx = ir_priv.c_idx = 0;
+
+	fptr->f_op = &ir_fops;
+	fptr->private_data = (void *)&ir_priv;
+
+	/* Enable the NEC device (CTRL register) */
+	/*	31:30 - reserved */
+	/*	29:24 	IR_CAPTURE_NBITS [5:0] -> set to 0x1f */
+	/*	23:22 - reserved */
+	/*	21:16 	GPIO_INFREARED_SEL [5:0] -> set to 12 */
+	/*	15:14 - reserved */
+	/*	13:0	IR_PREDIV_DEVIDER [13:0] -> set to 0x3b10 */
+	gbus_write_uint32(pGBus, REG_BASE_system_block + SYS_gpio_dir, GPIO_DIR_INPUT(12));
+	gbus_write_uint32(pGBus, IR_NEC_CAPTURE_DATA, 0);
+	gbus_write_uint32(pGBus, IR_NEC_CTRL, 0x1f0c3b10);
+
+	wp_var = wait_period;
+
+	printk(KERN_DEBUG "%s: Enable NEC decoder (0x%08lx)\n", 
+			ir_devname, gbus_read_uint32(pGBus, IR_NEC_CAPTURE_DATA));
+
+#ifdef WITH_RC5_CONTROL
+	/* Enable the RC5 device (CTRL register) */
+	/*	31:10 - reserved */
+	/*	9	IR_RC5_INT_ENABLE -> set */
+	/*	8	IR_NEC_INT_DISABLE */
+	/*	7	IR_DEBOUNCE_SEL1 -> set */
+	/*	6	IR_DEBOUNCE_SEL0 -> set */
+	/*	5	IR_DEBOUNCE_ENABLE -> set */
+	/*	4	IR_NEC_DISABLE */
+	/*	3	IR_RSYNC_1/4 -> set */
+	/*	2	IR_RSYNC_1/8 */
+	/*	1	IR_SIGNAL_INVERT */
+	/*	0	IR_RC5_DECODE_ENABLE -> set */
+	gbus_write_uint32(pGBus, IR_RC5_DECODE_CLK_DIV, rc5_clk_div);
+	gbus_write_uint32(pGBus, IR_RC5_DECODER_DATA, 0);
+	gbus_write_uint32(pGBus, IR_RC5_CTRL, 0x000002e9);
+
+	printk(KERN_DEBUG "%s: Enable RC5 decoder (0x%08lx)\n", 
+			ir_devname, gbus_read_uint32(pGBus, IR_RC5_DECODER_DATA));
+#endif /* WITH_RC5_CONTROL */
+
+#ifdef WITH_RC6_CONTROL
+	/* Enable the RC6 device (CTRL register) */
+	/*	7	IR_RC6_DATA_IN_INT_ENABLE -> set */
+	/*	6	IR_RC6_ERROR_INT_ENABLE -> set */
+	/*	5:2	reserved */
+	/*	1	IR_SIGNAL_INVERT */
+	/*	0	IR_RC6_DECODE_ENABLE -> set */
+	gbus_write_uint32(pGBus, IR_RC6_CTRL, 0xc1);
+	/* Tolerance and Duration */
+	/*	31:18	Tolerance (typ. 0xbb8) */
+	/*	17:0	Duration (typ. 0x2ee0) */
+	gbus_write_uint32(pGBus, IR_RC6_T_CTRL, (0xbb8 << 18) | 0x2ee0);
+
+	printk(KERN_DEBUG "%s: Enable RC6 decoder\n", ir_devname);
+#endif
+	return(0);
+}
+
+/* Close the device */
+static int ir_release(struct inode *inode_ptr, struct file *fptr) 
+{
+	/* Disable the NEC device */
+	printk(KERN_DEBUG "%s: Disable NEC decoder\n", ir_devname);
+	gbus_write_uint32(pGBus, IR_NEC_CAPTURE_DATA, 0);
+	gbus_write_uint32(pGBus, IR_NEC_CTRL, 0);
+
+#ifdef WITH_RC5_CONTROL
+	/* Disable RC5 control */
+	printk(KERN_DEBUG "%s: Disable RC5 decoder\n", ir_devname);
+	gbus_write_uint32(pGBus,  IR_RC5_CTRL, (gbus_read_uint32(pGBus, IR_RC5_CTRL) & 0xfffffdfe) | 0x00000100);
+#endif /* WITH_RC5_CONTROL */
+
+#ifdef WITH_RC6_CONTROL
+	printk(KERN_DEBUG "%s: Disable RC6 decoder\n", ir_devname);
+	gbus_write_uint32(pGBus, IR_RC6_CTRL, 0xc0000000);
+#endif /* WITH_RC6_CONTROL */
+
+	/* Adjust reference count */
+	ir_priv.ref_cnt--;
+
+	return(0);
+}
+
+int __init ir_init_module(void)
+{
+	int status = 0;
+
+	extern int tangox_ir_enabled(void);
+	if (tangox_ir_enabled() == 0)
+		return(0);
+
+	/* Initialize private data structure */
+	memset(&ir_priv, 0, sizeof(struct ir_private)); 
+	spin_lock_init(&ir_priv.lock);
+
+#ifdef WITH_RC6_CONTROL
+	if (buffer_size < 6) {
+		printk(KERN_ERR "%s: buffer size (%d) error, minimum 6.\n", ir_devname,
+			buffer_size); 
+		return(-EIO);
+	} 
+#else
+	if (buffer_size < 2) {
+		printk(KERN_ERR "%s: buffer size (%d) error, minimum 2.\n", ir_devname,
+			buffer_size); 
+		return(-EIO);
+	} 
+#endif
+
+	if ((ir_priv.buffer = kmalloc(buffer_size * sizeof(unsigned long), GFP_KERNEL)) == NULL) {
+		printk(KERN_ERR "%s: out of memory for buffer\n", ir_devname); 
+		return(-ENOMEM);
+	} else if ((ir_priv.key_table = kmalloc(max_keys * sizeof(unsigned long), GFP_KERNEL)) == NULL) {
+		printk(KERN_ERR "%s: out of memory for key table\n", ir_devname); 
+		kfree(ir_priv.buffer);
+		return(-ENOMEM);
+	}
+
+	/* Register device, and may be allocating major# */
+	status = register_chrdev(major_num, ir_devname, &ir_fops);
+	if (status < 0) {
+		printk(KERN_ERR "%s: cannot get major number\n", ir_devname); 
+		kfree(ir_priv.buffer);
+		kfree(ir_priv.key_table);
+		return(status);
+	} else if (major_num == 0)
+		major_num = status;	/* Dynamic major# allocation */
+
+	/* Make sure interrupt is disabled, will be re-enabled in device
+	   open stage */
+	gbus_write_uint32(pGBus, IR_NEC_CTRL, 0);
+
+#ifdef WITH_RC5_CONTROL
+	gbus_write_uint32(pGBus, IR_RC5_CTRL, (gbus_read_uint32(pGBus, IR_RC5_CTRL) & 0xfffffdfe) | 0x00000100);
+#endif
+
+#ifdef WITH_RC6_CONTROL
+	gbus_write_uint32(pGBus, IR_RC6_CTRL, 0xc0000000);
+#endif
+
+	/* Hook up ISR */
+	if (request_irq(ir_irq, ir_isr, IRQF_SHARED, ir_devname, 
+			&ir_priv) != 0) {
+		printk(KERN_ERR "%s: cannot register IRQ (%d)\n", ir_devname,
+			ir_irq);
+		unregister_chrdev(major_num, ir_devname);	
+		kfree(ir_priv.buffer);
+		kfree(ir_priv.key_table);
+		return(-EIO);
+	}
+
+	printk(KERN_INFO "SMP86xx %s (%d:0): driver loaded (wait_period = %dms, "
+		"buffer_size = %d)\n", ir_devname, major_num, wait_period, buffer_size);
+	return(0);
+}
+
+void __exit ir_cleanup_module(void)
+{
+	extern int tangox_ir_enabled(void);
+	if (tangox_ir_enabled() == 0)
+		return;
+
+	unregister_chrdev(major_num, ir_devname);
+	free_irq(ir_irq, &ir_priv);
+
+	if (ir_priv.buffer != NULL)
+		kfree(ir_priv.buffer);
+	if (ir_priv.key_table != NULL)
+		kfree(ir_priv.key_table);
+
+	printk(KERN_INFO "%s: driver unloaded\n", ir_devname);
+}
+
+module_init(ir_init_module);
+module_exit(ir_cleanup_module);
+
diff -Naur linux-2.6.25.8/drivers/ide/Kconfig linux-2.6.25.8-clean/drivers/ide/Kconfig
--- linux-2.6.25.8/drivers/ide/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/ide/Kconfig	2008-06-26 14:59:56.000000000 -0400
@@ -852,6 +852,36 @@
        default "128"
        depends on BLK_DEV_IDE_AU1XXX
 
+config BLK_DEV_BMIDE_TANGOX
+       select IDE_GENERIC
+       tristate "BMIDE for SMP863x/SMP865x"
+       depends on TANGOX
+       help
+         Enable the support for Bus Mastering IDE controller. 
+
+config BLK_DEV_BMIDE_TANGOX_DMA
+	bool "support BMIDE DMA operations"
+	default y
+	depends on BLK_DEV_BMIDE_TANGOX
+	help
+	  Enable the DMA support for Bus Mastering IDE controller, which
+	  include support for MDMA and UDMA modes. 
+
+config BLK_DEV_PBIDE_TANGOX
+       select IDE_GENERIC
+       tristate "PBIDE for SMP863x/SMP865x"
+       depends on TANGOX
+       help
+         Enable the support for Peripheral Bus IDE controller. 
+
+config BLK_DEV_PBIDE_TANGOX_DMA
+       bool "support PBIDE DMA operations"
+       default y
+       depends on BLK_DEV_PBIDE_TANGOX
+       help
+         Enable the DMA support for Bus Mastering IDE controller, which
+	  include support for MDMA modes. 
+
 config IDE_ARM
 	tristate "ARM IDE support"
 	depends on ARM && (ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
@@ -1112,7 +1142,7 @@
 
 config BLK_DEV_IDEDMA
 	def_bool BLK_DEV_IDEDMA_SFF || BLK_DEV_IDEDMA_PMAC || \
-		 BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+		 BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA || BLK_DEV_BMIDE_TANGOX_DMA || BLK_DEV_PBIDE_TANGOX_DMA
 
 config IDE_ARCH_OBSOLETE_INIT
 	def_bool ALPHA || (ARM && !ARCH_L7200) || BLACKFIN || X86 || IA64 || M32R || MIPS || PARISC || PPC || (SUPERH64 && BLK_DEV_IDEPCI) || SPARC
diff -Naur linux-2.6.25.8/drivers/ide/Makefile linux-2.6.25.8-clean/drivers/ide/Makefile
--- linux-2.6.25.8/drivers/ide/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/ide/Makefile	2008-06-26 14:59:56.000000000 -0400
@@ -26,7 +26,7 @@
 	obj-y += ide-arm-core.o
 endif
 
-obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ pci/
+obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ pci/ tangox/
 
 obj-$(CONFIG_IDEPCI_PCIBUS_ORDER)	+= ide-scan-pci.o
 
diff -Naur linux-2.6.25.8/drivers/ide/ide-probe.c linux-2.6.25.8-clean/drivers/ide/ide-probe.c
--- linux-2.6.25.8/drivers/ide/ide-probe.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/ide/ide-probe.c	2008-06-30 17:50:35.000000000 -0400
@@ -875,7 +875,11 @@
 {
 	struct request_queue *q;
 	ide_hwif_t *hwif = HWIF(drive);
+#ifndef MAX_KMALLOC_ORDER
 	int max_sectors = 256;
+#else
+	int max_sectors = (PAGE_SIZE<<MAX_KMALLOC_ORDER)>>9;
+#endif
 	int max_sg_entries = PRD_ENTRIES;
 
 	/*
@@ -891,7 +895,15 @@
 		return 1;
 
 	q->queuedata = drive;
+
+#if defined(CONFIG_BLK_DEV_BMIDE_TANGOX) || defined(CONFIG_BLK_DEV_PBIDE_TANGOX)
+	/* we  can handle  physical address  crossing  any boundaries,
+	 * this will make linux really merge all physically contiguous
+	 * bio */
+	blk_queue_segment_boundary(q, 0xffffffff);
+#else
 	blk_queue_segment_boundary(q, 0xffff);
+#endif
 
 	if (hwif->rqsize < max_sectors)
 		max_sectors = hwif->rqsize;
@@ -1051,7 +1063,7 @@
 	 */
 	if (!match || match->irq != hwif->irq) {
 		int sa = 0;
-#if defined(__mc68000__)
+#if defined(__mc68000__) || defined(CONFIG_TANGOX)
 		sa = IRQF_SHARED;
 #endif /* __mc68000__ */
 
diff -Naur linux-2.6.25.8/drivers/ide/ide.c linux-2.6.25.8-clean/drivers/ide/ide.c
--- linux-2.6.25.8/drivers/ide/ide.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/ide/ide.c	2008-06-26 14:59:56.000000000 -0400
@@ -813,6 +813,18 @@
 
 	return -EPERM;
 #endif
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX
+	{
+		extern int __init tangox_bmide_init(void);
+		tangox_bmide_init();
+	}
+#endif
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX
+	{
+		extern int __init tangox_pbide_init(void);
+		tangox_pbide_init();
+	}
+#endif
 }
 
 int set_pio_mode(ide_drive_t *drive, int arg)
diff -Naur linux-2.6.25.8/drivers/ide/tangox/Makefile linux-2.6.25.8-clean/drivers/ide/tangox/Makefile
--- linux-2.6.25.8/drivers/ide/tangox/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/ide/tangox/Makefile	2008-06-26 14:59:56.000000000 -0400
@@ -0,0 +1,4 @@
+obj-$(CONFIG_BLK_DEV_BMIDE_TANGOX)	+= tangox-bmide.o
+obj-$(CONFIG_BLK_DEV_PBIDE_TANGOX)	+= tangox-pbide.o
+
+EXTRA_CFLAGS	:= -I../
diff -Naur linux-2.6.25.8/drivers/ide/tangox/tangox-bmide.c linux-2.6.25.8-clean/drivers/ide/tangox/tangox-bmide.c
--- linux-2.6.25.8/drivers/ide/tangox/tangox-bmide.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/ide/tangox/tangox-bmide.c	2008-10-01 14:04:16.000000000 -0400
@@ -0,0 +1,842 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+
+#include "tangox-ide.h"
+
+static DEFINE_SPINLOCK(bmide_tune_chipset_spin_lock);
+
+#define PFX	"tangox_bmide: "
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+#define CONFIG_BLK_DEV_BMIDE_TANGOX_UDMA /* enable UDMA as well */
+#endif
+
+/*
+ * helper to access host interface
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_readl(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_writel(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_readb(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_writeb(REG_BASE_host_interface + (r), (v))
+
+#define CONFIG_RUNTIME_CLK_CALC
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+typedef struct {
+	unsigned long cycle_time;
+	unsigned long active_time;
+	unsigned long recovery_time;
+	unsigned long setup_time;
+	unsigned long hold_time;
+} j2_tim_pio_dma_t;
+
+typedef struct {
+	unsigned long t_zah;//
+	unsigned long t_mli;//
+	unsigned long t_ack;//
+	unsigned long t_env;//
+	unsigned long t_rp;	//
+	unsigned long t_cyc;//
+	unsigned long t_cvh;//
+	unsigned long t_cvs;//
+} j2_tim_udma_t;
+
+static j2_tim_pio_dma_t	j2_pio_timings[] = 
+{
+//	 cycle	, active, recov	, setup	, hold
+	{600	, 165	, 70	, 70	, 30	},
+	{383	, 125	, 70	, 50	, 20	},
+	{240	, 100	, 70	, 30	, 15	},
+	{180	, 80	, 70	, 30	, 10	},
+	{120	, 70	, 25	, 25	, 10	},
+};
+
+static j2_tim_pio_dma_t	j2_dma_timings[] =
+{
+//	 cycle	, active, recov	, setup	, hold
+	{480	, 215	, 215	, 50	, 20	},
+	{150	, 80	, 50	, 30	, 15	},
+	{120	, 70	, 25	, 25	, 10	},
+};
+
+// We round 16.8 to 17 - Ex: mode 5, t_cyc=16.8!!!
+static j2_tim_udma_t j2_udma_timings[] =
+{
+//	 t_zah,  t_mli, t_ack,  t_env,  t_rp,  t_cyc   t_cvh   t_cvs
+	{ 20,	 20,	 20,	20,		160,	112,	  7,	 70	},
+	{ 20,	 20,	 20,	20,		125,	 73,	  7,	 48	},
+	{ 20,	 20,	 20,	20,		100,	 54,	  7,	 31	},
+	{ 20,	 20,	 20,	20,		100,	 39,	  7,	 20	},
+	{ 20,	 20,	 20,	20,		100,	 25,	  7,	  7	},
+	{ 20,	 20,	 20,	20,		 85,	 17,	 10,	 10	},
+	{ 20,	 20,	 20,	20,		 85,	 13,	 10,	 10	},
+	{ 20,	 20,	 20,	20,		 85,	 13,	 10,	 10	},
+};
+
+static unsigned int CalcRegValTiming_PIO_DMA(j2_tim_pio_dma_t *t, unsigned long ide_clock);
+static unsigned int CalcRegValTiming1_UDMA(j2_tim_udma_t *t, unsigned long ide_clock);
+static unsigned int CalcRegValTiming2_UDMA(j2_tim_udma_t *t, unsigned long ide_clock);
+#endif /* CONFIG_RUNTIME_CLK_CALC */
+
+/*
+ * io helpers for PIO access
+ */
+static void tangox_bmide_outb(u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_bmide_outw(u16 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_bmide_outbsync(ide_drive_t *drive, u8 data,
+				unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static u8 tangox_bmide_inb(unsigned long port)
+{
+	u8 val;
+
+	val = ((u8)(gbus_readw(port) & 0xff));
+	return val;
+}
+
+static u16 tangox_bmide_inw(unsigned long port)
+{
+	u16 val;
+
+	val = ((u16)(gbus_readw(port) & 0xffff));
+	return val;
+}
+
+static void tangox_bmide_insw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		*(u16 *)addr = (u16)(gbus_readw(port) & 0xffff);
+		addr += 2;
+	}
+}
+
+static void tangox_bmide_outsw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		gbus_writew(port, *(u16 *)addr);
+		addr += 2;
+	}
+}
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+/*
+ * returns closest pio mode timings from given dma speed
+ */
+static u8 dma_2_pio(u8 xfer_rate) {
+
+	switch (xfer_rate) {
+	case XFER_UDMA_6:
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+/*
+ * dma related callbacks
+ */
+void tangox_bmide_dma_host_set(ide_drive_t *drive, int on)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 unit			= (drive->select.b.unit & 0x01);
+	u8 dma_stat		= hwif->INB(hwif->dma_status);
+
+	if (on)
+		dma_stat |= (1 << (5 + unit));
+	else
+		dma_stat &= ~(1 << (5 + unit));
+
+	hwif->OUTB(dma_stat, hwif->dma_status);
+}
+
+u8 tangox_bmide_cable_detect(struct hwif_s * hwif)
+{
+	if ((gbus_readl(REG_BASE_host_interface +
+		IDECTRL_idestatus) & 0x02) == 0x02) {
+		printk(KERN_ERR "no 80 conductors cable, falling back to "
+		       "lower udma mode\n");
+		return ATA_CBL_PATA40;
+	}
+	return ATA_CBL_PATA80;
+}
+
+/*
+ * dma operations
+ */
+static unsigned long g_mbus_reg = 0;
+static unsigned int g_next_sg = 0;
+
+static ide_startstop_t tangox_dma_intr(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat, stat;
+	struct request *rq;
+
+        dma_stat = hwif->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);
+
+	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
+		if (!(dma_stat & 1)) {
+			rq = HWGROUP(drive)->rq;
+			ide_end_request(drive, 1, rq->nr_sectors);
+			return ide_stopped;
+		}
+		printk(KERN_ERR PFX "%s: bad DMA status (dma_stat=%x)\n",
+		       drive->name, dma_stat);
+	}
+
+	return ide_error(drive, "dma_intr", 0);
+}
+
+static void tangox_mbus_intr(int irq, void *arg)
+{
+	ide_drive_t *drive = (ide_drive_t *)arg;
+	ide_hwif_t *hwif = HWIF(drive);
+        struct scatterlist *sg;
+
+	if (drive->using_dma == 0) {
+		printk(KERN_ERR PFX "bug: tangox_mbus_intr called while "
+		       "using_dma == 0\n");
+		return;
+	}
+
+	if (g_next_sg > hwif->sg_nents)
+		return;
+	else if (g_next_sg == hwif->sg_nents) { /* no more */
+		g_next_sg++;
+		em86xx_mbus_setup_dma_void(g_mbus_reg);
+		return;
+	}
+
+	em86xx_mbus_wait(g_mbus_reg, SBOX_IDEDVD);
+
+	/*
+	 * setup a new mbus transfer
+	 */
+	sg = &hwif->sg_table[g_next_sg];
+	g_next_sg++;
+
+	if (em86xx_mbus_setup_dma(g_mbus_reg, sg_dma_address(sg), sg_dma_len(sg),
+				  tangox_mbus_intr, drive, 0)) {
+		printk(KERN_ERR PFX "fail to resetup dma, wait "
+		       "for timeout...\n");
+	}
+}
+
+static void tangox_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+	/* issue  cmd to  drive,  and register  interrupt handler  for
+	 * command completion */
+	ide_execute_command(drive, command, &tangox_dma_intr, (2 * WAIT_CMD),
+			    NULL);
+}
+
+/* Get the I/O size of given request */
+static inline int get_request_size(struct request *rq)
+{
+	unsigned int rq_size;
+	struct bio *bio;
+	
+	for (rq_size = 0, bio = rq->bio; bio != NULL; bio = bio->bi_next)
+		rq_size += bio->bi_size;
+	
+	return rq_size;
+}
+
+static void tangox_dma_start(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq;
+	unsigned long val, len;
+
+        rq = HWGROUP(drive)->rq;
+	len = get_request_size(rq);
+
+	/* setup IDE DMA transfer len */
+	gbus_writel(REG_BASE_host_interface + IDECTRL_ide_dmalen, len);
+
+	/* enable bus mastering */
+	val = 0x05;
+	if (hwif->sg_dma_direction == DMA_FROM_DEVICE)
+		val |= 0x8;
+
+	gbus_writel(REG_BASE_host_interface + IDECTRL_bmic, val);
+}
+
+static int tangox_dma_setup(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq;
+	int iswrite;
+        struct scatterlist *sg = hwif->sg_table;
+
+        rq = HWGROUP(drive)->rq;
+
+	iswrite = (rq_data_dir(rq) == WRITE);
+	hwif->sg_dma_direction = iswrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	/*
+	 * ide_map_sg will merge contiguous memory zone for us
+	 */
+        ide_map_sg(drive, rq);
+
+	/* try to setup dma channel */
+	if (em86xx_mbus_alloc_dma(SBOX_IDEDVD, iswrite ? 0 : 1, &g_mbus_reg,
+				  NULL, 0)) {
+		printk(KERN_ERR PFX "fail to alloc dma, fallback to pio\n");
+		goto fallback_pio;
+	}
+
+	/*
+	 * map and transfer first segment
+	 */
+	dma_map_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	g_next_sg = 1;
+
+	/*
+	 * setup mbus dma for this address.  we want an mbus interrupt
+	 * only if this is not the last sg element,  so we can refeed
+	 * mbus.
+	 */
+	if (em86xx_mbus_setup_dma(g_mbus_reg, sg_dma_address(sg),
+				  sg_dma_len(sg),
+				  (hwif->sg_nents == 1) ? NULL : tangox_mbus_intr, 
+				  drive, 
+				  (hwif->sg_nents == 1) ? 1 : 0)) {
+		printk(KERN_ERR PFX "fail to setup dma, fallback to pio\n");
+		dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents,
+			     hwif->sg_dma_direction);
+		em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+		goto fallback_pio;
+	}
+
+	drive->waiting_for_dma = 1;
+	return 0;
+
+fallback_pio:
+	ide_map_sg(drive, rq);
+	return 1;
+}
+
+static int tangox_bmide_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+	int mbus_stat;
+        struct scatterlist *sg = hwif->sg_table;
+
+	dma_stat = hwif->INB(hwif->dma_status);
+
+	/*
+	 * make sure DMA is not in progress
+	 */
+	if ((dma_stat & 0x7) == 1) {
+		printk(KERN_ERR PFX "huh ? dma_end called while dma still "
+		       "in progress...\n");
+	}
+
+	/* clear the INTR & ERROR bits */
+	hwif->OUTB(dma_stat | 6, hwif->dma_status);
+
+	/*
+	 * confirm  whether MBUS transfer  is done  due to  the memory
+	 * arbitration, IDE  device thinks  the DMA transfer  is done,
+	 * but the data might be held in MBUS FIFO
+	 */
+	mbus_stat = em86xx_mbus_wait(g_mbus_reg, SBOX_IDEDVD);
+
+	/* release mbus */
+	em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+
+	/* stop bus mastering */
+	hwif->OUTB(0x4, hwif->dma_command);
+
+	dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents,
+		     hwif->sg_dma_direction);
+	drive->waiting_for_dma = 0;
+
+	/* fake  dma  error  in  case  of mbus  timeout,  else  return
+	 * dma_status error bit */
+	return (mbus_stat == 0) ? (dma_stat & 1) : 0x1;
+}
+
+static int tangox_bmide_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+
+	dma_stat = hwif->INB(hwif->dma_status);
+	if ((dma_stat & 0x4))
+		return 1;
+	return 0;
+}
+
+static void tangox_bmide_dma_lostirq(ide_drive_t *drive)
+{
+}
+
+static void tangox_bmide_dma_timeout(ide_drive_t *drive)
+{
+}
+#endif
+
+#ifndef CONFIG_RUNTIME_CLK_CALC
+/*
+ * timing values for each ide mode
+ */
+static const unsigned int s_pio_tim[] = {
+	0xff230ee6, 0xd41b0fa4, 0xb4150f63, 0xa7110f62, 0x9a0f0552
+};
+
+static const unsigned int s_dma_tim[] = {
+	0xf33333b4, 0xa3130b73, 0x9c100552
+};
+static const unsigned int s_udma_tim1[] = {
+	0x35440b08, 0x35440a06, 0x35440804
+};
+static const unsigned int s_udma_tim2[] = {
+	0x00000208, 0x00000206, 0x00000204
+};
+
+static const unsigned int s_udma_tim1_alt[] = {
+	0x44442418, 0x44441c10, 0x4444160b, 0x44441608,
+	0x44441605, 0x44441303, 0x44441302, 0x44441302
+};
+static const unsigned int s_udma_tim2_alt[] = {
+	0x0000010f, 0x0000010a, 0x00000106, 0x00000104,
+	0x00000101, 0x00000202, 0x00000202, 0x00000202
+};
+#endif /* !CONFIG_RUNTIME_CLK_CALC */
+
+static void tangox_bmide_set_pio_mode(ide_drive_t *drive, const u8 pio)
+{
+	int didx;
+	unsigned int ctrlreg, newflag;
+	unsigned long flags;
+	u8 mode;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+#define TIMING_MARGIN(x) (((x) * 105) / 100) /* add 5% margin */
+//#define TIMING_MARGIN(x) (x) /* no margin added */
+	extern unsigned long tangox_get_sysclock(void);
+	unsigned int ide_clock = TIMING_MARGIN(tangox_get_sysclock() / 1000000); /* in MHz */
+#endif
+	didx = drive->select.b.unit;
+	newflag = 0;
+	spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+
+	/*
+	 * setup timing for PIO mode
+	 */
+	mode = pio;
+	printk("%s: set to PIO mode %d\n", drive->name, mode);
+
+	/* fast timing for PIO */
+	newflag = 0x01;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+	gbus_writel(REG_BASE_host_interface +
+		    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+		    CalcRegValTiming_PIO_DMA(&(j2_pio_timings[mode]), ide_clock));
+#else
+	gbus_writel(REG_BASE_host_interface +
+		    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+		    s_pio_tim[mode]);
+#endif
+
+	ctrlreg = gbus_readl(REG_BASE_host_interface + IDECTRL_pri_idectl);
+	ctrlreg &= ~(didx == 0 ? 0xf : 0xf0);
+	ctrlreg |= newflag << (didx * 4);
+	gbus_writel(REG_BASE_host_interface + IDECTRL_pri_idectl, ctrlreg);
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+
+}
+
+static void tangox_bmide_set_dma_mode(ide_drive_t *drive, const u8 speed)
+{
+	int didx;
+	unsigned int ctrlreg, newflag;
+	unsigned long flags;
+	u8 mode;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+#define TIMING_MARGIN(x) (((x) * 105) / 100) /* add 5% margin */
+//#define TIMING_MARGIN(x) (x) /* no margin added */
+	extern unsigned long tangox_get_sysclock(void);
+	unsigned int ide_clock = TIMING_MARGIN(tangox_get_sysclock() / 1000000); /* in MHz */
+#endif
+	didx = drive->select.b.unit;
+	newflag = 0;
+	spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2) {
+		/*
+		 * setup timing for Multi-word DMA
+		 */
+		mode = speed - XFER_MW_DMA_0;
+		printk("%s: set to Multi-word DMA mode %d\n", drive->name,
+		       mode);
+
+		/* fast timing for PIO, prefetch enable */
+		newflag = 0x05;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    CalcRegValTiming_PIO_DMA(&(j2_dma_timings[mode]), ide_clock));
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    s_dma_tim[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    s_udma_tim1[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    s_udma_tim2[mode]);
+#endif
+
+	} 
+#endif
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_UDMA
+	else if (speed >= XFER_UDMA_0 && speed <= XFER_UDMA_7) {
+		unsigned int val;
+
+		/*
+		 * setup timing for Ultra DMA
+		 */
+		mode = speed - XFER_UDMA_0;
+		printk("%s: set to Ultra DMA mode %d\n", drive->name, mode);
+
+		newflag = 0x00;
+
+		/* enable Ultra DMA */
+		val = gbus_readl(REG_BASE_host_interface + IDECTRL_udmactl);
+		val |= (didx == 0) ? 0x01 : 0x02;
+		gbus_writel(REG_BASE_host_interface + IDECTRL_udmactl, val);
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    s_udma_tim1_alt[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    s_udma_tim2_alt[mode]);
+#endif
+ 	}
+#endif
+	else {
+		printk("%s: unknown speed to be set %d\n", drive->name, speed);
+	}
+
+	ctrlreg = gbus_readl(REG_BASE_host_interface + IDECTRL_pri_idectl);
+	ctrlreg &= ~(didx == 0 ? 0xf : 0xf0);
+	ctrlreg |= newflag << (didx * 4);
+	gbus_writel(REG_BASE_host_interface + IDECTRL_pri_idectl, ctrlreg);
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+}
+
+
+static void tangox_hw_setup(hw_regs_t *hw, unsigned long data_port,
+		     unsigned long ctrl_port)
+{
+	int i;
+	unsigned long reg;
+
+	memset(hw, 0, sizeof (*hw));
+
+	/* setup io_ports */
+	reg = data_port;
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += 4;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+}
+
+
+static const struct ide_port_info tangox_bmide_port_info = {
+	.host_flags		= IDE_HFLAG_POST_SET_MODE |
+				  IDE_HFLAG_NO_DMA | /* no SFF-style DMA */
+				  IDE_HFLAG_NO_IO_32BIT |
+				  IDE_HFLAG_UNMASK_IRQS |
+				  IDE_HFLAG_RQSIZE_256,
+		.pio_mask	= ATA_PIO4,
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+		.mwdma_mask	= ATA_MWDMA2,
+		.udma_mask	= ATA_UDMA5,
+#endif
+};
+
+/*
+ * init function, ide controller is registred here
+ */
+extern int tangox_bmide_enabled(void);
+
+int __init tangox_bmide_init(void)
+{
+	ide_hwif_t *hwif;
+	hw_regs_t hw;
+	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
+	if (!tangox_bmide_enabled()) {
+		printk(KERN_NOTICE PFX "bmide support is disabled\n");
+		return -1;
+	}
+
+	/* Enable bus master IDE interface */
+	WR_HOST_REG32(IDECTRL_pri_idectl, 0x8400);
+
+	/* no skew : normal IORDY, normal data */
+	WR_HOST_REG32(IDECTRL_idesrc, 0);
+
+	/* Enable non-PRD mode */
+	WR_HOST_REG32(IDECTRL_bmic, 0x4);
+
+	/*
+	 * set register offset for our controller
+	 */
+	tangox_hw_setup(&hw, REG_BASE_host_interface_BMIDE,
+			REG_BASE_host_interface + IDECTRL_pri_ctrlblock);
+	/*
+	 * Tango   has   two   interrupts   for   IDE   controller   :
+	 * IRQ_IDECTRL_IDE,  IRQ_IDECTRL_IDEDMA
+	 *
+	 * IRQ_IDECTRL_IDEDMA is to be used for DMA transfer but it is
+	 * almost same with IRQ_IDECTRL_IDE interrupt.  Tango triggers
+	 * IDEDMA interrupt  after DMA FIFO  is flushed, and  it stays
+	 * high   until  BMIS   register  bit   2  is   cleared.   Use
+	 * IRQ_IDECTRL_IDE interrupt for both of PIO and DMA.
+	 */
+	hw.irq = IRQ_IDECTRL_IDE;
+
+	/*
+	 * register our controller
+	 */
+	hwif = ide_find_port(hw.io_ports[IDE_DATA_OFFSET]);
+	ide_init_port_hw(hwif, &hw);
+
+	printk(KERN_INFO "%s: SMP863x/SMP865x Bus Mastering IDE controller\n", hwif->name);
+
+	/*
+	 * fill controller callbacks
+	 */
+
+	/* set up local I/O function entry points */
+	hwif->INB = tangox_bmide_inb;
+	hwif->INW = tangox_bmide_inw;
+	hwif->INSW = tangox_bmide_insw;
+	hwif->OUTB = tangox_bmide_outb;
+	hwif->OUTW = tangox_bmide_outw;
+	hwif->OUTBSYNC = tangox_bmide_outbsync;
+	hwif->OUTSW = tangox_bmide_outsw;
+	hwif->cable_detect = tangox_bmide_cable_detect;
+	hwif->set_pio_mode = tangox_bmide_set_pio_mode;
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	/* dma callbacks */
+	hwif->dma_host_set = tangox_bmide_dma_host_set;
+
+	hwif->ide_dma_test_irq = tangox_bmide_dma_test_irq;
+	hwif->dma_lost_irq = tangox_bmide_dma_lostirq;
+	hwif->dma_timeout = tangox_bmide_dma_timeout;
+
+	hwif->dma_setup = tangox_dma_setup;
+	hwif->dma_exec_cmd = tangox_dma_exec_cmd;
+	hwif->dma_start = tangox_dma_start;
+	hwif->ide_dma_end = tangox_bmide_dma_end;
+
+	hwif->dma_command = REG_BASE_host_interface + IDECTRL_bmic;
+	hwif->dma_status = REG_BASE_host_interface + IDECTRL_bmis;
+
+	hwif->set_dma_mode = tangox_bmide_set_dma_mode;
+
+	em86xx_mbus_init();
+#endif
+	idx[0] = hwif->index;
+	ide_device_add(idx, &tangox_bmide_port_info);
+	return 0;
+}
+
+static void __exit tangox_bmide_exit(void)
+{
+        return;
+}
+
+
+module_init(tangox_bmide_init);
+#ifdef MODULE
+module_exit(tangox_bmide_exit);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SMP86xx BM IDE driver");
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+/* The following is for runtime calculation of register value based on the mode and given
+ * system frequency by Ivan K. */
+static unsigned int CalcRegValTiming_PIO_DMA(j2_tim_pio_dma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int cycle_clks;	// ide clocks / cycle
+	unsigned int active_clks;	// ide clocks for active strobe
+	unsigned int recov_clks;	// ide clocks for recovery
+	unsigned int setup_clks;	// ide clocks for setup
+	unsigned int hold_clks;	// ide clocks for hold
+
+	// pio_timings in ns
+	cycle_clks	= (ide_clock * t->cycle_time)/1000;
+	active_clks	= (ide_clock * t->active_time)/1000;
+	recov_clks	= (ide_clock * t->recovery_time)/1000;
+	setup_clks	= (ide_clock * t->setup_time)/1000;
+	hold_clks	= (ide_clock * t->hold_time)/1000;
+
+	if(cycle_clks>0x7F) {
+		cycle_clks = 0x7F;
+	}
+	
+	if(active_clks>0x3F) {
+		active_clks = 0x3F;
+	}
+
+	if(recov_clks>0x3F) {
+		recov_clks = 0x3F;
+	}
+
+	if(setup_clks>0xF) {
+		setup_clks = 0xF;
+	}
+	
+	if(hold_clks>0x7) {
+		setup_clks = 0x7;
+	}
+	
+	dwRet	= (1<<31) | (cycle_clks<<24) | (active_clks<<16) | (recov_clks<<8) | (setup_clks<<4) | (hold_clks);
+
+	return dwRet;
+}
+
+static unsigned int CalcRegValTiming1_UDMA(j2_tim_udma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int t_zah,t_mli,t_ack,t_env,t_rp,t_cyc;
+
+	// pio_timings in ns
+	t_zah	= (ide_clock * t->t_zah)/1000;
+	t_mli	= (ide_clock * t->t_mli)/1000;
+	t_ack	= (ide_clock * t->t_ack)/1000;
+	t_env	= (ide_clock * t->t_env)/1000;
+	t_rp	= (ide_clock * t->t_rp) /1000;
+	t_cyc	= (ide_clock * t->t_cyc)/1000;
+
+	if ( t_zah > 0x0F ) {
+		t_zah = 0x0F;
+	}
+	if ( t_mli > 0x0F ) {
+		t_mli = 0x0F;
+	}
+	if ( t_ack > 0x0F ) {
+		t_ack = 0x0F;
+	}
+	if ( t_env > 0x0F) {
+		t_env = 0x0F;
+	}
+	if ( t_rp > 0x3F ) {
+		t_rp = 0x3F;
+	}
+	if ( t_cyc > 0x3F ) {
+		t_cyc = 0x3F;
+	}
+	
+	dwRet	= (t_zah<<28) | (t_mli<<24) | (t_ack<<20) | (t_env<<16) | (t_rp<<8) | (t_cyc);
+
+	return dwRet;
+}
+
+static unsigned int CalcRegValTiming2_UDMA(j2_tim_udma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int t_cvh,t_cvs;
+	
+	// pio_timings in ns
+	t_cvh	= (ide_clock * t->t_cvh)/1000;
+	t_cvs	= (ide_clock * t->t_cvs)/1000;
+
+	if ( t_cvh > 0x03 ) {
+		t_cvh = 0x03;
+	}
+	if ( t_cvs > 0x3F ) {
+		t_cvs = 0x3F;
+	}
+
+	dwRet	= (t_cvh<<8) | (t_cvs);
+
+	return dwRet;
+}
+#endif /* CONFIG_RUNTIME_CLK_CALC */
+
diff -Naur linux-2.6.25.8/drivers/ide/tangox/tangox-ide.h linux-2.6.25.8-clean/drivers/ide/tangox/tangox-ide.h
--- linux-2.6.25.8/drivers/ide/tangox/tangox-ide.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/ide/tangox/tangox-ide.h	2008-06-26 14:59:56.000000000 -0400
@@ -0,0 +1,24 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGOX_IDE_H
+#define __TANGOX_IDE_H
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2api.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3api.h>
+#endif
+
+#endif /* __TANGOX_IDE_H */
+
diff -Naur linux-2.6.25.8/drivers/ide/tangox/tangox-pbide.c linux-2.6.25.8-clean/drivers/ide/tangox/tangox-pbide.c
--- linux-2.6.25.8/drivers/ide/tangox/tangox-pbide.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/ide/tangox/tangox-pbide.c	2008-06-26 14:59:56.000000000 -0400
@@ -0,0 +1,548 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * driver/ide/tangox/tangox_pbide.c
+ * TANGOX PB IDE driver
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+#include "tangox-ide.h"
+
+extern int tangox_isaide_irq_map(void);
+extern int tangox_isaide_enabled(void);
+extern int tangox_isaide_cs_select(void);
+extern int tangox_isaide_timing_slot(void);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SMP86xx PB IDE driver");
+
+static unsigned long g_regbase_read, g_regbase_write;
+
+/*
+ * io helpers for PIO access
+ */
+static void tangox_pbide_outb(u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_pbide_outw(u16 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_pbide_outbsync(ide_drive_t *drive, u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static u8 tangox_pbide_inb(unsigned long port)
+{
+	u8 val;
+
+	val = ((u8)(gbus_readw(port) & 0xff));
+	return val;
+}
+
+static u16 tangox_pbide_inw(unsigned long port)
+{
+	u16 val;
+
+	val = ((u16)(gbus_readw(port) & 0xffff));
+	return val;
+}
+
+static void tangox_pbide_insw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		*(u16 *)addr = (u16)(gbus_readw(port) & 0xffff);
+		addr += 2;
+	}
+}
+
+static void tangox_pbide_outsw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		gbus_writew(port, *(u16 *)addr);
+		addr += 2;
+	}
+}
+
+//
+// data structure initialization
+//
+static void tangox_pbide_init_hwif_ports(hw_regs_t *hw, unsigned long data_port, 
+					unsigned long ctrl_port, int *irq)
+{
+	int i;
+	unsigned long reg;
+
+	memset(hw, 0, sizeof(*hw));
+
+	// setup io_ports
+	for (i = IDE_DATA_OFFSET, reg = data_port; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += 4;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+	hw->dma = NO_DMA;
+
+	if (irq) 
+		*irq = tangox_isaide_irq_map();
+}
+
+/*
+ * tangox_pbide_tune_drive
+ */
+static void tangox_pbide_tune_drive(ide_drive_t *drive, u8 pio)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+
+        if (pio == 255)
+                pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+        hwif->speedproc(drive, pio + XFER_PIO_0);
+}
+
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX_DMA
+static int tangox_pbide_dma_off_quietly(ide_drive_t *drive)
+{
+        drive->using_dma = 0;
+        return 0;
+}
+
+static int tangox_pbide_dma_test_irq(ide_drive_t *drive)
+{
+        return 1;
+}
+
+static void tangox_pbide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+        /* issue  cmd to  drive,  and register  interrupt handler  for
+         * command completion */
+        //ide_execute_command(drive, command, &ide_dma_intr, (2 * WAIT_CMD), NULL);
+}
+
+static void tangox_pbide_dma_start(ide_drive_t *drive)
+{
+	return;
+}
+
+static int tangox_pbide_dma_lostirq(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_timeout(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_host_on(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_host_off(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_on(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+
+        if (hwif->ide_dma_host_on)
+                hwif->ide_dma_host_on(drive);
+
+        printk("IDE: DMA enabled for %s%s\n",
+                drive->media == ide_disk ? "ATA DISK " :
+                (drive->media == ide_cdrom ? "ATAPI CDROM " : ""),
+                drive->name);
+        drive->using_dma = 1;
+        return 0;
+}
+
+/*
+ * Calculate the peripheral bus timing needed for the register used by IDE
+ * devices.
+ */
+
+/* 
+ * The tables bellows use indices as Multi-word DMA 2, Multi-word DMA 1,
+ * Multi-word DMA 0, PIO 4, PIO 3, PIO 2, PIO 1, and PIO 0 (From 0 to 7, 
+ * respectively).
+ */
+
+/* For storing value pair */
+typedef struct {
+	unsigned char x;
+	unsigned char y;
+} value_pair;
+
+/* Table used for calculate Ta and Tb */
+static const value_pair tab_values[] = {
+	{3,0}, {5,0}, {7,2}, {3,0}, {5,0}, {5,0}, {7,2}, {10,4}
+};
+
+/* Table used for calculate Tc */
+static const value_pair tc_values[] = {
+	{13,8}, {19,11}, {60,41}, {10,5}, {12,6}, {14,8}, {17,11}, {23,15}
+};
+
+/* Table used for calculate Td */
+static const value_pair td_values[] = {
+	{1,100}, {1,100}, {3,200}, {1,100}, {1,100}, {1,100}, {3,200}, {5,250}
+};
+
+/* 
+ * Calculate the required timing for setting up peripheral bus timing register.
+ *
+ * Input: sysclk = system clock rate (in MHz)
+ *        mode = IDE mode (0-2: Multiword DMA mode 2-0, 3-7: PIO mode 4-0)
+ * Return: 0 = Error
+ *         else = value for setting up the timing register
+ */
+static unsigned long get_pb_ide_timing(unsigned int sysclk, int mode)
+{
+	unsigned char ta = 0;
+	unsigned char tb = 0;
+	unsigned char tc = 0;
+	unsigned char td = 0;
+	long temp = 0;
+	const value_pair *val_ptr = (const value_pair *)0;
+
+	/* The formula is only effective between 100-240MHz */
+	if ((sysclk < 100) && (sysclk > 240))
+		return(0);
+	else if ((mode < 0) && (mode > 7)) /* Mode index is 0-7 only */
+		return(0);
+
+	/* (x, y) = tab_values[mode] */
+	/* (Ta + Tb) = Temp = (ceiling((sysclk - 100) * x / 140) + y) */
+	/* Ta = ceiling(Temp / 2) */
+	/* Tb = (Temp / 2) */
+	val_ptr = &tab_values[mode];
+	temp = ((sysclk - 100) * val_ptr->x) / 140;
+	if ((temp * 140) < ((sysclk - 100) * val_ptr->x))
+		temp++;
+	temp += val_ptr->y;
+	tb = ta = (unsigned char)((temp >> 1) & 0xff);
+	if (temp & 0x1)
+		ta++;
+
+	/* (x, y) = tc_values[mode] */
+	/* Tc = (ceiling((sysclk - 100) * x / 140) + y) */
+	val_ptr = &tc_values[mode];
+	tc = (unsigned char)(((sysclk - 100) * val_ptr->x) / 140) & 0xff;
+	if ((tc * 140) < ((sysclk - 100) * val_ptr->x))
+		tc++;
+	tc += val_ptr->y;
+
+	/* (x, y) = td_values[mode] */
+	/* Td = ceiling(sysclk + y - 400) * x / y) */
+	val_ptr = &td_values[mode];
+	if ((temp = (sysclk + val_ptr->y) - 400) < 0)
+		td = 0; /* It's possible that Td < 0, so we set it to 0 */
+	else {
+		td = (unsigned char)(((temp * val_ptr->x) / val_ptr->y) & 0xff);
+		if ((td * val_ptr->y) < (temp * val_ptr->x))
+			td++;
+	}
+	return((td << 24) | (tc << 16) | (tb << 8) | ta);
+}
+
+ide_startstop_t tangox_pbide_dma_intr(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq = HWGROUP(drive)->rq;
+
+	hwif->ide_dma_end(drive);
+
+	ide_end_request(drive, 1,rq->nr_sectors);
+
+	return ide_stopped;
+}
+
+static int tangox_pbide_rwdma(ide_drive_t *drive, int read, struct request *rq)
+{
+	unsigned long size = 0;
+	unsigned long addr = 0;
+
+        ide_hwif_t *hwif = HWIF(drive);
+        struct scatterlist *sg = hwif->sg_table;
+
+        dma_map_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+
+	if (hwif->sg_nents > 2) { /* this shouldn't happen since we limited rqsize=16 for now*/
+      		printk("cannot handle multiple transfer yet. sg_nents=0x%x\n", hwif->sg_nents);
+                dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	        return 1;
+	}
+
+	// setup switchbox and wait for its readiness
+        if (em86xx_mbus_alloc_dma(SBOX_IDEFLASH,  1, &g_regbase_read, NULL, 1)) {
+                printk("fail to alloc read dma, fallback to pio.\n");
+		return 1;
+        }
+
+        /* try to setup dma write channel */
+        if (em86xx_mbus_alloc_dma(SBOX_IDEFLASH,  0, &g_regbase_write, NULL, 1)) {
+                printk("fail to alloc write dma, fallback to pio.\n");
+		em86xx_mbus_free_dma(g_regbase_read, SBOX_IDEFLASH);
+		return 1;
+        }
+
+	// setup handler
+	if (drive->media == ide_disk)
+		ide_set_handler(drive, &tangox_pbide_dma_intr, 2 * WAIT_CMD, NULL);
+
+        addr = sg_dma_address(sg);
+       	size = sg_dma_len(sg);
+
+	if (hwif->sg_nents == 1) {
+
+		/* perform a single (linear/rectangle) transfer */
+
+	        // setup PB automode registers
+	        gbus_writel(REG_BASE_host_interface + PB_automode_start_address, 0);
+	        gbus_writel(REG_BASE_host_interface + PB_automode_control,
+				0x00140000 | ((read ? 1 : 0) << 16) | (size >> 1));
+
+	        if (read)
+        	        dma_cache_inv((unsigned int)phys_to_virt(addr), size);
+	        else
+	                dma_cache_wback_inv((unsigned int)phys_to_virt(addr), size);
+
+        	em86xx_mbus_setup_dma(read ? g_regbase_read : g_regbase_write,
+                		addr, size, NULL, NULL, 1);
+	}
+	else { 
+		/* perform a double transfer */
+		unsigned int addr1 = 0;
+		unsigned int size1 = 0;
+
+		sg = &hwif->sg_table[1];
+
+	        addr1 = sg_dma_address(sg);
+	       	size1 = sg_dma_len(sg);
+
+	        // setup PB automode registers
+	        gbus_writel(REG_BASE_host_interface + PB_automode_start_address, 0);
+	        gbus_writel(REG_BASE_host_interface + PB_automode_control,
+				0x00140000 | ((read ? 1 : 0) << 16) | ((size+size1) >> 1));
+
+                if (read) {
+                        dma_cache_inv((unsigned int)phys_to_virt(addr), size);
+                        dma_cache_inv((unsigned int)phys_to_virt(addr1), size1);
+		} else {
+                        dma_cache_wback_inv((unsigned int)phys_to_virt(addr), size);
+                        dma_cache_wback_inv((unsigned int)phys_to_virt(addr1), size1);
+		}
+
+                mbus_setup_dma_double(read ? g_regbase_read : g_regbase_write, 
+				addr, size, addr1, size1, 1);
+	}
+
+	if (drive->media == ide_disk) {
+		// send IDE command
+		HWIF(drive)->OUTB(read ? (drive->addressing ? WIN_READDMA_EXT : WIN_READDMA) : 
+			(drive->addressing ? WIN_WRITEDMA_EXT : WIN_WRITEDMA), IDE_COMMAND_REG);
+	}
+
+	return 0;
+}
+
+static int tangox_pbide_dma_setup(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        struct request *rq;
+        int iswrite;
+
+        drive->waiting_for_dma = 1;
+        rq = HWGROUP(drive)->rq;
+        iswrite = (rq_data_dir(rq) == WRITE);
+        hwif->sg_dma_direction = iswrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+	
+	// this will do the merge
+	ide_map_sg(drive, rq);
+
+        return tangox_pbide_rwdma(drive, !iswrite, rq);
+}
+
+static int tangox_ide_config_drive_for_dma(ide_drive_t *drive, int mode)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        int config_allows_dma = 0;
+        struct hd_driveid *id = drive->id;
+        int speed;
+
+        // enable DMA for CDROM by default
+        if (drive->media == ide_disk || drive->media == ide_cdrom)
+                config_allows_dma = 1;
+
+        if (id && (id->capability & 1) && hwif->autodma && config_allows_dma) {
+                speed = ide_dma_speed(drive, mode);
+
+                /* For CDROM, we do the max. MDMA mode 2 */
+		//if ((speed > XFER_MW_DMA_2) && (drive->media == ide_cdrom))
+		//	speed = XFER_MW_DMA_2;
+
+                if (speed >= XFER_MW_DMA_0) {
+                        if (hwif->speedproc)
+                                hwif->speedproc(drive, speed);
+                        ide_config_drive_speed(drive, speed);
+                        return hwif->ide_dma_on(drive);
+                }
+        }
+
+        return hwif->ide_dma_off_quietly(drive);
+}
+
+static int tangox_pbide_dma_check(ide_drive_t *drive)
+{
+	return tangox_ide_config_drive_for_dma(drive, 0);
+}
+
+static void tangox_pbide_tune_chipset_drive(int drive, int speed, int verbose)
+{
+	extern unsigned long tangox_get_sysclock(void);
+	int mode = speed & 0x0f;
+	unsigned int timing;
+	
+	if (speed >= XFER_PIO_0 && speed <= XFER_PIO_4)
+		mode -= 8;
+	else if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2)
+		mode += 5;
+	else
+		return;	
+
+	// get_pb_ide_timing() receives mode in reversed order
+	//   PIO : 7-3
+	//   Multi-word DMA : 2-0
+	mode = 7 - mode;
+	timing = get_pb_ide_timing(tangox_get_sysclock() * 11 / (10*1000000), mode);
+	gbus_writel(REG_BASE_host_interface + PB_timing_slot(tangox_isaide_timing_slot()), timing);
+}
+
+static int tangox_pbide_tune_chipset(ide_drive_t *drive, u8 speed)
+{
+	tangox_pbide_tune_chipset_drive(drive->select.b.unit, speed, 1);
+
+	return ide_config_drive_speed(drive, speed);
+}
+
+static int tangox_pbide_dma_end_io(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg = hwif->sg_table;
+	struct request *rq = HWGROUP(drive)->rq;
+
+	int stat = em86xx_mbus_wait(rq->cmd == READ ? g_regbase_read : 
+					g_regbase_write, SBOX_IDEFLASH);
+
+	dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+
+	/* Free up MBUS channel */
+	em86xx_mbus_free_dma(g_regbase_read, SBOX_IDEFLASH);
+	em86xx_mbus_free_dma(g_regbase_write, SBOX_IDEFLASH);
+	return((stat != 0) ? 1 : 0);
+}
+
+static int tangox_pbide_dma_end(ide_drive_t *drive)
+{
+	int status;
+
+	drive->waiting_for_dma = 0;
+	status = tangox_pbide_dma_end_io(drive);
+	return(status);
+}
+#endif
+
+//
+// initialize IDE driver
+//
+int __init tangox_pbide_init(void)
+{
+	int index, i;
+	ide_hwif_t *hwif;
+	hw_regs_t hw;
+#ifdef MODULE
+        ide_drive_t *drive = NULL;
+#endif
+
+	if (tangox_isaide_enabled() == 0)
+		return 0;
+	else
+		tangox_pbide_init_hwif_ports(&hw, 
+			REG_BASE_host_interface_ISAIDE(tangox_isaide_cs_select()), 0, &hw.irq);
+
+       	index = ide_register_hw(&hw, &hwif);
+	printk("%s: SMP863x/SMP865x PB IDE controller.\n", hwif->name);
+
+	// initialize ide_hwifs data structure
+	// supports only one interface
+	for (i = index; i < index + 1; ++i) {
+		// register DMA handler
+		hwif = &ide_hwifs[i];
+
+	        /* set up local I/O function entry points */
+	        hwif->INB = tangox_pbide_inb;
+	        hwif->INW = tangox_pbide_inw;
+	        hwif->INSW = tangox_pbide_insw;
+	        hwif->OUTB = tangox_pbide_outb;
+	        hwif->OUTW = tangox_pbide_outw;
+	        hwif->OUTBSYNC = tangox_pbide_outbsync;
+	        hwif->OUTSW = tangox_pbide_outsw;
+
+		hwif->rqsize = 16; 
+
+	    if (!noautodma) {
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX_DMA 
+		hwif->autodma = 1;
+		hwif->atapi_dma = 1;
+		hwif->ultra_mask = 0x00;	// dpbble all Ultra DMA
+		hwif->mwdma_mask = 0x07;	// enable all Multi-word DMA
+		hwif->swdma_mask = 0x80;	// dpbble all Single-word DMA
+
+	        hwif->dma_setup = tangox_pbide_dma_setup;
+	        hwif->dma_exec_cmd = tangox_pbide_dma_exec_cmd;
+	        hwif->dma_start = tangox_pbide_dma_start;
+		hwif->ide_dma_end = tangox_pbide_dma_end;
+
+		hwif->ide_dma_check = tangox_pbide_dma_check;
+		hwif->ide_dma_on = tangox_pbide_dma_on;
+		hwif->ide_dma_off_quietly = tangox_pbide_dma_off_quietly;
+		hwif->ide_dma_test_irq = tangox_pbide_dma_test_irq;
+		hwif->ide_dma_host_on = tangox_pbide_dma_host_on;
+		hwif->ide_dma_host_off = tangox_pbide_dma_host_off;
+		hwif->ide_dma_lostirq = tangox_pbide_dma_lostirq;
+		hwif->ide_dma_timeout = tangox_pbide_dma_timeout;
+	      	hwif->tuneproc = tangox_pbide_tune_drive;
+		hwif->speedproc = tangox_pbide_tune_chipset;
+#endif
+	    }
+	}
+
+	return 0;
+}
+
+void __exit tangox_pbide_exit(void)
+{
+        return;
+}
+
+#ifdef MODULE
+module_init(tangox_pbide_init);
+module_exit(tangox_pbide_exit);
+#endif
+
diff -Naur linux-2.6.25.8/drivers/media/video/Kconfig linux-2.6.25.8-clean/drivers/media/video/Kconfig
--- linux-2.6.25.8/drivers/media/video/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/media/video/Kconfig	2008-07-14 17:27:12.000000000 -0400
@@ -730,6 +730,8 @@
 
 if V4L_USB_DRIVERS && USB
 
+source "drivers/media/video/hdpvr/Kconfig"
+
 source "drivers/media/video/pvrusb2/Kconfig"
 
 source "drivers/media/video/em28xx/Kconfig"
diff -Naur linux-2.6.25.8/drivers/media/video/Makefile linux-2.6.25.8-clean/drivers/media/video/Makefile
--- linux-2.6.25.8/drivers/media/video/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/media/video/Makefile	2008-07-14 17:26:49.000000000 -0400
@@ -125,6 +125,8 @@
 obj-$(CONFIG_USB_PWC)           += pwc/
 obj-$(CONFIG_USB_ZC0301)        += zc0301/
 
+obj-$(CONFIG_VIDEO_HDPVR)       += hdpvr/
+
 obj-$(CONFIG_USB_IBMCAM)        += usbvideo/
 obj-$(CONFIG_USB_KONICAWC)      += usbvideo/
 obj-$(CONFIG_USB_VICAM)         += usbvideo/
diff -Naur linux-2.6.25.8/drivers/media/video/hdpvr/Kconfig linux-2.6.25.8-clean/drivers/media/video/hdpvr/Kconfig
--- linux-2.6.25.8/drivers/media/video/hdpvr/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/media/video/hdpvr/Kconfig	2008-07-14 17:25:44.000000000 -0400
@@ -0,0 +1,10 @@
+
+config VIDEO_HDPVR
+	tristate "Hauppauge HD PVR support"
+	depends on VIDEO_DEV
+	---help---
+	  This is a video4linux driver for Hauppauge's HD PVR USB device.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hdpvr
+
diff -Naur linux-2.6.25.8/drivers/media/video/hdpvr/Makefile linux-2.6.25.8-clean/drivers/media/video/hdpvr/Makefile
--- linux-2.6.25.8/drivers/media/video/hdpvr/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/media/video/hdpvr/Makefile	2008-07-14 17:25:44.000000000 -0400
@@ -0,0 +1,7 @@
+hdpvr-objs	:= hdpvr-control.o hdpvr-core.o hdpvr-video.o
+
+obj-$(CONFIG_VIDEO_HDPVR) += hdpvr.o
+
+EXTRA_CFLAGS += -Idrivers/media/video
+
+EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
diff -Naur linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr-control.c linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr-control.c
--- linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr-control.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr-control.c	2008-07-14 17:25:44.000000000 -0400
@@ -0,0 +1,164 @@
+/*
+ * Hauppage HD PVR USB driver - video 4 linux 2 interface
+ *
+ * Copyright (C) 2008      Janne Grunau (j@jannau.net)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/mutex.h>
+
+#include "hdpvr.h"
+
+
+int hdpvr_config_call(struct hdpvr_device *dev, uint value, u8 valbuf)
+{
+	int ret;
+	char request_type = 0x38, snd_request = 0x01;
+	char *buf = kmalloc(1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	*buf = valbuf;
+	ret = usb_control_msg(dev->udev,
+			      usb_sndctrlpipe(dev->udev, 0),
+			      snd_request, 0x00 | request_type,
+			      value, CTRL_DEFAULT_INDEX,
+			      buf, 1, 10000);
+
+	hdpvr_info("config call request returned %d", ret);
+
+	return ret < 0 ? ret : 0;
+}
+
+struct hdpvr_video_info *get_video_info(struct hdpvr_device *dev)
+{
+	u8 *buffer;
+	struct hdpvr_video_info *vidinf = NULL;
+#ifdef HDPVR_DEBUG
+	char print_buf[15];
+#endif
+	int ret;
+
+	buffer = kzalloc(5, GFP_KERNEL);
+	if (!buffer) {
+		err("out of memory");
+		goto err;
+	}
+	vidinf = kzalloc(sizeof(struct hdpvr_video_info), GFP_KERNEL);
+	if (!vidinf) {
+		err("out of memory");
+		goto err;
+	}
+
+	ret = usb_control_msg(dev->udev,
+			      usb_rcvctrlpipe(dev->udev, 0),
+			      0x81, 0x80 | 0x38,
+			      0x1400, 0x0003,
+			      buffer, 5,
+			      1000);
+	if (ret == 5) {
+		vidinf->width	= buffer[1] << 8 | buffer[0];
+		vidinf->height	= buffer[3] << 8 | buffer[2];
+		vidinf->fps	= buffer[4];
+	}
+
+#ifdef HDPVR_DEBUG
+	if (hdpvr_debug & MSG_INFO) {
+		print_bytes(print_buf, buffer, 5);
+		hdpvr_info("get video info returned: %d, %s", ret, print_buf);
+	}
+#endif
+
+	if (!vidinf->width || !vidinf->height || !vidinf->fps) {
+		kfree(vidinf);
+		vidinf = NULL;
+	}
+err:
+	kfree(buffer);
+	return vidinf;
+}
+
+int get_input_lines_info(struct hdpvr_device *dev)
+{
+	u8 buffer[3];
+#ifdef HDPVR_DEBUG
+	char print_buf[9];
+#endif
+	int ret;
+
+	ret = usb_control_msg(dev->udev,
+			      usb_rcvctrlpipe(dev->udev, 0),
+			      0x81, 0x80 | 0x38,
+			      0x1800, 0x0003,
+			      buffer, 3,
+			      1000);
+
+#ifdef HDPVR_DEBUG
+	if (hdpvr_debug & MSG_INFO) {
+		print_bytes(print_buf, buffer, 3);
+		hdpvr_info("get input lines info returned: %d, %s", ret,
+			   print_buf);
+	}
+#endif
+	return buffer[1] << 8 | buffer[0];
+}
+
+
+int hdpvr_set_bitrate(struct hdpvr_device *dev)
+{
+	int ret;
+	char *buf;
+
+	buf = kzalloc(4, GFP_KERNEL);
+	if (!buf) {
+		err("out of memory");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	buf[0] = dev->options.bitrate;
+	buf[2] = dev->options.peak_bitrate;
+
+	ret = usb_control_msg(dev->udev,
+			      usb_sndctrlpipe(dev->udev, 0),
+			      0x01, 0x38, CTRL_BITRATE_VALUE,
+			      CTRL_DEFAULT_INDEX, buf, 4, 1000);
+
+err:
+	return ret;
+}
+
+int hdpvr_set_options(struct hdpvr_device *dev)
+{
+       hdpvr_config_call(dev, CTRL_VIDEO_STD_TYPE, dev->options.video_std);
+
+       hdpvr_config_call(dev, CTRL_VIDEO_INPUT_VALUE,
+			 dev->options.video_input+1);
+       hdpvr_config_call(dev, CTRL_AUDIO_INPUT_VALUE,
+			 dev->options.audio_input+1);
+
+       hdpvr_set_bitrate(dev);
+       hdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,
+			 dev->options.bitrate_mode);
+       hdpvr_config_call(dev, CTRL_GOP_MODE_VALUE, dev->options.gop_mode);
+
+       hdpvr_config_call(dev, CTRL_BRIGHTNESS, dev->options.brightness);
+       hdpvr_config_call(dev, CTRL_CONTRAST,   dev->options.contrast);
+       hdpvr_config_call(dev, CTRL_HUE,        dev->options.hue);
+       hdpvr_config_call(dev, CTRL_SATURATION, dev->options.saturation);
+       hdpvr_config_call(dev, CTRL_SHARPNESS,  dev->options.sharpness);
+
+       return 0;
+}
diff -Naur linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr-core.c linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr-core.c
--- linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr-core.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr-core.c	2008-07-14 17:25:44.000000000 -0400
@@ -0,0 +1,436 @@
+/*
+ * Hauppage HD PVR USB driver
+ *
+ * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2008      Janne Grunau (j@jannau.net)
+ * Copyright (C) 2008      John Poet
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/uaccess.h>
+#include <asm/atomic.h>
+#include <linux/usb.h>
+#include <linux/mutex.h>
+
+#include <linux/videodev2.h>
+#include <media/v4l2-dev.h>
+
+#include "hdpvr.h"
+
+static int video_nr[HDPVR_MAX] = {[0 ... (HDPVR_MAX - 1)] = UNSET};
+module_param_array(video_nr, int, NULL, 0);
+MODULE_PARM_DESC(video_nr, "video device number (-1=Auto)");
+
+/* holds the number if currently registered devices */
+static atomic_t dev_nr = ATOMIC_INIT(-1);
+
+static int skip_device_init;
+module_param(skip_device_init, bool, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(skip_device_init, "skip the not yet working device init");
+
+int hdpvr_debug;
+module_param(hdpvr_debug, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(hdpvr_debug, "enable debugging output");
+
+uint default_video_input = HDPVR_VIDEO_INPUTS;
+module_param(default_video_input, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(default_video_input, "default video input: 0=Component / "
+		 "1=S-Video / 2=Composite");
+
+uint default_audio_input = HDPVR_AUDIO_INPUTS;
+module_param(default_audio_input, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(default_audio_input, "default audio input: 0=RCA back / "
+		 "1=RCA front / 2=S/PDIF");
+
+
+/* table of devices that work with this driver */
+static struct usb_device_id hdpvr_table [] = {
+	{ USB_DEVICE(HD_PVR_VENDOR_ID, HD_PVR_PRODUCT_ID) },
+	{ }					/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, hdpvr_table);
+
+
+#define to_hdpvr_dev(d) container_of(d, struct hdpvr_device, kref)
+
+
+void hdpvr_delete(struct kref *kref)
+{
+	struct hdpvr_device *dev = to_hdpvr_dev(kref);
+
+	hdpvr_free_buffers(dev);
+
+	usb_put_dev(dev->udev);
+	kfree(dev);
+}
+
+#ifdef HDPVR_DEBUG
+void print_bytes(char *string, unsigned char *buf, size_t len)
+{
+
+	int i, pos = 0;
+	for (i = 0; i < len; i++)
+		pos += snprintf(string+pos, 4, "%02x ", buf[i]);
+
+	string[pos-1] = '\0';
+
+	return;
+}
+#endif
+
+static void challenge(u8 *bytes)
+{
+	u64 *i64P, tmp64;
+	uint i, idx;
+
+	for (idx = 0; idx < 32; ++idx) {
+
+		if (idx & 0x3)
+			bytes[(idx >> 3) + 3] = bytes[(idx >> 2) & 0x3];
+
+		switch (idx & 0x3) {
+		case 0x3:
+			bytes[2] += bytes[3] * 4 + bytes[4] + bytes[5];
+			bytes[4] += bytes[(idx & 0x1) * 2] * 9 + 9;
+			break;
+		case 0x1:
+			bytes[0] *= 8;
+			bytes[0] += 7*idx + 4;
+			bytes[6] += bytes[3] * 3;
+			break;
+		case 0x0:
+			bytes[3 - (idx >> 3)] = bytes[idx >> 2];
+			bytes[5] += bytes[6] * 3;
+			for (i = 0; i < 3; i++)
+				bytes[3] *= bytes[3] + 1;
+			break;
+		case 0x2:
+			for (i = 0; i < 3; i++)
+				bytes[1] *= bytes[6] + 1;
+			for (i = 0; i < 3; i++) {
+				i64P = (u64 *)bytes;
+				tmp64 = le64_to_cpup(i64P);
+				tmp64 <<= bytes[7] & 0x0f;
+				*i64P += cpu_to_le64(tmp64);
+			}
+			break;
+		}
+	}
+}
+
+/* try to init the device like the windows driver */
+static int device_authorization(struct hdpvr_device *dev)
+{
+
+	int ret, retval = -ENOMEM;
+	char request_type = 0x38, rcv_request = 0x81;
+	size_t buf_size = 46;
+	char *buf;
+	char *response;
+#ifdef HDPVR_DEBUG
+	char *print_buf = kzalloc(5*buf_size+1, GFP_KERNEL);
+	if (!print_buf) {
+		err("Out of memory");
+		goto error;
+	}
+#endif
+
+	buf = kzalloc(buf_size, GFP_KERNEL);
+	if (!buf) {
+		err("Out of memory");
+		goto error;
+	}
+
+	ret = usb_control_msg(dev->udev,
+			      usb_rcvctrlpipe(dev->udev, 0),
+			      rcv_request, 0x80 | request_type,
+			      0x0400, 0x0003,
+			      buf, 46,
+			      10000);
+	if (ret != 46) {
+		err("unexpected answer of status request, len %d", ret);
+		goto error;
+	}
+#ifdef HDPVR_DEBUG
+	else {
+		print_bytes(print_buf, buf, 46);
+		hdpvr_info("Status request returned, len %d: %s", ret,
+			   print_buf);
+	}
+#endif
+	if (buf[1] != HDPVR_FIRMWARE_VERSION) {
+		err("wrong firmware version");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	response = kmalloc(8, GFP_KERNEL);
+	if (!response)
+		goto error;
+	memcpy(response, buf+38, 8);
+
+#ifdef HDPVR_DEBUG
+	print_bytes(print_buf, response, 8);
+	hdpvr_info("challenge: %s", print_buf);
+#endif
+	challenge(response);
+#ifdef HDPVR_DEBUG
+	print_bytes(print_buf, response, 8);
+	hdpvr_info(" response: %s", print_buf);
+#endif
+
+	msleep(100);
+	ret = usb_control_msg(dev->udev,
+			      usb_sndctrlpipe(dev->udev, 0),
+			      0xd1, 0x00 | request_type,
+			      0x0000, 0x0000,
+			      response, 8,
+			      10000);
+	kfree(response);
+	hdpvr_info("magic request returned %d", ret);
+
+	retval = ret != 8;
+error:
+	return retval;
+}
+
+static int hdpvr_device_init(struct hdpvr_device *dev)
+{
+	int retval = -ENOMEM, ret;
+	size_t buf_size = 10;
+	u8 *buf, *print_buf = NULL;
+	struct hdpvr_video_info *vidinf;
+
+	buf = kzalloc(buf_size, GFP_KERNEL);
+	if (!buf) {
+		err("Out of memory");
+		goto error;
+	}
+	print_buf = kzalloc(5*buf_size+1, GFP_KERNEL);
+	if (!print_buf) {
+		err("Out of memory");
+		goto error;
+	}
+
+	if (!skip_device_init && device_authorization(dev)) {
+		retval = -EFAULT;
+		goto error;
+	}
+
+	/* default options for init */
+	hdpvr_set_options(dev);
+
+	/* set filter options */
+	buf[0] = 0x03; buf[1] = 0x03; buf[2] = 0x00; buf[3] = 0x00;
+	ret = usb_control_msg(dev->udev,
+			      usb_sndctrlpipe(dev->udev, 0),
+			      0x01, 0x38,
+			      CTRL_LOW_PASS_FILTER_VALUE, CTRL_DEFAULT_INDEX,
+			      buf, 4,
+			      1000);
+	hdpvr_info("control request returned %d", ret);
+
+	vidinf = get_video_info(dev);
+	if (!vidinf)
+		hdpvr_info("no valid video signal or device init failed");
+	else
+		kfree(vidinf);
+
+	/* disable blind leds */
+	buf[0] = 0x1;
+	ret = usb_control_msg(dev->udev,
+			      usb_sndctrlpipe(dev->udev, 0),
+			      0xd4, 0x38,
+			      0, 0,
+			      buf, 1,
+			      1000);
+	hdpvr_info("control request returned %d", ret);
+
+	/* boost analog audio */
+	buf[0] = 0x0;
+	ret = usb_control_msg(dev->udev,
+			      usb_sndctrlpipe(dev->udev, 0),
+			      0xd5, 0x38,
+			      0, 0,
+			      buf, 1,
+			      1000);
+	hdpvr_info("control request returned %d", ret);
+
+	dev->status = STATUS_IDLE;
+	retval = 0;
+
+error:
+	kfree(buf);
+	kfree(print_buf);
+	return retval;
+}
+
+extern struct file_operations hdpvr_fops;
+
+static const struct hdpvr_options hdpvr_default_options = {
+	.video_std	= HDPVR_60HZ,
+	.video_input	= HDPVR_COMPONENT,
+	.audio_input	= HDPVR_RCA_BACK,
+	.bitrate	= 60, /* 6 mbps */
+	.peak_bitrate	= 90, /* 9 mbps */
+	.bitrate_mode	= HDPVR_CONSTANT,
+	.gop_mode	= HDPVR_SIMPLE_IDR_GOP,
+	.brightness	= 0x80,
+	.contrast	= 0x80,
+	.hue		= 0x80,
+	.saturation	= 0x80,
+	.sharpness	= 0x80,
+};
+
+static int hdpvr_probe(struct usb_interface *interface,
+		       const struct usb_device_id *id)
+{
+	struct hdpvr_device *dev;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	size_t buffer_size;
+	int i;
+	int retval = -ENOMEM;
+
+	/* allocate memory for our device state and initialize it */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		err("Out of memory");
+		goto error;
+	}
+	kref_init(&dev->kref);
+	mutex_init(&dev->io_mutex);
+	init_waitqueue_head(&dev->wait);
+
+	/* init video transfer queues */
+	INIT_LIST_HEAD(&dev->free_buff_list);
+	INIT_LIST_HEAD(&dev->rec_buff_list);
+
+	dev->options = hdpvr_default_options;
+
+	if (default_video_input < HDPVR_VIDEO_INPUTS)
+		dev->options.video_input = default_video_input;
+
+	if (default_audio_input < HDPVR_AUDIO_INPUTS)
+		dev->options.audio_input = default_audio_input;
+
+	dev->udev = usb_get_dev(interface_to_usbdev(interface));
+
+	/* set up the endpoint information */
+	/* use only the first bulk-in and bulk-out endpoints */
+	iface_desc = interface->cur_altsetting;
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i].desc;
+
+		if (!dev->bulk_in_endpointAddr &&
+		    usb_endpoint_is_bulk_in(endpoint)) {
+			/* we found a bulk in endpoint */
+			buffer_size = 8192; /*le16_to_cpu
+					      (endpoint->wMaxPacketSize); */
+			dev->bulk_in_size = buffer_size;
+			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+		}
+
+	}
+	if (!dev->bulk_in_endpointAddr) {
+		err("Could not find bulk-in endpoint");
+		goto error;
+	}
+
+	/* init the device */
+	if (hdpvr_device_init(dev)) {
+		err("device init failed");
+		goto error;
+	}
+
+	if (hdpvr_alloc_buffers(dev, NUM_BUFFERS)) {
+		err("allocating transfer buffers failed");
+		goto error;
+	}
+
+	if (hdpvr_register_videodev(dev,
+				    video_nr[atomic_inc_return(&dev_nr)])) {
+		err("registering videodev failed");
+		goto error;
+	}
+
+	/* save our data pointer in this interface device */
+	usb_set_intfdata(interface, dev);
+
+	/* let the user know what node this device is now attached to */
+	hdpvr_print("USB HD PVR device now attached to /dev/video%d",
+	     dev->video_dev->minor);
+	return 0;
+
+error:
+	if (dev)
+		/* this frees allocated memory */
+		kref_put(&dev->kref, hdpvr_delete);
+	return retval;
+}
+
+static void hdpvr_disconnect(struct usb_interface *interface)
+{
+	struct hdpvr_device *dev;
+	int minor;
+
+	dev = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+
+	minor = dev->video_dev->minor;
+
+	/* prevent more I/O from starting */
+	mutex_lock(&dev->io_mutex);
+	video_unregister_device(dev->video_dev);
+	mutex_unlock(&dev->io_mutex);
+
+	/* decrement our usage count */
+	kref_put(&dev->kref, hdpvr_delete);
+
+	atomic_dec(&dev_nr);
+
+	hdpvr_print("USB HD PVR /dev/video%d now disconnected", minor);
+}
+
+
+static struct usb_driver hdpvr_usb_driver = {
+	.name =		"hdpvr",
+	.probe =	hdpvr_probe,
+	.disconnect =	hdpvr_disconnect,
+	.id_table =	hdpvr_table,
+};
+
+static int __init hdpvr_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&hdpvr_usb_driver);
+	if (result)
+		err("usb_register failed. Error number %d", result);
+
+	return result;
+}
+
+static void __exit hdpvr_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&hdpvr_usb_driver);
+}
+
+module_init(hdpvr_init);
+module_exit(hdpvr_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Janne Grunau");
+MODULE_DESCRIPTION("Hauppauge HD PVR driver");
diff -Naur linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr-video.c linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr-video.c
--- linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr-video.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr-video.c	2008-07-14 17:25:44.000000000 -0400
@@ -0,0 +1,1219 @@
+/*
+ * Hauppage HD PVR USB driver - video 4 linux 2 interface
+ *
+ * Copyright (C) 2008      Janne Grunau (j@jannau.net)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/mutex.h>
+#include <linux/version.h>
+
+#include <linux/videodev2.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-common.h>
+#include "hdpvr.h"
+
+#define BULK_URB_TIMEOUT 1250 /* 1.25 seconds */
+
+struct hdpvr_fh {
+	struct hdpvr_device	*dev;
+};
+
+static uint list_size(struct list_head *list)
+{
+	struct list_head *tmp;
+	uint count = 0;
+
+	list_for_each(tmp, list) {
+		count++;
+	}
+
+	return count;
+}
+
+/*=========================================================================*/
+/* urb callback */
+static void hdpvr_read_bulk_callback(struct urb *urb)
+{
+	struct hdpvr_buffer *buf = (struct hdpvr_buffer *)urb->context;
+	struct hdpvr_device *dev = buf->dev;
+
+	/* marking buffer as received and wake waiting */
+	buf->status = BUFSTAT_READY;
+	wake_up_interruptible(&dev->wait);
+}
+
+/*=========================================================================*/
+/* bufffer bits */
+
+/* calling function should hold dev->io_mutex */
+static int hdpvr_cancel_queue(struct hdpvr_device *dev)
+{
+	struct hdpvr_buffer *buf;
+
+	hdpvr_trace("status = %d", dev->status);
+
+	list_for_each_entry(buf, &dev->rec_buff_list, buff_list) {
+		usb_kill_urb(buf->urb);
+		buf->status = BUFSTAT_AVAILABLE;
+	}
+
+	list_splice_init(&dev->rec_buff_list, dev->free_buff_list.prev);
+
+	return 0;
+}
+
+static int hdpvr_free_queue(struct list_head *q)
+{
+	struct list_head *tmp;
+	struct list_head *p;
+	struct hdpvr_buffer *buf;
+	struct urb *urb;
+
+	for (p = q->next; p != q;) {
+		buf = list_entry(p, struct hdpvr_buffer, buff_list);
+
+		urb = buf->urb;
+		usb_buffer_free(urb->dev, urb->transfer_buffer_length,
+				urb->transfer_buffer, urb->transfer_dma);
+		usb_free_urb(urb);
+		tmp = p->next;
+		list_del(p);
+		kfree(buf);
+		p = tmp;
+	}
+
+	return 0;
+}
+
+int hdpvr_free_buffers(struct hdpvr_device *dev)
+{
+	mutex_lock(&dev->io_mutex);
+
+	hdpvr_cancel_queue(dev);
+
+	hdpvr_free_queue(&dev->free_buff_list);
+	hdpvr_free_queue(&dev->rec_buff_list);
+
+	mutex_unlock(&dev->io_mutex);
+
+	return 0;
+}
+
+/* function expects dev->io_mutex to be held */
+int hdpvr_alloc_buffers(struct hdpvr_device *dev, uint count)
+{
+	uint i;
+	int retval = -ENOMEM;
+	u8 *mem;
+	struct hdpvr_buffer *buf;
+	struct urb *urb;
+
+	hdpvr_trace("status = %d", dev->status);
+	hdpvr_info("allocating %u buffers", count);
+
+	for (i = 0; i < count; i++) {
+
+		buf = kzalloc(sizeof(struct hdpvr_buffer), GFP_KERNEL);
+		if (!buf) {
+			err("cannot allocate buffer");
+			goto exit;
+		}
+		buf->dev = dev;
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			err("cannot allocate urb");
+			goto exit;
+		}
+		buf->urb = urb;
+
+		mem = usb_buffer_alloc(dev->udev, dev->bulk_in_size, GFP_KERNEL,
+				       &urb->transfer_dma);
+		if (!mem) {
+			err("cannot allocate usb transfer buffer");
+			goto exit;
+		}
+
+		usb_fill_bulk_urb(buf->urb, dev->udev,
+				  usb_rcvbulkpipe(dev->udev,
+						  dev->bulk_in_endpointAddr),
+				  mem, dev->bulk_in_size,
+				  hdpvr_read_bulk_callback, buf);
+
+		buf->status = BUFSTAT_AVAILABLE;
+		list_add_tail(&buf->buff_list, &dev->free_buff_list);
+	}
+	return 0;
+exit:
+	hdpvr_free_buffers(dev);
+	return retval;
+}
+
+static int submit_pending_buffers(struct hdpvr_device *dev)
+{
+	struct hdpvr_buffer *buf;
+	struct urb *urb;
+	int ret = 0, err_count = 0;
+
+	hdpvr_trace("status = %d", dev->status);
+
+	mutex_lock(&dev->io_mutex);
+
+	while (dev->status == STATUS_STREAMING &&
+	       !list_empty(&dev->free_buff_list)) {
+
+		buf = list_entry(dev->free_buff_list.next, struct hdpvr_buffer,
+				 buff_list);
+		if (buf->status != BUFSTAT_AVAILABLE) {
+			err("buffer not marked as availbale");
+			ret = -EFAULT;
+			goto err;
+		}
+
+		urb = buf->urb;
+		urb->status = 0;
+		urb->actual_length = 0;
+		ret = usb_submit_urb(urb, GFP_KERNEL);
+		if (ret) {
+			err("usb_submit_urb in %s returned %d", __func__, ret);
+			if (++err_count > 2)
+				break;
+			continue;
+		}
+		buf->status = BUFSTAT_INPROGRESS;
+		list_move_tail(&buf->buff_list, &dev->rec_buff_list);
+	}
+err:
+	hdpvr_info_buffer("buffer queue stat: %d free, %d proc",
+			  list_size(&dev->free_buff_list),
+			  list_size(&dev->rec_buff_list));
+	mutex_unlock(&dev->io_mutex);
+	return ret;
+}
+
+static struct hdpvr_buffer *get_next_buffer(struct hdpvr_device *dev)
+{
+	struct hdpvr_buffer *buf;
+
+	mutex_lock(&dev->io_mutex);
+
+	if (list_empty(&dev->rec_buff_list)) {
+		mutex_unlock(&dev->io_mutex);
+		err("error: rec_buf_list is empty");
+		return NULL;
+	}
+
+	buf = list_entry(dev->rec_buff_list.next, struct hdpvr_buffer,
+			 buff_list);
+	mutex_unlock(&dev->io_mutex);
+
+	return buf;
+}
+
+static int start_streaming(struct hdpvr_device *dev)
+{
+	int ret;
+	struct hdpvr_video_info *vidinf;
+
+	hdpvr_trace("status = %d", dev->status);
+	if (dev->status != STATUS_IDLE)
+		return -EAGAIN;
+
+	vidinf = get_video_info(dev);
+
+	if (vidinf) {
+		hdpvr_info("video signal: %dx%d@%dhz", vidinf->width,
+			   vidinf->height, vidinf->fps);
+		kfree(vidinf);
+
+		/* start streaming 2 request */
+		ret = usb_control_msg(dev->udev,
+				      usb_sndctrlpipe(dev->udev, 0),
+				      0xb8, 0x38, 0x1, 0, NULL, 0, 8000);
+		hdpvr_info("encoder start control request returned %d", ret);
+
+		hdpvr_config_call(dev, CTRL_START_STREAMING_VALUE, 0x00);
+
+		msleep(5);
+		hdpvr_info("streaming started");
+		dev->status = STATUS_STREAMING;
+		return 0;
+	}
+	hdpvr_err("no video signal at input %d", dev->options.video_input);
+	return -EAGAIN;
+}
+
+static int stop_streaming(struct hdpvr_device *dev)
+{
+	int ret, actual_length, c = 0;
+	u8 *buf;
+
+	hdpvr_trace("status = %d", dev->status);
+	if (dev->status != STATUS_STREAMING)
+		return -EAGAIN;
+
+	buf = kmalloc(dev->bulk_in_size, GFP_KERNEL);
+	if (!buf) {
+		err("stop streaming failed, out of memory");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	hdpvr_config_call(dev, CTRL_STOP_STREAMING_VALUE, 0x00);
+
+	/* wait 100 msec to let in flight urb comming back */
+	msleep(100);
+
+	/* kill the still outstanding urbs */
+	hdpvr_cancel_queue(dev);
+
+	/* emptying the device buffer before shutting it down */
+	while (++c < 500 &&
+	       !usb_bulk_msg(dev->udev,
+			     usb_rcvbulkpipe(dev->udev,
+					     dev->bulk_in_endpointAddr),
+			     buf, dev->bulk_in_size, &actual_length,
+			     BULK_URB_TIMEOUT)) {
+		/* wait */
+		msleep(5);
+		hdpvr_info_buffer("%2d: got %d bytes", c, actual_length);
+	}
+	kfree(buf);
+	hdpvr_info("used %d urbs to empty device buffers", c-1);
+
+	/* stop streaming 2 request */
+	ret = usb_control_msg(dev->udev,
+			      usb_sndctrlpipe(dev->udev, 0),
+			      0xb9, 0x38, 0x1, 0, NULL, 0, 8000);
+	hdpvr_info("encoder shutdown control request returned %d", ret);
+
+	hdpvr_info_buffer("buffer queue stat: %d free, %d proc",
+		   list_size(&dev->free_buff_list),
+		   list_size(&dev->rec_buff_list));
+
+	dev->status = STATUS_IDLE;
+exit:
+	return 0;
+}
+
+
+/*=======================================================================*/
+/*
+ * video 4 linux 2 file operations
+ */
+
+static int hdpvr_open(struct inode *inode, struct file *file)
+{
+	struct hdpvr_device *dev;
+	struct hdpvr_fh *fh;
+	int retval = -ENOMEM;
+
+	dev = (struct hdpvr_device *)video_get_drvdata(video_devdata(file));
+	if (!dev) {
+		err("open failing with with ENODEV");
+		retval = -ENODEV;
+		goto err;
+	}
+
+	hdpvr_trace("status = %d", dev->status);
+
+	/* increment our usage count for the device */
+	kref_get(&dev->kref);
+
+	fh = kzalloc(sizeof(struct hdpvr_fh), GFP_KERNEL);
+	if (!fh) {
+		err("Out of memory?");
+		goto err;
+	}
+	/* lock the device to allow correctly handling errors
+	 * in resumption */
+	mutex_lock(&dev->io_mutex);
+	dev->open_count++;
+
+	fh->dev = dev;
+
+	/* save our object in the file's private structure */
+	file->private_data = fh;
+
+	retval = 0;
+err:
+	mutex_unlock(&dev->io_mutex);
+	return retval;
+}
+
+
+static void hdpvr_draw_down(struct hdpvr_device *dev)
+{
+	hdpvr_trace("status = %d", dev->status);
+	/* hdpvr_cancel_queue(dev); */
+}
+
+
+static int hdpvr_flush(struct file *file, fl_owner_t id)
+{
+	struct hdpvr_fh *fh = (struct hdpvr_fh *)file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+
+	if (!dev)
+		return -ENODEV;
+
+	hdpvr_trace("status = %d", dev->status);
+
+	/* wait for io to stop */
+	mutex_lock(&dev->io_mutex);
+	hdpvr_draw_down(dev);
+
+	mutex_unlock(&dev->io_mutex);
+
+	return 0;
+}
+
+static int hdpvr_release(struct inode *inode, struct file *file)
+{
+	struct hdpvr_fh		*fh  = (struct hdpvr_fh *)file->private_data;
+	struct hdpvr_device	*dev = fh->dev;
+
+	if (!dev)
+		return -ENODEV;
+
+	hdpvr_trace("status = %d", dev->status);
+
+	mutex_lock(&dev->io_mutex);
+	if (!(--dev->open_count) && dev->status == STATUS_STREAMING)
+		stop_streaming(dev);
+
+	mutex_unlock(&dev->io_mutex);
+
+	/* decrement the count on our device */
+	kref_put(&dev->kref, hdpvr_delete);
+	return 0;
+}
+
+/*
+ * hdpvr_v4l2_read()
+ * will allocate buffers when called for the first time
+ */
+static ssize_t hdpvr_read(struct file *file, char __user *buffer, size_t count,
+			  loff_t *pos)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	struct hdpvr_buffer *buf = NULL;
+	struct urb *urb;
+	unsigned int ret = 0;
+	unsigned int processed = 0;
+	int rem;
+	int cnt;
+
+	if (*pos)
+		return -ESPIPE;
+
+	if (!dev)
+		return -ENODEV;
+
+	hdpvr_trace("status = %d", dev->status);
+
+	mutex_lock(&dev->io_mutex);
+	if (dev->status == STATUS_IDLE) {
+		if (start_streaming(dev)) {
+			err("start_streaming failed");
+			ret = -EFAULT;
+			dev->status = STATUS_IDLE;
+			mutex_unlock(&dev->io_mutex);
+			goto err;
+		}
+
+		hdpvr_info_buffer("buffer queue stat: %d free, %d proc",
+				  list_size(&dev->free_buff_list),
+				  list_size(&dev->rec_buff_list));
+	}
+	mutex_unlock(&dev->io_mutex);
+
+	if (submit_pending_buffers(dev)) {
+		err("couldn't submit buffers");
+		if (!ret)
+			ret = -EFAULT;
+		goto err;
+	}
+
+	buf = get_next_buffer(dev);
+
+	while (count > 0 && buf) {
+
+		urb = buf->urb;
+
+		if (buf->status != BUFSTAT_READY) {
+			/* return nonblocking */
+			if (file->f_flags & O_NONBLOCK) {
+				if (!ret)
+					ret = -EAGAIN;
+				goto err;
+			}
+
+			if (wait_event_interruptible(dev->wait,
+					      buf->status == BUFSTAT_READY)) {
+				ret = -ERESTARTSYS;
+				goto err;
+			}
+		}
+
+		/* set remaining bytes to copy */
+		rem = urb->actual_length - buf->pos;
+		cnt = rem > count ? count : rem;
+
+		if (copy_to_user(buffer, urb->transfer_buffer + buf->pos,
+				 cnt)) {
+			err("read: copy_to_user failed");
+			if (!ret)
+				ret = -EFAULT;
+			goto err;
+		}
+
+		buf->pos += cnt;
+		count -= cnt;
+		buffer += cnt;
+		ret += cnt;
+
+		/* finished, take next buffer */
+		if (buf->pos == urb->actual_length) {
+			mutex_lock(&dev->io_mutex);
+			buf->pos = 0;
+			buf->status = BUFSTAT_AVAILABLE;
+
+			list_move_tail(&buf->buff_list, &dev->free_buff_list);
+
+			mutex_unlock(&dev->io_mutex);
+
+			if (!(++processed % (NUM_BUFFERS/2))) {
+				if (submit_pending_buffers(dev)) {
+					err("couldn't submit buffers");
+					if (!ret)
+						ret = -EFAULT;
+					goto err;
+				}
+			}
+
+			buf = get_next_buffer(dev);
+		}
+	}
+err:
+	if (!ret && !buf)
+		ret = -EAGAIN;
+	return ret;
+}
+
+static unsigned int hdpvr_poll(struct file *filp, poll_table *wait)
+{
+	struct hdpvr_fh *fh = (struct hdpvr_fh *)filp->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	unsigned int mask = 0;
+
+	mutex_lock(&dev->io_mutex);
+	if (dev->status == STATUS_IDLE) {
+		if (start_streaming(dev)) {
+			err("start_streaming failed");
+			dev->status = STATUS_IDLE;
+		}
+
+		hdpvr_info_buffer("buffer queue stat: %d free, %d proc",
+				  list_size(&dev->free_buff_list),
+				  list_size(&dev->rec_buff_list));
+	}
+	mutex_unlock(&dev->io_mutex);
+
+	submit_pending_buffers(dev);
+
+	mutex_lock(&dev->io_mutex);
+
+	poll_wait(filp, &dev->wait, wait);
+
+	if (!list_empty(&dev->rec_buff_list)) {
+
+		struct hdpvr_buffer *buf = list_entry(dev->rec_buff_list.next,
+						      struct hdpvr_buffer,
+						      buff_list);
+
+		if (buf->status == BUFSTAT_READY)
+			mask |= POLLIN | POLLRDNORM;
+	}
+
+	mutex_unlock(&dev->io_mutex);
+
+	return mask;
+}
+
+
+static int hdpvr_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	struct hdpvr_fh *fh = (struct hdpvr_fh *)filp->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	int res;
+
+	mutex_lock(&dev->io_mutex);
+	switch (cmd) {
+	case VIDIOC_TRY_ENCODER_CMD:
+	case VIDIOC_ENCODER_CMD: {
+		struct v4l2_encoder_cmd *enc = (struct v4l2_encoder_cmd *)arg;
+		int try = cmd == VIDIOC_TRY_ENCODER_CMD;
+
+		memset(&enc->raw, 0, sizeof(enc->raw));
+		switch (enc->cmd) {
+		case V4L2_ENC_CMD_START:
+			enc->flags = 0;
+			if (try)
+				return 0;
+			res = start_streaming(dev);
+			break;
+		case V4L2_ENC_CMD_STOP:
+			if (try)
+				return 0;
+			res = stop_streaming(dev);
+			break;
+		default:
+			hdpvr_ioctl_debug("Unsupported encoder cmd %d\n",
+					  enc->cmd);
+			return -EINVAL;
+		}
+		break;
+	}
+	default:
+		res = video_ioctl2(inode, filp, cmd, arg);
+	}
+	mutex_unlock(&dev->io_mutex);
+	return res;
+}
+
+static const struct file_operations hdpvr_fops = {
+	.owner		= THIS_MODULE,
+	.open		= hdpvr_open,
+	.release	= hdpvr_release,
+	.flush		= hdpvr_flush,
+	.read		= hdpvr_read,
+	.poll		= hdpvr_poll,
+	.ioctl		= hdpvr_ioctl,
+};
+
+/*=======================================================================*/
+/*
+ * V4L2 ioctl handling
+ */
+
+static int vidioc_querycap(struct file *file, void  *priv,
+			   struct v4l2_capability *cap)
+{
+	strcpy(cap->driver, "hdpvr");
+	strcpy(cap->card, "Haupauge HD PVR");
+	cap->version = HDPVR_VERSION;
+	cap->capabilities =     V4L2_CAP_VIDEO_CAPTURE |
+				V4L2_CAP_AUDIO         |
+				V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_s_std(struct file *file, void *private_data,
+			v4l2_std_id *std)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	u8 std_type = 1;
+
+	if (*std & (V4L2_STD_NTSC | V4L2_STD_PAL_60))
+		std_type = 0;
+
+	return hdpvr_config_call(dev, CTRL_VIDEO_STD_TYPE, std_type);
+}
+
+static const char *iname[] = {
+	[HDPVR_COMPONENT] = "Component",
+	[HDPVR_SVIDEO]    = "S-Video",
+	[HDPVR_COMPOSITE] = "Composite",
+};
+
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *i)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	unsigned int n;
+
+	n = i->index;
+	if (n >= HDPVR_VIDEO_INPUTS)
+		return -EINVAL;
+
+	i->type = V4L2_INPUT_TYPE_CAMERA;
+
+	strncpy(i->name, iname[n], sizeof(i->name) - 1);
+	i->name[sizeof(i->name) - 1] = '\0';
+
+	i->audioset = 1<<HDPVR_RCA_FRONT | 1<<HDPVR_RCA_BACK | 1<<HDPVR_SPDIF;
+
+	i->std = dev->video_dev->tvnorms;
+
+	return 0;
+}
+
+static int vidioc_s_input(struct file *file, void *private_data,
+			  unsigned int index)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	int retval;
+
+	if (index >= HDPVR_VIDEO_INPUTS)
+		return -EINVAL;
+
+	if (dev->status != STATUS_IDLE)
+		return -EAGAIN;
+
+	retval = hdpvr_config_call(dev, CTRL_VIDEO_INPUT_VALUE, index+1);
+	if (!retval)
+		dev->options.video_input = index;
+
+	return retval;
+}
+
+static int vidioc_g_input(struct file *file, void *private_data,
+			  unsigned int *index)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+
+	*index = dev->options.video_input;
+	return 0;
+}
+
+
+static const char *audio_iname[] = {
+	[HDPVR_RCA_FRONT] = "RCA front",
+	[HDPVR_RCA_BACK]  = "RCA back",
+	[HDPVR_SPDIF]     = "SPDIF",
+};
+
+static int vidioc_enumaudio(struct file *file, void *priv,
+				struct v4l2_audio *audio)
+{
+	unsigned int n;
+
+	n = audio->index;
+	if (n >= HDPVR_AUDIO_INPUTS)
+		return -EINVAL;
+
+	audio->capability = V4L2_AUDCAP_STEREO;
+
+	strncpy(audio->name, audio_iname[n], sizeof(audio->name) - 1);
+	audio->name[sizeof(audio->name) - 1] = '\0';
+
+	return 0;
+}
+
+static int vidioc_s_audio(struct file *file, void *private_data,
+			  struct v4l2_audio *audio)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	int retval;
+
+	if (audio->index >= HDPVR_VIDEO_INPUTS)
+		return -EINVAL;
+
+	if (dev->status != STATUS_IDLE)
+		return -EAGAIN;
+
+	retval = hdpvr_config_call(dev, CTRL_VIDEO_INPUT_VALUE, audio->index+1);
+	if (!retval)
+		dev->options.audio_input = audio->index;
+
+	return retval;
+}
+
+static int vidioc_g_audio(struct file *file, void *private_data,
+			  struct v4l2_audio *audio)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+
+	audio->index = dev->options.audio_input;
+	audio->capability = V4L2_AUDCAP_STEREO;
+	strncpy(audio->name, audio_iname[audio->index], sizeof(audio->name) - 1);
+	audio->name[sizeof(audio->name) - 1] = '\0';
+	return 0;
+}
+
+static const s32 supported_v4l2_ctrls[] = {
+	V4L2_CID_BRIGHTNESS,
+	V4L2_CID_CONTRAST,
+	V4L2_CID_SATURATION,
+	V4L2_CID_HUE,
+	V4L2_CID_SHARPNESS,
+	V4L2_CID_MPEG_AUDIO_ENCODING,
+	V4L2_CID_MPEG_VIDEO_ENCODING,
+	V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+	V4L2_CID_MPEG_VIDEO_BITRATE,
+	V4L2_CID_MPEG_VIDEO_BITRATE_PEAK,
+};
+
+static int fill_queryctrl(struct v4l2_queryctrl *qc)
+{
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x86);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);
+	case V4L2_CID_SATURATION:
+		return v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);
+	case V4L2_CID_HUE:
+		return v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);
+	case V4L2_CID_SHARPNESS:
+		return v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);
+	case V4L2_CID_MPEG_AUDIO_ENCODING:
+		return v4l2_ctrl_query_fill(qc, V4L2_MPEG_AUDIO_ENCODING_AAC,
+					    V4L2_MPEG_AUDIO_ENCODING_AAC, 1,
+					    V4L2_MPEG_AUDIO_ENCODING_AAC);
+	case V4L2_CID_MPEG_VIDEO_ENCODING:
+		return v4l2_ctrl_query_fill(
+			qc, V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC,
+			V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC, 1,
+			V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC);
+
+/* 	case V4L2_CID_MPEG_VIDEO_? maybe keyframe interval: */
+/* 		return v4l2_ctrl_query_fill(qc, 0, 128, 128, 0); */
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		return v4l2_ctrl_query_fill(
+			qc, V4L2_MPEG_VIDEO_BITRATE_MODE_VBR,
+			V4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 1,
+			V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);
+
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+		return v4l2_ctrl_query_fill(qc, 1000000, 13500000, 100000,
+					    6500000);
+	case V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:
+		return v4l2_ctrl_query_fill(qc, 1100000, 20200000, 100000,
+					    9000000);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int vidioc_queryctrl(struct file *file, void *private_data,
+			    struct v4l2_queryctrl *qc)
+{
+	int i;
+	u32 id = qc->id;
+
+	memset(qc, 0, sizeof(*qc));
+
+	qc->id = id;
+
+	for (i = 0; i < ARRAY_SIZE(supported_v4l2_ctrls); i++)
+		if (qc->id == supported_v4l2_ctrls[i])
+			return fill_queryctrl(qc);
+
+	/* handle V4L2_CTRL_FLAG_NEXT_CTRL set */
+	if (qc->id & V4L2_CTRL_FLAG_NEXT_CTRL) {
+		qc->id &= ~V4L2_CTRL_FLAG_NEXT_CTRL;
+
+		for (i = 0; i < ARRAY_SIZE(supported_v4l2_ctrls); i++)
+			if (qc->id < supported_v4l2_ctrls[i]) {
+				qc->id = supported_v4l2_ctrls[i];
+				return fill_queryctrl(qc);
+			}
+	}
+
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *private_data,
+			 struct v4l2_control *ctrl)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		ctrl->value = dev->options.brightness;
+		break;
+	case V4L2_CID_CONTRAST:
+		ctrl->value = dev->options.contrast;
+		break;
+	case V4L2_CID_SATURATION:
+		ctrl->value = dev->options.saturation;
+		break;
+	case V4L2_CID_HUE:
+		ctrl->value = dev->options.hue;
+		break;
+	case V4L2_CID_SHARPNESS:
+		ctrl->value = dev->options.sharpness;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *private_data,
+			 struct v4l2_control *ctrl)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	int retval;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		retval = hdpvr_config_call(dev, CTRL_BRIGHTNESS, ctrl->value);
+		if (!retval)
+			dev->options.brightness = ctrl->value;
+		break;
+	case V4L2_CID_CONTRAST:
+		retval = hdpvr_config_call(dev, CTRL_CONTRAST, ctrl->value);
+		if (!retval)
+			dev->options.contrast = ctrl->value;
+		break;
+	case V4L2_CID_SATURATION:
+		retval = hdpvr_config_call(dev, CTRL_SATURATION, ctrl->value);
+		if (!retval)
+			dev->options.saturation = ctrl->value;
+		break;
+	case V4L2_CID_HUE:
+		retval = hdpvr_config_call(dev, CTRL_HUE, ctrl->value);
+		if (!retval)
+			dev->options.hue = ctrl->value;
+		break;
+	case V4L2_CID_SHARPNESS:
+		retval = hdpvr_config_call(dev, CTRL_SHARPNESS, ctrl->value);
+		if (!retval)
+			dev->options.sharpness = ctrl->value;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return retval;
+}
+
+
+static int hdpvr_get_ctrl(struct hdpvr_options *opt,
+			  struct v4l2_ext_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_MPEG_AUDIO_ENCODING:
+		ctrl->value = V4L2_MPEG_AUDIO_ENCODING_AAC;
+		break;
+	case V4L2_CID_MPEG_VIDEO_ENCODING:
+		ctrl->value = V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC;
+		break;
+/* 	case V4L2_CID_MPEG_VIDEO_B_FRAMES: */
+/* 		ctrl->value = (opt->gop_mode & 0x2) ? 0 : 128; */
+/* 		break; */
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		ctrl->value = opt->bitrate_mode == HDPVR_CONSTANT
+			? V4L2_MPEG_VIDEO_BITRATE_MODE_CBR
+			: V4L2_MPEG_VIDEO_BITRATE_MODE_VBR;
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+		ctrl->value = opt->bitrate * 100000;
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:
+		ctrl->value = opt->peak_bitrate * 100000;
+		break;
+	case V4L2_CID_MPEG_STREAM_TYPE:
+		ctrl->value = V4L2_MPEG_STREAM_TYPE_MPEG2_TS;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int vidioc_g_ext_ctrls(struct file *file, void *priv,
+			      struct v4l2_ext_controls *ctrls)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	int i, err = 0;
+
+	if (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {
+		for (i = 0; i < ctrls->count; i++) {
+			struct v4l2_ext_control *ctrl = ctrls->controls + i;
+
+			err = hdpvr_get_ctrl(&dev->options, ctrl);
+			if (err) {
+				ctrls->error_idx = i;
+				break;
+			}
+		}
+		return err;
+
+	}
+
+	return -EINVAL;
+}
+
+
+static int hdpvr_try_ctrl(struct v4l2_ext_control *ctrl)
+{
+	int ret = -EINVAL;
+
+	switch (ctrl->id) {
+	case V4L2_CID_MPEG_AUDIO_ENCODING:
+		if (ctrl->value == V4L2_MPEG_AUDIO_ENCODING_AAC)
+			ret = 0;
+		break;
+	case V4L2_CID_MPEG_VIDEO_ENCODING:
+		if (ctrl->value == V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC)
+			ret = 0;
+		break;
+/* 	case V4L2_CID_MPEG_VIDEO_B_FRAMES: */
+/* 		if (ctrl->value == 0 || ctrl->value == 128) */
+/* 			ret = 0; */
+/* 		break; */
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		if (ctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR ||
+		    ctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR)
+			ret = 0;
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+	{
+		uint bitrate = ctrl->value/100000;
+		if (bitrate >= 10 && bitrate <= 135)
+			ret = 0;
+		break;
+	}
+	case V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:
+	{
+		uint bitrate = ctrl->value/100000;
+		if (bitrate >= 10 && bitrate <= 202)
+			ret = 0;
+		break;
+	}
+	case V4L2_CID_MPEG_STREAM_TYPE:
+		if (ctrl->value == V4L2_MPEG_STREAM_TYPE_MPEG2_TS)
+			ret = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int vidioc_try_ext_ctrls(struct file *file, void *priv,
+				struct v4l2_ext_controls *ctrls)
+{
+	int i, err = 0;
+
+	if (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {
+		for (i = 0; i < ctrls->count; i++) {
+			struct v4l2_ext_control *ctrl = ctrls->controls + i;
+
+			err = hdpvr_try_ctrl(ctrl);
+			if (err) {
+				ctrls->error_idx = i;
+				break;
+			}
+		}
+		return err;
+	}
+
+	return -EINVAL;
+}
+
+
+static int hdpvr_set_ctrl(struct hdpvr_device *dev,
+			  struct v4l2_ext_control *ctrl)
+{
+	struct hdpvr_options *opt = &dev->options;
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_MPEG_AUDIO_ENCODING:
+		break;
+	case V4L2_CID_MPEG_VIDEO_ENCODING:
+		break;
+/* 	case V4L2_CID_MPEG_VIDEO_B_FRAMES: */
+/* 		if (ctrl->value == 0 && !(opt->gop_mode & 0x2)) { */
+/* 			opt->gop_mode |= 0x2; */
+/* 			hdpvr_config_call(dev, CTRL_GOP_MODE_VALUE, */
+/* 					  opt->gop_mode); */
+/* 		} */
+/* 		if (ctrl->value == 128 && opt->gop_mode & 0x2) { */
+/* 			opt->gop_mode &= ~0x2; */
+/* 			hdpvr_config_call(dev, CTRL_GOP_MODE_VALUE, */
+/* 					  opt->gop_mode); */
+/* 		} */
+/* 		break; */
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		if (ctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR &&
+		    opt->bitrate_mode != HDPVR_CONSTANT) {
+			opt->bitrate_mode = HDPVR_CONSTANT;
+			hdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,
+					  opt->bitrate_mode);
+		}
+		if (ctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR &&
+		    opt->bitrate_mode == HDPVR_CONSTANT) {
+			opt->bitrate_mode = HDPVR_VARIABLE_AVERAGE;
+			hdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,
+					  opt->bitrate_mode);
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE: {
+		uint bitrate = ctrl->value/100000;
+
+		opt->bitrate = bitrate;
+		if (bitrate >= opt->peak_bitrate)
+			opt->peak_bitrate = bitrate+1;
+
+		hdpvr_set_bitrate(dev);
+		break;
+	}
+	case V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: {
+		uint bitrate = ctrl->value/100000;
+
+		if (opt->bitrate < bitrate) {
+			opt->peak_bitrate = bitrate;
+			hdpvr_set_bitrate(dev);
+		} else
+			ret = -EINVAL;
+		break;
+	}
+	case V4L2_CID_MPEG_STREAM_TYPE:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static int vidioc_s_ext_ctrls(struct file *file, void *priv,
+			      struct v4l2_ext_controls *ctrls)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	int i, err = 0;
+
+	if (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {
+		for (i = 0; i < ctrls->count; i++) {
+			struct v4l2_ext_control *ctrl = ctrls->controls + i;
+
+			err = hdpvr_try_ctrl(ctrl);
+			if (err) {
+				ctrls->error_idx = i;
+				break;
+			}
+			err = hdpvr_set_ctrl(dev, ctrl);
+			if (err) {
+				ctrls->error_idx = i;
+				break;
+			}
+		}
+		return err;
+
+	}
+
+	return -EINVAL;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void *private_data,
+				    struct v4l2_fmtdesc *f)
+{
+
+	if (f->index != 0 || f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	f->flags = V4L2_FMT_FLAG_COMPRESSED;
+	strncpy(f->description, "MPEG2-TS with AVC/AAC streams", 32);
+	f->pixelformat = V4L2_PIX_FMT_MPEG;
+
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *private_data,
+				struct v4l2_format *f)
+{
+	struct hdpvr_fh *fh = file->private_data;
+	struct hdpvr_device *dev = fh->dev;
+	struct hdpvr_video_info *vid_info;
+
+	if (!dev)
+		return -ENODEV;
+
+	vid_info = get_video_info(dev);
+	if (!vid_info)
+		return -EFAULT;
+
+	f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	f->fmt.pix.pixelformat	= V4L2_PIX_FMT_MPEG;
+	f->fmt.pix.width	= vid_info->width;
+	f->fmt.pix.height	= vid_info->height;
+	f->fmt.pix.sizeimage	= dev->bulk_in_size;
+	f->fmt.pix.colorspace	= 0;
+	f->fmt.pix.bytesperline	= 0;
+	f->fmt.pix.field	= V4L2_FIELD_ANY;
+
+	kfree(vid_info);
+	return 0;
+}
+
+
+static const struct video_device hdpvr_video_template = {
+	.type			= VFL_TYPE_GRABBER,
+	.type2			= VID_TYPE_CAPTURE | VID_TYPE_MPEG_ENCODER,
+	.fops			= &hdpvr_fops,
+	.release		= video_device_release,
+	.vidioc_querycap	= vidioc_querycap,
+	.vidioc_s_std		= vidioc_s_std,
+	.vidioc_enum_input	= vidioc_enum_input,
+	.vidioc_g_input		= vidioc_g_input,
+	.vidioc_s_input		= vidioc_s_input,
+	.vidioc_enumaudio	= vidioc_enumaudio,
+	.vidioc_g_audio		= vidioc_g_audio,
+	.vidioc_s_audio		= vidioc_s_audio,
+	.vidioc_queryctrl	= vidioc_queryctrl,
+	.vidioc_g_ctrl		= vidioc_g_ctrl,
+	.vidioc_s_ctrl		= vidioc_s_ctrl,
+	.vidioc_g_ext_ctrls	= vidioc_g_ext_ctrls,
+	.vidioc_s_ext_ctrls	= vidioc_s_ext_ctrls,
+	.vidioc_try_ext_ctrls	= vidioc_try_ext_ctrls,
+	.vidioc_enum_fmt_vid_cap	= vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap		= vidioc_g_fmt_vid_cap,
+	.tvnorms 		=
+		V4L2_STD_NTSC  | V4L2_STD_SECAM | V4L2_STD_PAL_B |
+		V4L2_STD_PAL_G | V4L2_STD_PAL_H | V4L2_STD_PAL_I |
+		V4L2_STD_PAL_D | V4L2_STD_PAL_M | V4L2_STD_PAL_N |
+		V4L2_STD_PAL_60,
+};
+
+int hdpvr_register_videodev(struct hdpvr_device *dev, int devnum)
+{
+	/* setup and register video device */
+	dev->video_dev = video_device_alloc();
+	if (!dev->video_dev) {
+		err("video_device_alloc() failed");
+		goto error;
+	}
+
+	*(dev->video_dev) = hdpvr_video_template;
+	strcpy(dev->video_dev->name, "Hauppauge HD PVR");
+	dev->video_dev->priv = dev;
+
+	if (video_register_device(dev->video_dev, VFL_TYPE_GRABBER, devnum)) {
+		err("V4L2 device registration failed");
+		goto error;
+	}
+
+	return 0;
+error:
+	return -ENOMEM;
+}
diff -Naur linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr.h linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr.h
--- linux-2.6.25.8/drivers/media/video/hdpvr/hdpvr.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/media/video/hdpvr/hdpvr.h	2008-07-14 17:25:44.000000000 -0400
@@ -0,0 +1,299 @@
+/*
+ * Hauppage HD PVR USB driver
+ *
+ * Copyright (C) 2008      Janne Grunau (j@jannau.net)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+#define HDPVR_MAJOR_VERSION 0
+#define HDPVR_MINOR_VERSION 1
+#define HDPVR_RELEASE 0
+#define HDPVR_VERSION \
+	KERNEL_VERSION(HDPVR_MAJOR_VERSION, HDPVR_MINOR_VERSION, HDPVR_RELEASE)
+
+#define HDPVR_MAX 8
+
+/* Define these values to match your devices */
+#define HD_PVR_VENDOR_ID	0x2040
+#define HD_PVR_PRODUCT_ID	0x4900
+
+#define UNSET    (-1U)
+
+#define NUM_BUFFERS 16
+
+#define HDPVR_FIRMWARE_VERSION 8
+
+#define HDPVR_DEBUG
+
+extern int hdpvr_debug;
+
+#define MSG_INFO	1
+#define MSG_BUFFER	1<<1
+#define MSG_TRACE	1<<2
+#define MSG_IOCTL	1<<3
+
+#define hdpvr_err(fmt, arg...) do {\
+	printk(KERN_ERR "hdpvr: ERROR %s: " fmt "\n", __func__, ##arg); } \
+	while (0)
+
+#define hdpvr_print(fmt, arg...) do {\
+	printk(KERN_NOTICE "hdpvr: " fmt "\n", ##arg); } while (0)
+
+#define hdpvr_info(fmt, arg...) do {\
+	if (hdpvr_debug & MSG_INFO) \
+		printk(KERN_INFO "hdpvr: INFO %s: " fmt "\n", __func__, \
+		       ##arg); } \
+	while (0)
+
+#define hdpvr_info_buffer(fmt, arg...) do {\
+	if (hdpvr_debug & MSG_BUFFER) \
+		printk(KERN_DEBUG "hdpvr: BUFFER %s: " fmt "\n", __func__, \
+		       ##arg); } \
+	while (0)
+
+#define hdpvr_trace(fmt, arg...) do {\
+	if (hdpvr_debug & MSG_TRACE)				\
+		printk(KERN_DEBUG "hdpvr: TRACE %s: " fmt "\n", __func__, \
+		       ##arg); } \
+	while (0)
+
+#define hdpvr_ioctl_debug(fmt, arg...) do {\
+	if (hdpvr_debug & MSG_IOCTL)				\
+		printk(KERN_DEBUG "hdpvr: IOCTL " fmt "\n", \
+		       ##arg); } \
+	while (0)
+
+struct hdpvr_options {
+	u8	video_std;
+	u8	video_input;
+	u8	audio_input;
+	u8	bitrate;	/* in 100kbps */
+	u8	peak_bitrate;	/* in 100kbps */
+	u8	bitrate_mode;
+	u8	gop_mode;
+	u8	brightness;
+	u8	contrast;
+	u8	hue;
+	u8	saturation;
+	u8	sharpness;
+};
+
+/* Structure to hold all of our device specific stuff */
+struct hdpvr_device {
+	/* the v4l device for this device */
+	struct video_device	*video_dev;
+	/* the usb device for this device */
+	struct usb_device	*udev;
+
+	/* the max packet size of the bulk endpoint */
+	size_t			bulk_in_size;
+	/* the address of the bulk in endpoint */
+	__u8			bulk_in_endpointAddr;
+
+	/* holds the current device status */
+	__u8			status;
+	/* count the number of openers */
+	uint			open_count;
+
+	struct kref		kref;
+
+	/* holds the cureent set options */
+	struct hdpvr_options	options;
+
+	/* synchronize I/O */
+	struct mutex		io_mutex;
+	/* available buffers */
+	struct list_head	free_buff_list;
+	/* in progress buffers */
+	struct list_head	rec_buff_list;
+	/* waitqueue for buffers */
+	wait_queue_head_t	wait;
+};
+
+
+/* buffer one bulk urb of data */
+struct hdpvr_buffer {
+	struct list_head	buff_list;
+
+	struct urb		*urb;
+
+	struct hdpvr_device	*dev;
+
+	uint			pos;
+
+	__u8			status;
+};
+
+/* */
+
+struct hdpvr_video_info {
+	u16	width;
+	u16	height;
+	u8	fps;
+};
+
+enum {
+	STATUS_UNINITIALIZED	= 0,
+	STATUS_IDLE,
+	STATUS_STARTING,
+	STATUS_SHUTTING_DOWN,
+	STATUS_STREAMING,
+	STATUS_ERROR,
+};
+
+enum {
+	BUFSTAT_UNINITIALIZED = 0,
+	BUFSTAT_AVAILABLE,
+	BUFSTAT_INPROGRESS,
+	BUFSTAT_READY,
+};
+
+#define CTRL_START_STREAMING_VALUE	0x0700
+#define CTRL_STOP_STREAMING_VALUE	0x0800
+#define CTRL_BITRATE_VALUE		0x1000
+#define CTRL_BITRATE_MODE_VALUE		0x1200
+#define CTRL_GOP_MODE_VALUE		0x1300
+#define CTRL_VIDEO_INPUT_VALUE		0x1500
+#define CTRL_VIDEO_STD_TYPE		0x1700
+#define CTRL_AUDIO_INPUT_VALUE		0x2500
+#define CTRL_BRIGHTNESS			0x2900
+#define CTRL_CONTRAST			0x2a00
+#define CTRL_HUE			0x2b00
+#define CTRL_SATURATION			0x2c00
+#define CTRL_SHARPNESS			0x2d00
+#define CTRL_LOW_PASS_FILTER_VALUE	0x3100
+
+#define CTRL_DEFAULT_INDEX		0x0003
+
+
+	/* :0 s 38 01 1000 0003 0004 4 = 0a00ca00
+	 * BITRATE SETTING
+	 *   1st and 2nd byte (little endian): average bitrate in 100 000 bit/s
+	 *                                     min: 1 mbit/s, max: 13.5 mbit/s
+	 *   3rd and 4th byte (little endian): peak bitrate in 100 000 bit/s
+	 *                                     min: average + 100kbit/s,
+	 *                                      max: 20.2 mbit/s
+	 */
+
+	/* :0 s 38 01 1200 0003 0001 1 = 02
+	 * BIT RATE MODE
+	 *  constant = 1, variable (peak) = 2, variable (average) = 3
+	 */
+
+	/* :0 s 38 01 1300 0003 0001 1 = 03
+	 * GOP MODE (2 bit)
+	 *    low bit 0/1: advanced/simple GOP
+	 *   high bit 0/1: IDR(4/32/128) / no IDR (4/32/0)
+	 */
+
+	/* :0 s 38 01 1700 0003 0001 1 = 00
+	 * VIDEO STANDARD or FREQUNCY 0 = 60hz, 1 = 50hz
+	 */
+
+	/* :0 s 38 01 3100 0003 0004 4 = 03030000
+	 * FILTER CONTROL
+	 *   1st byte luma low pass filter strength,
+	 *   2nd byte chroma low pass filter strength,
+	 *   3rd byte MF enable chroma, min=0, max=1
+	 *   4th byte n
+	 */
+
+
+	/* :0 s 38 b9 0001 0000 0000 0 */
+
+
+
+/* :0 s 38 d3 0000 0000 0001 1 = 00 */
+/* 		ret = usb_control_msg(dev->udev, */
+/* 				      usb_sndctrlpipe(dev->udev, 0), */
+/* 				      0xd3, 0x38, */
+/* 				      0, 0, */
+/* 				      "\0", 1, */
+/* 				      1000); */
+
+/* 		info("control request returned %d", ret); */
+/* 		msleep(5000); */
+
+
+	/* :0 s b8 81 1400 0003 0005 5 <
+	 * :0 0 5 = d0024002 19
+	 * QUERY FRAME SIZE AND RATE
+	 *   1st and 2nd byte (little endian): horizontal resolution
+	 *   3rd and 4th byte (little endian): vertical resolution
+	 *   5th byte: frame rate
+	 */
+
+	/* :0 s b8 81 1800 0003 0003 3 <
+	 * :0 0 3 = 030104
+	 * QUERY SIGNAL AND DETECTED LINES, maybe INPUT
+	 */
+
+enum hdpvr_video_std {
+	HDPVR_60HZ = 1,
+	HDPVR_50HZ,
+};
+
+enum hdpvr_video_input {
+	HDPVR_COMPONENT = 0,
+	HDPVR_SVIDEO,
+	HDPVR_COMPOSITE,
+	HDPVR_VIDEO_INPUTS
+};
+
+enum hdpvr_audio_inputs {
+	HDPVR_RCA_BACK = 0,
+	HDPVR_RCA_FRONT,
+	HDPVR_SPDIF,
+	HDPVR_AUDIO_INPUTS
+};
+
+enum hdpvr_bitrate_mode {
+	HDPVR_CONSTANT = 1,
+	HDPVR_VARIABLE_PEAK,
+	HDPVR_VARIABLE_AVERAGE,
+};
+
+enum hdpvr_gop_mode {
+	HDPVR_ADVANCED_IDR_GOP = 0,
+	HDPVR_SIMPLE_IDR_GOP,
+	HDPVR_ADVANCED_NOIDR_GOP,
+	HDPVR_SIMPLE_NOIDR_GOP,
+};
+
+void hdpvr_delete(struct kref *kref);
+
+/*========================================================================*/
+/* hardware control functions */
+int hdpvr_set_options(struct hdpvr_device *dev);
+
+int hdpvr_set_bitrate(struct hdpvr_device *dev);
+
+int hdpvr_config_call(struct hdpvr_device *dev, uint value,
+		      unsigned char valbuf);
+
+struct hdpvr_video_info *get_video_info(struct hdpvr_device *dev);
+
+/* :0 s b8 81 1800 0003 0003 3 < */
+/* :0 0 3 = 0301ff */
+int get_input_lines_info(struct hdpvr_device *dev);
+
+
+/*========================================================================*/
+/* v4l2 registration */
+int hdpvr_register_videodev(struct hdpvr_device *dev, int devnumber);
+
+
+/*========================================================================*/
+/* buffer management */
+int hdpvr_free_buffers(struct hdpvr_device *dev);
+int hdpvr_alloc_buffers(struct hdpvr_device *dev, uint count);
+
+
+
+#ifdef HDPVR_DEBUG
+void print_bytes(char *string, unsigned char *buf, size_t len);
+#endif
diff -Naur linux-2.6.25.8/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.6.25.8-clean/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.6.25.8/drivers/mtd/chips/cfi_cmdset_0002.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/mtd/chips/cfi_cmdset_0002.c	2008-06-27 15:45:17.000000000 -0400
@@ -454,6 +454,22 @@
  * correctly and is therefore not done	(particulary with interleaved chips
  * as each chip must be checked independantly of the others).
  */
+#ifdef CONFIG_TANGOX
+/* For TANGOX, verify content in start address as well */
+static int __xipram chip_ready(struct map_info *map, unsigned long addr, unsigned long start, map_word z_val)
+{
+	map_word d, t, z;
+
+	d = map_read(map, addr);
+	mb();
+	t = map_read(map, addr);
+	mb();
+	z = map_read(map, start);
+	mb();
+
+	return map_word_equal(map, d, t) && map_word_equal(map, z, z_val);
+}
+#else
 static int __xipram chip_ready(struct map_info *map, unsigned long addr)
 {
 	map_word d, t;
@@ -463,6 +479,7 @@
 
 	return map_word_equal(map, d, t);
 }
+#endif
 
 /*
  * Return true if the chip is ready and has the correct value.
@@ -496,6 +513,9 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long timeo;
 	struct cfi_pri_amdstd *cfip = (struct cfi_pri_amdstd *)cfi->cmdset_priv;
+#ifdef CONFIG_TANGOX
+	map_word z_val = map_read(map, chip->start);
+#endif
 
  resettime:
 	timeo = jiffies + HZ;
@@ -504,8 +524,13 @@
 
 	case FL_STATUS:
 		for (;;) {
+#ifdef CONFIG_TANGOX
+			if (chip_ready(map, adr, chip->start, z_val))
+				break;
+#else
 			if (chip_ready(map, adr))
 				break;
+#endif
 
 			if (time_after(jiffies, timeo)) {
 				printk(KERN_ERR "Waiting for chip to be ready timed out.\n");
@@ -536,6 +561,12 @@
 		    )))
 			goto sleep;
 
+		/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		 * Sentivision FIX: map_write here whole flash operation freeze on VIP1216 STB.
+		 *   So we just will sleep waitting for state change: */
+		goto sleep;
+		/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+
 		/* We could check to see if we're trying to access the sector
 		 * that is currently being erased. However, no user will try
 		 * anything like that so we just wait for the timeout. */
@@ -548,8 +579,13 @@
 		chip->state = FL_ERASE_SUSPENDING;
 		chip->erase_suspended = 1;
 		for (;;) {
+#ifdef CONFIG_TANGOX
+			if (chip_ready(map, adr, chip->start, z_val))
+				break;
+#else
 			if (chip_ready(map, adr))
 				break;
+#endif
 
 			if (time_after(jiffies, timeo)) {
 				/* Should have suspended the erase by now.
@@ -1005,6 +1041,9 @@
 	int ret = 0;
 	map_word oldd;
 	int retry_cnt = 0;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+#endif
 
 	adr += chip->start;
 
@@ -1024,6 +1063,9 @@
 	 * data at other locations when 0xff is written to a location that
 	 * already contains 0xff.
 	 */
+#ifdef CONFIG_TANGOX
+	z_val = ((adr == chip->start) ? datum : map_read(map, chip->start));
+#endif
 	oldd = map_read(map, adr);
 	if (map_word_equal(map, oldd, datum)) {
 		DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): NOP\n",
@@ -1062,15 +1104,25 @@
 			continue;
 		}
 
-		if (time_after(jiffies, timeo) && !chip_ready(map, adr)){
+#ifdef CONFIG_TANGOX
+		if (time_after(jiffies, timeo) && !chip_ready(map, adr, chip->start, z_val))
+#else
+		if (time_after(jiffies, timeo) && !chip_ready(map, adr))
+#endif
+		{
 			xip_enable(map, chip, adr);
 			printk(KERN_WARNING "MTD %s(): software timeout\n", __func__);
 			xip_disable(map, chip, adr);
 			break;
 		}
 
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val))
+			break;
+#else
 		if (chip_ready(map, adr))
 			break;
+#endif
 
 		/* Latency issues. Drop the lock, wait a while and retry */
 		UDELAY(map, chip, adr, 1);
@@ -1253,6 +1305,9 @@
 	unsigned long cmd_adr;
 	int z, words;
 	map_word datum;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+#endif
 
 	adr += chip->start;
 	cmd_adr = adr;
@@ -1273,6 +1328,9 @@
 	ENABLE_VPP(map);
 	xip_disable(map, chip, cmd_adr);
 
+#ifdef CONFIG_TANGOX
+	z_val = ((adr == chip->start) ? datum : map_read(map, chip->start));
+#endif
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
 	//cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
@@ -1323,10 +1381,20 @@
 			continue;
 		}
 
+#ifdef CONFIG_TANGOX
+		if (time_after(jiffies, timeo) && !chip_ready(map, adr, chip->start, z_val))
+			break;
+#else
 		if (time_after(jiffies, timeo) && !chip_ready(map, adr))
 			break;
+#endif
 
-		if (chip_ready(map, adr)) {
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val)) 
+#else
+		if (chip_ready(map, adr)) 
+#endif
+		{
 			xip_enable(map, chip, adr);
 			goto op_done;
 		}
@@ -1444,6 +1512,10 @@
 	unsigned long int adr;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret = 0;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+	z_val.x[0] = ((map->bankwidth == 1) ? 0xff : 0xffff);
+#endif
 
 	adr = cfi->addr_unlock1;
 
@@ -1496,8 +1568,13 @@
 			chip->erase_suspended = 0;
 		}
 
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val))
+			break;
+#else
 		if (chip_ready(map, adr))
 			break;
+#endif
 
 		if (time_after(jiffies, timeo)) {
 			printk(KERN_WARNING "MTD %s(): software timeout\n",
@@ -1532,6 +1609,9 @@
 	unsigned long timeo = jiffies + HZ;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret = 0;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+#endif
 
 	adr += chip->start;
 
@@ -1545,6 +1625,13 @@
 	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): ERASE 0x%.8lx\n",
 	       __func__, adr );
 
+#ifdef CONFIG_TANGOX
+	if (adr == chip->start)
+		z_val.x[0] = ((map->bankwidth == 1) ? 0xff : 0xffff);
+	else
+		z_val = map_read(map, chip->start);
+#endif
+
 	XIP_INVAL_CACHED_RANGE(map, adr, len);
 	ENABLE_VPP(map);
 	xip_disable(map, chip, adr);
@@ -1578,13 +1665,18 @@
 			continue;
 		}
 		if (chip->erase_suspended) {
-			/* This erase was suspended and resumed.
+		/* This erase was suspended and resumed.
 			   Adjust the timeout */
 			timeo = jiffies + (HZ*20); /* FIXME */
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr)) {
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val))
+#else
+		if (chip_ready(map, adr)) 
+#endif
+		{
 			xip_enable(map, chip, adr);
 			break;
 		}
diff -Naur linux-2.6.25.8/drivers/mtd/maps/Kconfig linux-2.6.25.8-clean/drivers/mtd/maps/Kconfig
--- linux-2.6.25.8/drivers/mtd/maps/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/mtd/maps/Kconfig	2008-06-27 15:45:17.000000000 -0400
@@ -23,7 +23,7 @@
 
 config MTD_PHYSMAP_START
 	hex "Physical start address of flash mapping"
-	depends on MTD_PHYSMAP
+	depends on MTD_PHYSMAP && TANGOX_XENV_READ!=y
 	default "0x8000000"
 	help
 	  This is the physical memory location at which the flash chips
@@ -47,9 +47,9 @@
 	  Ignore this option if you use run-time physmap configuration
 	  (i.e., run-time calling physmap_configure()).
 
-config MTD_PHYSMAP_BANKWIDTH
+config MTD_PHYSMAP_BANKWIDTH 
 	int "Bank width in octets"
-	depends on MTD_PHYSMAP
+	depends on MTD_PHYSMAP && TANGOX_XENV_READ!=y
 	default "2"
 	help
 	  This is the total width of the data bus of the flash devices
diff -Naur linux-2.6.25.8/drivers/net/Kconfig linux-2.6.25.8-clean/drivers/net/Kconfig
--- linux-2.6.25.8/drivers/net/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/net/Kconfig	2008-06-26 15:00:17.000000000 -0400
@@ -1239,6 +1239,24 @@
 source "drivers/net/ibm_emac/Kconfig"
 source "drivers/net/ibm_newemac/Kconfig"
 
+config TANGO2_ENET
+	tristate "SMP863x Builtin Ethernet support"
+	depends on NET_ETHERNET && TANGO2 && !TANGO2_SD
+	select MII
+	select CRC32
+	help
+	 This option adds support for the SMP863x integrated Ethernet
+	 controller.  This driver uses NAPI and generic Linux MII
+	 support.
+
+config TANGO2_ENET_OLD
+	tristate "SMP863x Builtin Ethernet support (old driver)"
+	depends on NET_ETHERNET && TANGO2 && !TANGO2_SD
+	help
+	 This option adds support  for the SMP863x integrated Ethernet
+	 controller. This  is the orignal driver from  Sigma with only
+	 small changes.
+
 config NET_PCI
 	bool "EISA, VLB, PCI and on board controllers"
 	depends on ISA || EISA || PCI
diff -Naur linux-2.6.25.8/drivers/net/Makefile linux-2.6.25.8-clean/drivers/net/Makefile
--- linux-2.6.25.8/drivers/net/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/net/Makefile	2008-06-26 15:00:17.000000000 -0400
@@ -224,6 +224,10 @@
 
 obj-$(CONFIG_MACB) += macb.o
 
+# For SMP863x ethernet
+obj-$(CONFIG_TANGO2_ENET) += tango2_enet.o
+obj-$(CONFIG_TANGO2_ENET_OLD) += tango2_enet_old.o
+
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
 obj-$(CONFIG_TR) += tokenring/
diff -Naur linux-2.6.25.8/drivers/net/tango2_enet.c linux-2.6.25.8-clean/drivers/net/tango2_enet.c
--- linux-2.6.25.8/drivers/net/tango2_enet.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/net/tango2_enet.c	2009-04-13 19:31:18.000000000 -0400
@@ -0,0 +1,1142 @@
+/*
+ * New driver for SMP863x builtin Ethernet mac
+ *
+ * This driver uses NAPI and generic linux MII support.
+ *
+ * Tx path limits the number of interrupt by reclaiming sent buffer in
+ * a timer.  In case  the tx starts  to go  faster, it will  switch to
+ * interrupt mode.
+ *
+ * Note that OOM condition is not handled correctly, and can leave the
+ * rx path  in bad  shape. down/up the  interface should make  it work
+ * again though. But anyway, it's not likely to happen.
+ *
+ * Copyright (C) 2005 Maxime Bizon <mbizon@freebox.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/crc32.h>
+
+#include "tango2_enet.h"
+
+#define PFX	"tango2_enet: "
+
+MODULE_DESCRIPTION("SMP863x internal ethernet mac driver");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+MODULE_LICENSE("GPL");
+
+static int gphy_id = -1;
+module_param(gphy_id, int, 0);
+MODULE_PARM_DESC(gphy_id, "PHY id, else autodetect");
+
+static struct net_device *gdev;
+
+/*
+ * mdio read/write callback, can run from userspace or timer
+ */
+static __inline int enet_mdio_read(struct net_device *dev, int phy_id,
+				   int location)
+{
+	int val;
+
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+	enet_writel(ENET_MAC_MIIAR, MIIAR_ADDR(phy_id) | MIIAR_REG(location));
+	udelay(1);
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+	val = enet_readl(ENET_MAC_MIIDR);
+
+	return val;
+}
+
+static void enet_mdio_write(struct net_device *dev, int phy_id,
+				     int location, int val)
+{
+	enet_writel(ENET_MAC_MIIDR, val);
+	enet_writel(ENET_MAC_MIIAR,
+		    MIIAR_ADDR(phy_id) | MIIAR_REG(location) | MIIAR_WRITE);
+	udelay(1);
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+}
+
+/*
+ * enable/disable interrupt helpers
+ * need proper locks since we will call them from any context
+ */
+static __inline void enet_disable_interrupts(struct tango2_enet_priv *priv,
+					     int rx_only)
+{
+	unsigned long flags, val;
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	if (rx_only) {
+		val = enet_readl(ENET_DMA_IER);
+		val &= ~IER_R;
+		enet_writel(ENET_DMA_IER, val);
+	} else
+		enet_writel(ENET_DMA_IER, 0);
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+static __inline void enet_enable_interrupts(struct tango2_enet_priv *priv,
+					    int rx_only)
+{
+	unsigned long flags, val;
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	if (rx_only) {
+		val = enet_readl(ENET_DMA_IER);
+		val |= IER_R;
+		enet_writel(ENET_DMA_IER, val);
+	} else
+		enet_writel(ENET_DMA_IER, IER_NIS | IER_R | IER_T);
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+
+extern long long em86_netstats[];
+
+/*
+ * rx poll func, called by network core
+ */
+static int enet_poll(struct napi_struct *napi, int budget)
+{
+	struct tango2_enet_priv *priv = container_of(napi, struct tango2_enet_priv, napi);
+	struct net_device *dev = priv->dev;
+	int received=0;
+
+    gbus_writel(0x1B0040,1); // Update IOP
+//    while(gbus_readl(0x1B0040)!=0); // Update IOP
+    em86_netstats[18]=gbus_readl(0x1B0004);
+
+	/* process no more than "limit" done rx */
+	do {
+		volatile struct enet_rx_desc *rx;
+		struct sk_buff *skb;
+		uint32_t rdes0_cache;
+		unsigned int len;
+
+		rx = &priv->rx_descs[priv->last_rx_desc];
+
+		/* we  need  multiple  read  on this  volatile,  avoid
+		 * memory access at each time */
+		rdes0_cache = rx->rdes0;
+		if (rdes0_cache & RDES0_OWN) {
+			break;
+		}
+
+		if (received>=budget)
+			break;
+
+		if (likely(skb = priv->rx_skbs[priv->last_rx_desc])) {
+
+			/* we don't handle multipacket frame */
+			if (!(rdes0_cache & RDES0_FIRST) ||
+			    !(rdes0_cache & RDES0_LAST)) {
+				/* we don't handle multipacket frame */
+				priv->stats.rx_errors++;
+				priv->stats.rx_length_errors++;
+				goto rearm;
+			}
+
+			/* check for CRC */
+			if (rdes0_cache & RDES0_CRC) {
+				priv->stats.rx_errors++;
+				priv->stats.rx_crc_errors++;
+				goto rearm;
+			}
+
+			/* sanity check on len field */
+			len = RDES0_FRAME_LEN(rdes0_cache);
+			if (rdes0_cache & (RDES0_TOO_LONG | RDES0_TRUNC) ||
+			    len > RX_BUF_SIZE) {
+				priv->stats.rx_errors++;
+				priv->stats.rx_length_errors++;
+				goto rearm;
+			}
+
+			/* check remaining error */
+			if (rdes0_cache & (RDES0_ERR_SUM | RDES0_COLLISION |
+					   RDES0_WATCHDOG_TMOUT |
+					   RDES0_MII_ERROR)) {
+				priv->stats.rx_errors++;
+				goto rearm;
+			}
+
+			if (!(rx->rdes3&0x10000))
+			{
+				while(!(rx->rdes3&0x10000))
+				{
+					gbus_writel(0x1B0040,1); // Update IOP
+					// We'd probably prefer to skip some cycles here to leave bus free
+					em86_netstats[19]+=1;
+				}
+			}
+
+			/* ok, seems  valid, adjust skb  proto and len
+			 * and give it to kernel */
+			skb->dev = dev;
+			skb_put(skb, len);
+			skb->protocol = eth_type_trans(skb, dev);
+
+			if ((rx->rdes3 == 0x1000B)) {
+				em86_netstats[4]+=1;
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+			}
+			else
+			{
+				if ((rx->rdes3&0x10003)==0x10003)
+				{
+					em86_netstats[6]+=1;
+				}
+				else
+				{
+					em86_netstats[8]+=1;
+				}
+				skb->ip_summed = CHECKSUM_NONE;
+			}
+			
+			netif_receive_skb(skb);
+
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += len;
+			dev->last_rx = jiffies;
+			priv->rx_skbs[priv->last_rx_desc] = NULL;
+			/* we will realloc an skb for this slot */
+		}
+
+		skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		if (unlikely(!skb))
+			break;
+
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		rx->rdes3 = 0; // Clear checksum state
+		rx->rdes2 = PHYSADDR(skb->data);
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[priv->last_rx_desc] = skb;
+
+rearm:
+		/* rearm descriptor */
+		wmb();
+		rx->rdes0 = RDES0_OWN;
+		priv->last_rx_desc++;
+		priv->last_rx_desc &= (ENET_RX_DESC_COUNT - 1);
+		received++;
+
+	} while (1);
+
+	if (received==budget) 
+	{
+		/* breaked, but there is still work to do */
+		return received;
+	}
+
+	netif_rx_complete(dev, napi);
+	enet_enable_interrupts(priv, 1);
+
+	return received;
+}
+
+/*
+ * tx reclaim func. Called by timer or tx done tasklet to reclaim sent
+ * buffers.
+ */
+static void enet_tx_reclaim(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	volatile struct enet_tx_desc *tx;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	spin_lock(&priv->tx_lock);
+
+	while (priv->free_tx_desc_count < ENET_TX_DESC_COUNT) {
+		uint32_t tdes0_cache;
+		struct sk_buff *skb;
+
+		tx = &priv->tx_descs[priv->dirty_tx_desc];
+
+		tdes0_cache = tx->tdes0;
+		if (tdes0_cache & TDES0_OWN)
+			break;
+
+		skb = priv->tx_skbs[priv->dirty_tx_desc];
+		priv->stats.tx_packets++;
+
+		/* check  for  transmission  errors and  update  stats
+		 * accordingly */
+		if (tdes0_cache & (TDES0_ERR_SUM | TDES0_CARRIER_LOST |
+				   TDES0_NO_CARRIER | TDES0_LATE_COLLISION |
+				   TDES0_EXC_COLLISION | TDES0_HEARTBEAT |
+				   TDES0_EXC_DEFERAL | TDES0_UNDERFLOW)) {
+			priv->stats.tx_errors++;
+		} else {
+			priv->stats.tx_bytes += skb->len;
+		}
+
+		dev_kfree_skb(skb);
+		priv->tx_skbs[priv->dirty_tx_desc] = NULL;
+		priv->dirty_tx_desc++;
+		priv->dirty_tx_desc %= ENET_TX_DESC_COUNT;
+		priv->free_tx_desc_count++;
+	}
+
+	if (priv->free_tx_desc_count != 0 && netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+}
+
+/*
+ * tx done timer callback, just call tx_done and reschedule timer
+ */
+static void enet_tx_reclaim_timer(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+	enet_tx_reclaim(data);
+
+	priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	add_timer(&priv->tx_reclaim_timer);
+}
+
+
+/*
+ * tx request callback
+ */
+static int enet_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	volatile struct enet_tx_desc *tx;
+	unsigned long tdes1_cache;
+
+	spin_lock(&priv->tx_lock);
+
+	priv = netdev_priv(dev);
+	tx = &priv->tx_descs[priv->next_tx_desc];
+
+	/* make sure the next free tx desc is available */
+	if (unlikely(priv->free_tx_desc_count == 0)) {
+		/* no, this  should not happen since  queue is stopped
+		 * before we run out of tx desc */
+		printk(KERN_WARNING PFX "no free tx desc to handle pkt\n");
+//		dev_kfree_skb(skb);
+		netif_stop_queue(dev);
+		spin_unlock(&priv->tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* fill the tx desc with this skb address */
+	tdes1_cache = (TDES1_FIRST | TDES1_LAST);
+	if (priv->next_tx_desc == ENET_TX_DESC_COUNT - 1)
+		tdes1_cache |= TDES1_TER;
+
+	/* if we  start to  run low  on free tx  desc, then  enable tx
+	 * interrupt to reclaim them faster */
+	if (priv->free_tx_desc_count == ENET_TX_DESC_LOW) {
+		tdes1_cache |= (TDES1_ENABLE_ISR);
+	}
+	tdes1_cache |= TDES1_TBS1(skb->len);
+
+	tx->tdes1 = tdes1_cache;
+	tx->tdes2 = PHYSADDR(skb->data);
+	dma_cache_wback((unsigned long)skb->data, skb->len);
+
+	/* keep a pointer to it for later and give it to dma  */
+	priv->tx_skbs[priv->next_tx_desc] = skb;
+	wmb();
+	tx->tdes0 = TDES0_OWN;
+
+	/* kick tx dma in case it was suspended */
+	wmb();
+	enet_writel(ENET_DMA_TPDR, 0x1);
+
+	priv->next_tx_desc++;
+	priv->next_tx_desc %= ENET_TX_DESC_COUNT;
+
+	/* if next  tx descriptor is not  clean, then we  have to stop
+	 * queue */
+	if (unlikely(--priv->free_tx_desc_count == 0))
+		netif_stop_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+
+	return NETDEV_TX_OK;
+}
+
+/*
+ * our  irq handler, just  ack it  and schedule  the right  tasklet to
+ * handle this
+ */
+static irqreturn_t enet_isr(int irq, void *dev_id)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	dev = (struct net_device *)dev_id;
+	priv = netdev_priv(dev);
+
+	/* fetch status & ack them */
+	val = enet_readl(ENET_DMA_SR);
+	enet_writel(ENET_DMA_SR, val);
+
+	/* handle interrupt */
+	if (val & SR_NIS) {
+		if (val & SR_T) {
+			tasklet_schedule(&priv->tx_reclaim_tasklet);
+		}
+
+		if (val & SR_R) {
+			if (netif_rx_schedule_prep(dev, &priv->napi)) {
+				/* disable rx interrupt */
+				enet_disable_interrupts(priv, 1);
+
+				gbus_writel(0x1B0040,1); // Update IOP
+
+				/* ack  any  interrupt  that may  have
+				 * arrived  between last ack  to avoid
+				 * reentering */
+				enet_writel(ENET_DMA_SR, SR_NIS | SR_R);
+				__netif_rx_schedule(dev, &priv->napi);
+			}
+		}
+	}
+
+        return IRQ_HANDLED;
+}
+
+/*
+ * start/stop dma engine
+ */
+static __inline void enet_start_dma(struct tango2_enet_priv *priv)
+{
+	/* send start command to rx & tx dma */
+	enet_writel(ENET_DMA_CR, CR_SF | CR_SR | CR_ST);
+}
+
+static __inline void enet_stop_dma(struct tango2_enet_priv *priv)
+{
+	unsigned long val;
+
+	/* send stop command to rx & tx dma */
+	enet_writel(ENET_DMA_CR, 0);
+
+	/* wait for them to reach stopped state, should not be long */
+	do {
+		udelay(1);
+		val = enet_readl(ENET_DMA_SR);
+		if ((val & SR_TPS) && (val & SR_RPS))
+			break;
+	} while (1);
+}
+
+/*
+ * reconfigure mac for new link state
+ */
+static void enet_link_reconfigure(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	priv = netdev_priv(dev);
+
+	if (dev->flags & IFF_UP)
+		enet_stop_dma(priv);
+
+	/* reflect duplex status in dma register */
+	spin_lock(&priv->maccr_lock);
+	val = enet_readl(ENET_MAC_MACCR);
+	if (priv->mii.full_duplex)
+		val |= MACCR_F;
+	else
+		val &= ~MACCR_F;
+	enet_writel(ENET_MAC_MACCR, val);
+	spin_unlock(&priv->maccr_lock);
+
+	if (dev->flags & IFF_UP)
+		enet_start_dma(priv);
+}
+
+/*
+ * link check timer callback
+ */
+static void enet_link_check(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	/* check for duplex change */
+	spin_lock(&priv->mii_lock);
+	ret = mii_check_media(&priv->mii, 1, 0);
+	spin_unlock(&priv->mii_lock);
+
+	if (ret)
+		enet_link_reconfigure(dev);
+
+	/* reschedule timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+}
+
+/*
+ * program given mac address in hw registers
+ */
+static int enet_set_mac_address(struct net_device *dev, void *addr)
+{
+	unsigned long hi_mac, low_mac;
+	struct sockaddr *sock = addr;
+
+	/* to make it safe, we won't do this while running */
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, sock->sa_data, ETH_ALEN);
+
+	hi_mac = (dev->dev_addr[5] << 8) | dev->dev_addr[4];
+	low_mac = (dev->dev_addr[3] << 24)| (dev->dev_addr[2] << 16) |
+		(dev->dev_addr[1] << 8) | dev->dev_addr[0];
+
+	enet_writel(ENET_MAC_MACAHR, hi_mac);
+	enet_writel(ENET_MAC_MACALR, low_mac);
+
+	return 0;
+}
+
+/*
+ * update hash table to reflect new device multicast address list
+ */
+static void enet_set_multicast_list(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	struct dev_mc_list *mclist;
+	unsigned long val;
+	uint32_t mc_filter[2];
+	int i;
+
+	priv = netdev_priv(dev);
+
+	/* the link check timer might change MACCR, we need to protect
+	 * against it */
+	spin_lock_bh(&priv->maccr_lock);
+	val = enet_readl(ENET_MAC_MACCR);
+
+        if (dev->flags & IFF_PROMISC) {
+                val |= MACCR_PR | MACCR_PM;
+	} else {
+		val &= ~MACCR_PR;
+		/* if we want all multicast or if address count is too
+		 * high, don't try to compute hash value */
+		if (dev->mc_count > 64 || dev->flags & IFF_ALLMULTI) {
+			val |= MACCR_PM;
+		}
+	}
+	enet_writel(ENET_MAC_MACCR, val);
+	spin_unlock_bh(&priv->maccr_lock);
+
+	/* we  don't  need  to  update  hash  table  if  we  pass  all
+	 * multicast */
+	if (val & MACCR_PM)
+		return;
+
+	mc_filter[0] = mc_filter[1] = 0;
+	mclist = dev->mc_list;
+
+	for (i = 0; i < dev->mc_count; i++) {
+		unsigned int n;
+		char *addr;
+
+		addr = mclist->dmi_addr;
+		mclist = mclist->next;
+		if (!(*addr & 1))
+			continue;
+
+		n = ether_crc(ETH_ALEN, addr) >> 26;
+		mc_filter[n >> 5] |= 1 << (n & 31);
+	}
+
+	enet_writel(ENET_MAC_MALR, mc_filter[0]);
+	enet_writel(ENET_MAC_MAHR, mc_filter[1]);
+}
+
+/*
+ * open callback
+ */
+static int enet_open(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	priv = netdev_priv(dev);
+
+	/* check link */
+	if (mii_check_media(&priv->mii, 1, 1))
+		enet_link_reconfigure(dev);
+
+	/* start rx & tx dma engine */
+	enet_start_dma(priv);
+
+	napi_enable(&priv->napi);
+
+	/* enable mac rx & tx */
+	val = enet_readl(ENET_MAC_MACCR);
+	val |= MACCR_TE | MACCR_RE;
+	enet_writel(ENET_MAC_MACCR, val);
+
+	/*
+	 * clear & enable interrupts, we want:
+	 * - receive complete
+	 * - transmit complete
+	 */
+	enet_writel(ENET_DMA_SR, SR_NIS | SR_R | SR_T);
+	enet_enable_interrupts(priv, 0);
+
+	/* start link check & tx reclaim timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+
+	priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	add_timer(&priv->tx_reclaim_timer);
+
+	/* and finally start tx queue */
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/*
+ * stop callback
+ */
+static int enet_stop(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+	int i;
+
+	priv = netdev_priv(dev);
+
+	/* stop link timer */
+	del_timer_sync(&priv->link_check_timer);
+
+	/* stop tx queue */
+	netif_stop_queue(dev);
+	napi_disable(&priv->napi);
+
+	/* wait for all tx buffers to be reclaimed */
+	while (priv->free_tx_desc_count != ENET_TX_DESC_COUNT)
+		yield();
+
+	/* stop tx reclaim timer */
+	del_timer_sync(&priv->tx_reclaim_timer);
+
+	/* disable all interrupts */
+	enet_disable_interrupts(priv, 0);
+
+	/* stop dma */
+	enet_stop_dma(priv);
+
+	/* stop mac rx & tx */
+	val = enet_readl(ENET_MAC_MACCR);
+	val &= ~(MACCR_TE | MACCR_RE);
+	enet_writel(ENET_MAC_MACCR, val);
+
+	/* while we were stopping it,  the rx dma may have filled some
+	 * buffer, consider it junk and rearm all descriptor */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		volatile struct enet_rx_desc *rx;
+
+		rx = &priv->rx_descs[i];
+		rx->rdes0 = RDES0_OWN;
+	}
+
+	/* make  the dma engine  restarts at  first descriptor  in the
+	 * list */
+	enet_writel(ENET_DMA_RBAR, PHYSADDR(priv->rx_descs));
+	enet_writel(ENET_DMA_TBAR, PHYSADDR(priv->tx_descs));
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->last_rx_desc = 0;
+
+	return 0;
+}
+
+/*
+ * get_stats callback
+ */
+static struct net_device_stats *enet_get_stats(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+
+	priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+/*
+ * ethtool callbacks
+ */
+static int enet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_gset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_sset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_nway_reset(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_nway_restart(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static u32 enet_get_link(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_link_ok(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static struct ethtool_ops enet_ethtool_ops = {
+	.get_settings		= enet_get_settings,
+	.set_settings		= enet_set_settings,
+	.nway_reset		= enet_nway_reset,
+	.get_link		= enet_get_link,
+};
+
+static int enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii);
+	ret = generic_mii_ioctl(&priv->mii, if_mii(rq), cmd, NULL);
+	spin_unlock_bh(&priv->mii);
+
+	return ret;
+}
+
+/*
+ * dma ring allocation is done here
+ */
+static int enet_dma_init(struct tango2_enet_priv *priv)
+{
+	unsigned int size;
+	int i;
+
+	/*
+	 * allocate rx descriptor list & rx buffers
+	 *
+	 * We allocate  skb now and fill buffer  with their addresses,
+	 * note that we reserve 4 bytes at beginning of data buffer to
+	 * store skb address.
+	 *
+	 */
+	size = ENET_RX_DESC_COUNT * sizeof (struct enet_rx_desc);
+	if (!(priv->rx_descs_cached = kmalloc(size, GFP_KERNEL)))
+		return -ENOMEM;
+	priv->rx_descs = (volatile struct enet_rx_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->rx_descs_cached);
+	dma_cache_wback_inv((unsigned long)priv->rx_descs_cached, size);
+
+	/*
+	 * initialize all rx descs
+	 */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		volatile struct enet_rx_desc *rx;
+		struct sk_buff *skb;
+
+		rx = &priv->rx_descs[i];
+		rx->rdes0 = RDES0_OWN;
+
+		rx->rdes1 = RDES1_RBS2(0) | RDES1_RBS1(RX_BUF_SIZE);
+		if (i == ENET_RX_DESC_COUNT - 1)
+			rx->rdes1 |= RDES1_RER;
+
+		skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		if (!skb)
+			return -ENOMEM;
+
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		rx->rdes2 = PHYSADDR(skb->data);
+		rx->rdes3 = 0;
+
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[i] = skb;
+	}
+	priv->last_rx_desc = 0;
+
+	/*
+	 * allocate tx descriptor list
+	 *
+	 * We allocate  only the descriptor list and  prepare them for
+	 * further use. When tx is needed, we will set the right flags
+	 * and kick the dma.
+	 */
+	size = ENET_TX_DESC_COUNT * sizeof (struct enet_tx_desc);
+	if (!(priv->tx_descs_cached = kmalloc(size, GFP_KERNEL)))
+		return -ENOMEM;
+	priv->tx_descs = (volatile struct enet_tx_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->tx_descs_cached);
+	dma_cache_wback_inv((unsigned long)priv->tx_descs_cached, size);
+
+	/*
+	 * initialize tx descs
+	 */
+	for (i = 0; i < ENET_TX_DESC_COUNT; i++) {
+		volatile struct enet_tx_desc *tx;
+
+		tx = &priv->tx_descs[i];
+		tx->tdes0 = 0;
+		tx->tdes1 = 0;
+		if (i == ENET_TX_DESC_COUNT - 1)
+			tx->tdes1 |= TDES1_TER;
+		tx->tdes2 = 0;
+		tx->tdes3 = 0;
+	}
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->free_tx_desc_count = ENET_TX_DESC_COUNT;
+
+	/*
+	 * write rx desc list & tx desc list addresses in registers
+	 */
+	enet_writel(ENET_DMA_RBAR, PHYSADDR(priv->rx_descs));
+	enet_writel(ENET_DMA_TBAR, PHYSADDR(priv->tx_descs));
+
+    printk(KERN_ERR "tango2_enet rx desc at %X tx desc at %X\n",PHYSADDR(priv->rx_descs),
+        PHYSADDR(priv->tx_descs));
+	return 0;
+}
+
+/*
+ * free  all dma rings  memory, called  at uninit  time or  when error
+ * occurs at init time
+ */
+static void enet_dma_free(struct tango2_enet_priv *priv)
+{
+	int i;
+
+	/* note: kfree(NULL) is ok */
+	kfree(priv->rx_descs_cached);
+	kfree(priv->tx_descs_cached);
+
+	/* note: kfree_skb(NULL) is _not_ ok */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		if (priv->rx_skbs[i])
+			kfree_skb(priv->rx_skbs[i]);
+	}
+
+	for (i = 0; i < ENET_TX_DESC_COUNT; i++) {
+		if (priv->tx_skbs[i])
+			kfree_skb(priv->tx_skbs[i]);
+	}
+}
+
+/*
+ * mac hw init is done here
+ */
+static int enet_hw_init(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int loop;
+
+	priv = netdev_priv(dev);
+
+	/* reset phy */
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, BMCR_RESET);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if (!(enet_mdio_read(dev, priv->mii.phy_id,
+				     MII_BMCR) & BMCR_RESET))
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR PFX "PHY reset does not complete...\n");
+		return -EBUSY;
+	}
+
+	/* reset dma engine */
+	enet_writel(ENET_DMA_BMR, BMR_SWR);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if (!(enet_readl(ENET_DMA_BMR) & BMR_SWR))
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR PFX "dma engine does not exit reset...\n");
+		return -EBUSY;
+	}
+
+	/* set bus mode */
+	enet_writel(ENET_DMA_BMR, BMR_PBL(32));
+
+	/* enable MAC flow ctrl */
+	enet_writel(ENET_MAC_FCR, FCR_ENABLE);
+
+	/* configure MAC ctrller to do hash perfect filtering  */
+	enet_writel(ENET_MAC_MACCR, MACCR_ASTP | MACCR_HP);
+
+	/* clear hash table */
+	enet_writel(ENET_MAC_MAHR, 0xffffffff);
+	enet_writel(ENET_MAC_MALR, 0xffffffff);
+
+	return 0;
+}
+
+
+
+/*
+ * allocate  netdevice structure,  do  all dma  rings allocations  and
+ * register the netdevice
+ */
+extern int tangox_ethernet_getmac(int i, unsigned char *);
+
+static int enet_probe(void)
+{
+	struct tango2_enet_priv *priv;
+	struct net_device *dev;
+	int ret;
+	struct sockaddr sock;
+
+	printk(KERN_INFO PFX "ethernet driver for SMP863x internal mac\n");
+
+	/* allocate  netdevice structure  with enough  length  for our
+	 * context data */
+	dev = alloc_etherdev(sizeof (*priv));
+	if (!dev)
+		return -ENOMEM;
+
+	/* initialize private data */
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof (*priv));
+	spin_lock_init(&priv->tx_lock);
+	spin_lock_init(&priv->ier_lock);
+	spin_lock_init(&priv->maccr_lock);
+
+	/* init tx done tasklet */
+	tasklet_init(&priv->tx_reclaim_tasklet, enet_tx_reclaim,
+		     (unsigned long)dev);
+
+	/* init tx reclaim timer */
+	init_timer(&priv->tx_reclaim_timer);
+	priv->tx_reclaim_timer.data = (unsigned long )dev;
+	priv->tx_reclaim_timer.function = enet_tx_reclaim_timer;
+
+	/* init link check timer and mii lock */
+	init_timer(&priv->link_check_timer);
+	priv->link_check_timer.data = (unsigned long)dev;
+	priv->link_check_timer.function = enet_link_check;
+	spin_lock_init(&priv->mii_lock);
+
+	/* fill mii info */
+	priv->mii.dev = dev;
+	priv->mii.phy_id_mask = 0x1f;
+	priv->mii.reg_num_mask = 0x1f;
+	priv->mii.mdio_read = enet_mdio_read;
+	priv->mii.mdio_write = enet_mdio_write;
+
+	if (gphy_id != -1) {
+		/* phy id forced, just check for sanity */
+		if (gphy_id < 0 || gphy_id > 31) {
+			ret = -EINVAL;
+			goto err_free;
+		}
+		priv->mii.phy_id = gphy_id;
+
+	} else {
+		int i;
+
+		/* try to probe phy if not given */
+		for (i = 0; i < 32; i++) {
+			uint32_t id;
+			int val;
+
+			val = enet_mdio_read(dev, i, MII_PHYSID1);
+			id = (val << 16);
+			val = enet_mdio_read(dev, i, MII_PHYSID2);
+			id |= val;
+
+			if (id != 0xffffffff && id != 0x00000000)
+				break;
+		}
+
+		if (i == 32) {
+			printk(KERN_ERR PFX "unable to autodetect phy\n");
+			ret = -EIO;
+			goto err_free;
+		}
+
+		printk(KERN_ERR PFX "detected phy at address 0x%02x\n", i);
+		priv->mii.phy_id = i;
+	}
+
+	/* initialize hardware */
+	if ((ret = enet_hw_init(dev)))
+		goto err_free;
+
+	/* initialize dma rings */
+	if ((ret = enet_dma_init(priv)))
+		goto err_free;
+
+	/* register interrupt handler */
+	ret = request_irq(ENET_IRQ, enet_isr, IRQF_SHARED,
+			  "tango2_enet", dev);
+	if (ret)
+		goto err_free;
+	dev->irq = ENET_IRQ;
+
+	/* install driver callbacks and register netdevice */
+	priv->dev = dev;
+	dev->open = enet_open;
+	dev->stop = enet_stop;
+	dev->hard_start_xmit = enet_xmit;
+	dev->get_stats = enet_get_stats;
+	dev->set_mac_address = enet_set_mac_address;
+	dev->set_multicast_list = enet_set_multicast_list;
+	dev->ethtool_ops = &enet_ethtool_ops;
+	dev->do_ioctl = enet_ioctl;
+	netif_napi_add(dev, &priv->napi, enet_poll, 16);
+
+	/* set default mac address */
+	tangox_ethernet_getmac(0, dev->dev_addr);
+	memcpy(&(sock.sa_data), dev->dev_addr, ETH_ALEN);
+	enet_set_mac_address(dev, &sock);
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR PFX "unable to register netdevice\n");
+		goto err_free;
+	}
+
+	printk(KERN_INFO PFX "mac address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	gdev = dev;
+	return 0;
+
+err_free:
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	enet_dma_free(priv);
+	free_netdev(dev);
+	return ret;
+}
+
+
+/*
+ * entry point, checks if ethernet is  enabled on the board and if so,
+ * probes it
+ */
+extern int tangox_ethernet_enabled(int);
+
+int __init tango2_enet_init(void)
+{
+    // Start IOP
+    gbus_writel(0xDFFFC,3);
+    gbus_writel(0xDFFFC,1);
+    gbus_writel(0xDFFFC,0);
+
+	if (!tangox_ethernet_enabled(0)) {
+		printk(KERN_NOTICE PFX "ethernet support is disabled\n");
+		return -ENODEV;
+	}
+
+	return enet_probe();
+}
+
+/*
+ * exit func, stops hardware and unregisters netdevice
+ */
+void __exit tango2_enet_exit(void)
+{
+	struct tango2_enet_priv *priv;
+	struct net_device *dev;
+
+	dev = gdev;
+
+	free_irq(dev->irq, dev);
+	unregister_netdev(dev);
+
+	priv = netdev_priv(dev);
+	enet_dma_free(priv);
+
+	free_netdev(dev);
+}
+
+
+module_init(tango2_enet_init);
+module_exit(tango2_enet_exit);
+
diff -Naur linux-2.6.25.8/drivers/net/tango2_enet.h linux-2.6.25.8-clean/drivers/net/tango2_enet.h
--- linux-2.6.25.8/drivers/net/tango2_enet.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/net/tango2_enet.h	2008-06-26 15:00:52.000000000 -0400
@@ -0,0 +1,313 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO2_ENET_H
+#define __TANGO2_ENET_H
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+
+#include <asm/addrspace.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#else
+#error "Unknown architecture"
+#endif
+
+#define ENET_IRQ	((IRQ_CONTROLLER_IRQ_BASE) + (LOG2_CPU_ETH_MAC_INT))
+
+/*
+ * number of rx/tx buffers available
+ * !!! MUST BE A POWER OF 2 !!!
+ */
+#define ENET_RX_DESC_COUNT	64
+#define ENET_TX_DESC_COUNT	64
+
+/*
+ * we enable tx  interrupt when there is equal to  this number of free
+ * tx desc. Keep it lower than ENET_TX_DESC_COUNT if you change it.
+ */
+#define ENET_TX_DESC_LOW	20
+
+/*
+ * sizeof rx buffers we give to the dma controller
+ */
+#define RX_BUF_SIZE		0x600
+
+/*
+ * ipv4 stack  assumes received  ip header is  32 bits aligned,  so we
+ * keep 2 bytes to align ip header
+ */
+#define SKB_RESERVE_SIZE	2
+
+/*
+ * we reclaim  transmited using a  timer, we switch to  interrupt mode
+ * under high load. this is the timer frequency
+ */
+#define TX_RECLAIM_TIMER_FREQ	(HZ / 100)
+
+/*
+ * link status  is polled on a regular  basis by a timer,  this is its
+ * frequency
+ */
+#define LINK_CHECK_TIMER_FREQ	(HZ)
+
+
+/*
+ * address space conversion
+ */
+#define CACHE_TO_NONCACHE(x)	KSEG1ADDR(x)
+#define PHYSADDR(x)		tangox_dma_address(CPHYSADDR(x))
+
+
+/*
+ * Mac/DMA registers offset, refer to documentation
+ */
+#define ENET_HOST_BASE		REG_BASE_host_interface
+
+/* mac registers */
+#define ENET_MAC_BASE		(ENET_HOST_BASE + 0x6000)
+#define ENET_MAC_MACCR		(ENET_MAC_BASE + 0x0)
+#define MACCR_F			(1 << 20)
+#define MACCR_PM		(1 << 19)
+#define MACCR_PR		(1 << 18)
+#define MACCR_HP		(1 << 13)
+#define MACCR_ASTP		(1 << 8)
+#define MACCR_TE		(1 << 3)
+#define MACCR_RE		(1 << 2)
+#define ENET_MAC_MACAHR		(ENET_MAC_BASE + 0x4)
+#define ENET_MAC_MACALR		(ENET_MAC_BASE + 0x8)
+#define ENET_MAC_MAHR		(ENET_MAC_BASE + 0xc)
+#define ENET_MAC_MALR		(ENET_MAC_BASE + 0x10)
+#define ENET_MAC_MIIAR		(ENET_MAC_BASE + 0x14)
+#define MIIAR_ADDR(x)		((x) << 11)
+#define MIIAR_REG(x)		((x) << 6)
+#define MIIAR_WRITE		(1 << 1)
+#define MIIAR_BUSY		(1 << 0)
+#define ENET_MAC_MIIDR		(ENET_MAC_BASE + 0x18)
+#define ENET_MAC_FCR		(ENET_MAC_BASE + 0x1c)
+#define FCR_ENABLE		(1 << 1)
+
+/* dma registers */
+#define ENET_DMA_BASE		(ENET_HOST_BASE + 0x7000)
+#define ENET_DMA_BMR		(ENET_DMA_BASE + 0x00)
+#define BMR_PBL(x)		((x & 0x3f) << 8)
+#define BMR_SWR			(1 << 0)
+#define ENET_DMA_TPDR		(ENET_DMA_BASE + 0x04)
+#define ENET_DMA_RPDR		(ENET_DMA_BASE + 0x08)
+#define ENET_DMA_RBAR		(ENET_DMA_BASE + 0x0c)
+#define ENET_DMA_TBAR		(ENET_DMA_BASE + 0x10)
+#define ENET_DMA_SR		(ENET_DMA_BASE + 0x14)
+#define SR_EB(x)		(((x) >> 23) & 0x3)
+#define SR_TS(x)		(((x) >> 20) & 0x7)
+#define SR_RS(x)		(((x) >> 17) & 0x7)
+#define SR_NIS			(1 << 16)
+#define SR_AIS			(1 << 15)
+#define SR_ERI			(1 << 14)
+#define SR_FBE			(1 << 13)
+#define SR_ETI			(1 << 12)
+#define SR_RWT			(1 << 11)
+#define SR_RPS			(1 << 8)
+#define SR_RU			(1 << 7)
+#define SR_R			(1 << 6)
+#define SR_UNF			(1 << 5)
+#define SR_TU			(1 << 4)
+#define SR_TPS			(1 << 1)
+#define SR_T			(1 << 0)
+#define ENET_DMA_CR		(ENET_DMA_BASE + 0x18)
+#define CR_SF			(1 << 21)
+#define CR_ST			(1 << 13)
+#define CR_SR			(1 << 1)
+#define ENET_DMA_IER		(ENET_DMA_BASE + 0x1c)
+#define IER_NIS			(1 << 16)
+#define IER_AIS			(1 << 15)
+#define IER_ERE			(1 << 14)
+#define IER_FBE			(1 << 13)
+#define IER_ETE			(1 << 10)
+#define IER_RWT			(1 << 9)
+#define IER_RS			(1 << 8)
+#define IER_RU			(1 << 7)
+#define IER_R			(1 << 6)
+#define IER_UE			(1 << 5)
+#define IER_TBU			(1 << 2)
+#define IER_TS			(1 << 1)
+#define IER_T			(1 << 0)
+#define ENET_DMA_CHRBA		(ENET_DMA_BASE + 0x54)
+
+
+/*
+ * rx dma descriptor definition
+ */
+struct enet_rx_desc {
+	unsigned long rdes0;
+	unsigned long rdes1;
+	unsigned long rdes2;
+	unsigned long rdes3;
+};
+
+#define RDES0_OWN		(1 << 31)
+#define RDES0_FILTER_FAIL	(1 << 30)
+#define RDES0_FRAME_LEN(x)	(((x) & 0x1fff0000) >> 16)
+#define RDES0_ERR_SUM		(1 << 15)
+#define RDES0_TRUNC		(1 << 14)
+#define RDES0_FIRST		(1 << 9)
+#define RDES0_LAST		(1 << 8)
+#define RDES0_TOO_LONG		(1 << 7)
+#define RDES0_COLLISION		(1 << 6)
+#define RDES0_WATCHDOG_TMOUT	(1 << 4)
+#define RDES0_MII_ERROR		(1 << 3)
+#define RDES0_CRC		(1 << 1)
+
+#define RDES1_DISABLE_ISR	(1 << 31)
+#define RDES1_RER		(1 << 25)
+#define RDES1_RCH		(1 << 24)
+#define RDES1_RBS2(x)		((x) << 11)
+#define RDES1_RBS1(x)		(x)
+
+
+
+/*
+ * tx dma descriptor definition
+ */
+struct enet_tx_desc {
+	uint32_t tdes0;
+	uint32_t tdes1;
+	uint32_t tdes2;
+	uint32_t tdes3;
+};
+
+#define TDES0_OWN		(1 << 31)
+#define TDES0_ERR_SUM		(1 << 15)
+#define TDES0_CARRIER_LOST	(1 << 11)
+#define TDES0_NO_CARRIER	(1 << 10)
+#define TDES0_LATE_COLLISION	(1 << 9)
+#define TDES0_EXC_COLLISION	(1 << 8)
+#define TDES0_HEARTBEAT		(1 << 7)
+#define TDES0_EXC_DEFERAL	(1 << 2)
+#define TDES0_UNDERFLOW		(1 << 1)
+
+#define TDES1_ENABLE_ISR	(1 << 31)
+#define TDES1_LAST	 	(1 << 30)
+#define TDES1_FIRST		(1 << 29)
+#define TDES1_DISABLE_FCS	(1 << 26)
+#define TDES1_TER	 	(1 << 25)
+#define TDES1_TCH	 	(1 << 24)
+#define TDES1_DISABLE_PADDING	(1 << 23)
+#define TDES1_TBS2(x)		((x) << 11)
+#define TDES1_TBS1(x)		(x)
+
+
+/*
+ * our private context
+ */
+struct tango2_enet_priv {
+
+	/*
+	 * rx related
+	 */
+
+	/* pointer to rx descriptor array */
+	volatile struct enet_rx_desc	*rx_descs;
+	struct enet_rx_desc		*rx_descs_cached;
+
+	/* last rx descriptor processed */
+	unsigned int			last_rx_desc;
+
+	/* we keep a list of skb given */
+	struct sk_buff			*rx_skbs[ENET_RX_DESC_COUNT];
+
+	/* ethernet device stats */
+	struct net_device_stats		stats;
+
+
+
+
+	/*
+	 * tx related
+	 */
+
+	/* access  to  tx related  dma  stuffs  is  protected by  this
+	 * spinlock, this is because we  access them via a tasklet and
+	 * a timer */
+	spinlock_t			tx_lock;
+
+	/* pointer to tx descriptor array */
+	volatile struct enet_tx_desc	*tx_descs;
+	struct enet_tx_desc		*tx_descs_cached;
+
+	/* index of current dirty tx descriptor */
+	unsigned int			dirty_tx_desc;
+
+	/* index of next clean tx descriptor to use */
+	unsigned int			next_tx_desc;
+
+	/* count of free tx desc to avoid its computation */
+	unsigned int			free_tx_desc_count;
+
+	/* list of sent skb */
+	struct sk_buff			*tx_skbs[ENET_TX_DESC_COUNT];
+
+	/* tx  done operation is  done under  these tasklet  and timer
+	 * context */
+	struct tasklet_struct		tx_reclaim_tasklet;
+	struct timer_list		tx_reclaim_timer;
+
+
+	/*
+	 * misc
+	 */
+
+	/* spinlock used to protect interrupt enable register */
+	spinlock_t			ier_lock;
+
+	/* spinlock used to protect maccr register */
+	spinlock_t			maccr_lock;
+
+	/* our mii state */
+	struct mii_if_info		mii;
+
+	/* mii access is protected by following spinlock */
+	spinlock_t			mii_lock;
+
+	/* link status is checked periodically by this timer */
+	struct timer_list		link_check_timer;
+	struct napi_struct	napi;
+	struct net_device	*dev;
+};
+
+/*
+ * helpers to access registers
+ */
+
+static inline unsigned long enet_readl(unsigned long addr)
+{
+	unsigned long tmp = 0;
+	unsigned long res = gbus_readl(addr);
+	extern int is_tango2_es6(void);
+	if (is_tango2_es6()) 
+		tmp = gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt);
+	return(res);
+}
+
+static inline void enet_writel(unsigned long addr, unsigned long data)
+{
+	gbus_writel(addr, data);
+
+	/* some write  read sequence seems  to freeze completly  if no
+	 * barrier is done between each access. To be safe, we do this
+	 * after all write access */
+	iob();
+}
+
+#endif /* __TANGO2_ENET_H */
+
diff -Naur linux-2.6.25.8/drivers/net/tango2_enet_old.c linux-2.6.25.8-clean/drivers/net/tango2_enet_old.c
--- linux-2.6.25.8/drivers/net/tango2_enet_old.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/net/tango2_enet_old.c	2008-06-26 15:00:17.000000000 -0400
@@ -0,0 +1,2294 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ *  Embedded Ethernet driver for TANGO2 ES4 or above
+ */
+#ifdef BOOTLOADER
+#include "config.h"
+#include "version.h"
+#include "util.h"
+#include "net.h"
+#include "net_ipv4.h"
+#include "em86xxapi.h"
+#include "irqs.h"
+#include "errno.h"
+#include "uart.h"
+#include "memcfg.h"
+#else
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+//#include <linux/compatmac.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/crc32.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/memcfg.h>
+#else
+#include <asm/virtconvert.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/memcfg.h>
+#endif
+
+// Use kernel timer implementation for polling the link status
+// #define USE_KERNEL_TIMER
+
+#endif //BOOTLOADER
+
+#include "tango2_enet_old.h"
+
+#define DRV_NAME	"em86xx-eth"
+#define DRV_VERSION     "-0.0.0.0.1"
+
+/* Uncomment this for different messages */
+//#define ETH_DEBUG 
+#define ETH_ERRMSG 
+#define ETH_MSG
+//#define ETH_DBG_INOUT
+//#define DEBUG_RX_TX_STATE
+//#define DEBUG_MDIO
+
+#ifdef BOOTLOADER
+#define DRIVER "em86xx_eth"
+
+/* For static buffer allocation */
+// #define STATIC_BUF_ALLOC
+#define printk          uart_printf
+
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+#define MAX_ORDER	10
+
+#endif /* BOOTLOADER */
+
+/* For software filtering*/
+//#define USE_SW_FILTERING
+#define USE_HW_FILTERING
+
+#ifdef ETH_DEBUG
+#define DBG_PRINT	printk
+#else
+static void inline DBG_PRINT(const char *x, ...) { ; }
+#endif /* ETH_DEBUG */
+
+#ifdef ETH_ERRMSG
+#define ERR_PRINT	printk
+#else
+static void inline ERR_PRINT(const char *x, ...) { ; }
+#endif /* ETH_ERRMSG */
+
+#ifdef ETH_MSG
+#define MSG_PRINT	printk
+#else
+static void inline MSG_PRINT(const char *x, ...) { ; }
+#endif /* ETH_ERRMSG */
+
+#ifdef ETH_DBG_INOUT
+#define DBG_PRINT_INOUT_FUNC(x) printk("%s: %s\n", __func__, x);
+#define MSG_PRINT	printk
+#else
+static void inline DBG_PRINT_INOUT_FUNC(const char *x, ...) { ; }
+#endif /* ETH_ERRMSG */
+
+/* Hack: this is the mac address by default */
+#define DEF_MAC_HI	0x00000011
+#ifdef BOOTLOADER
+#define DEF_MAC_LO	0xdeadbeef
+#else
+#define DEF_MAC_LO	0xaabbccdd
+#endif
+
+/* Default maximum link wait */
+#ifdef USE_KERNEL_TIMER
+#define DEF_LINK_LOOP		0x10000
+#else
+#define DEF_LINK_LOOP		0x100
+#endif
+#define DEF_MAX_LINK_LOOP	(DEF_LINK_LOOP * 16)
+
+#define ETH_IRQ_FLAGS   (DmaIntNormal     | DmaIntAbnormal    | DmaIntRxStopped         | \
+		         DmaIntRxNoBuffer | DmaIntRxCompleted | DmaIeTxUnderflow        | \
+                         DmaIeTxStopped   | DmaIeTxCompleted) 
+/*	(DmaIntNormal	  | DmaIntAbnormal    | DmaIntRxStopped		| \
+			 DmaIntRxNoBuffer | DmaIntRxCompleted | DmaIntTxCompleted)
+*/
+#define ETH_RXTX_FLAGS	(DmaTxStart       | DmaRxStart	      | DmaStoreAndForward)
+
+#ifndef USE_HW_FILTERING 
+#define ETH_MAC_FLAGS   (MacTxEnable      |  MacRxEnable       | MacPromiscuousModeOn	| \
+                        MacPadStripEnable |  MacHashFilterOn   | MacPerfectFilterOff 	| \
+                        MacRetryEnable    |  MacHeartBeatOff)
+#else 
+#define ETH_MAC_FLAGS	(MacTxEnable   	  | MacRxEnable        | MacPromiscuousModeOff  | \
+			MacPadStripEnable | MacHashFilterOn    | MacPerfectFilterOn     | \
+                        MacRetryEnable    | MacMulticastFilterOn | MacHeartBeatOff)
+#define DEFAULT_BROADCAST_ADDRESS { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF }
+static void em86xx_eth_set_multicast_list(struct net_device *dev);
+#endif /*USE_HW_FILTERING*/
+
+#define MD_FRAME_FLAGS  (DescRxLast        | DescRxFirst)
+#define TX_DESC1_FLAGS 	(DescTxLast        | DescTxFirst        | DescChain             | \
+			 DescTxIntEnable)
+#define RX_ERROR_FLAGS  (DescFilteringFail | DescError		| DescRxTruncated	| \
+			 DescLengthError   | DescRxDamaged 	| DescRxLongFrame	| \
+			 DescRxCollision   | DescRxMiiError	| DescRxCrc)
+#define TX_ERROR_FLAGS  (DescTxLostCarrier | DescTxNoCarrier	| DescTxLateCollision 	| \
+			 DescTxExcCollisions| DescTxHeartbeatFail| DescTxUnderflow)
+
+#if defined(CONFIG_TANGOX) 
+extern int tangox_ethernet_getmac(int idx, unsigned char *mac);
+#endif
+
+#define PHY_10BASET_HD_ANAR  	 (CSMACD | BASET10 | FLOWCONTROL | RF)
+#define PHY_10BASET_FD_ANAR 	 (CSMACD | BASET10 | BASET10FD | FLOWCONTROL | RF)
+#define PHY_100BASET_HD_ANAR	 (CSMACD | BASET10 | BASET10FD | BASET100 | FLOWCONTROL | RF)
+#define PHY_100BASET_FD_ANAR	 (CSMACD | BASET10 | BASET10FD | BASET100 | BASET100FD | FLOWCONTROL | RF)
+
+/* Number of descriptors and buffer size */
+#define MIN_NUM_RDESC	8
+#define MIN_NUM_TDESC	8
+#define NUM_RDESC 	64
+#define NUM_TDESC	64
+#define R_BUF_SIZE	0x700	/* needs to be < 2KB */
+#define T_BUF_SIZE	0x700	/* needs to be < 2KB */
+
+#if (R_BUF_SIZE < (1 << 14))
+/* For multi-descriptor frame support: only when receive buffer size < 16384 */
+#define MULTI_DESCS_FRAME_SUPPORT
+#endif
+
+/* Private data for this ethernet device */
+typedef struct {
+	struct net_device_stats stats; /* stats */
+	unsigned long last_rxidx;      /* last rx idx to descriptor */
+	unsigned long next_txidx;      /* next tx idx to descriptor */
+
+
+	spinlock_t lock;
+	/* MII transceiver section. */
+	struct mii_if_info mii_if;
+        /* Mode selection */
+        int autoneg_active;
+        int phy_loopback;	
+
+	/* Descriptors and buffers: notice the alignments */
+#ifdef STATIC_BUF_ALLOC 
+	struct em86xx_desc eth_rxdsc[NUM_RDESC] __attribute__ ((__aligned__(16)));
+	struct em86xx_desc eth_txdsc[NUM_TDESC] __attribute__ ((__aligned__(16)));
+	unsigned char eth_rxbuf[NUM_RDESC * R_BUF_SIZE] __attribute__ ((__aligned__(16)));
+	unsigned char eth_txbuf[NUM_TDESC * T_BUF_SIZE] __attribute__ ((__aligned__(16)));
+#else
+	struct em86xx_desc *eth_rxdsc;
+	struct em86xx_desc *eth_txdsc;
+	unsigned char *eth_rxbuf;
+	unsigned char *eth_txbuf;
+	unsigned long desc_page;
+	unsigned long rxbuf_pages;
+	unsigned long txbuf_pages;
+#ifndef BOOTLOADER
+	unsigned long rxbuf_order;
+	unsigned long txbuf_order;
+#endif
+#endif
+
+	/* Number of descriptors */
+	unsigned long num_rxdesc;
+	unsigned long num_txdesc;
+
+/* The real data pointer to be accessed in non-cache region */
+	volatile struct em86xx_desc *rxdsc;
+	volatile struct em86xx_desc *txdsc;
+	volatile unsigned char *rxbuf;
+	volatile unsigned char *txbuf;
+
+	/* Reference count for device */
+	int dev_count;
+
+	int reset_flag;
+	int phy_id;
+	int stop_thread;
+
+#ifndef BOOTLOADER
+#ifdef USE_KERNEL_TIMER 
+	struct timer_list eth_timer;
+#endif
+	struct sk_buff **rx_skb_list;
+	int need_restart_tx_queue; 
+#endif
+
+} EM86XX_ETH_PRIV;
+
+/* For storing MAC address */
+static unsigned long def_mac_hi = DEF_MAC_HI;
+static unsigned long def_mac_lo = DEF_MAC_LO;
+unsigned long num_rxdesc_param = NUM_RDESC;
+unsigned long num_txdesc_param = NUM_TDESC;
+
+/* Default PHY address: -1 for search */
+static int phy_address = -1;
+/* Default to 100BaseT/FD*/
+
+static int em86xx_eth_reset_desc(struct net_device *dev, int *reset);
+
+#ifdef BOOTLOADER
+static void em86xx_eth_intr_handler(int irq, void *dev_id);
+#else
+static struct net_device em86xx_eth_dev;
+static irqreturn_t em86xx_eth_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
+static int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
+
+MODULE_AUTHOR("Craig Qu");
+MODULE_DESCRIPTION("Sigma Designs ethernet driver");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(def_mac_hi, "i");
+MODULE_PARM(def_mac_lo, "i");
+MODULE_PARM(phy_address, "i");
+MODULE_PARM_DESC(phy_address, "PHY address connecting to the MAC.");
+
+#ifndef STATIC_BUF_ALLOC 
+MODULE_PARM(num_rxdesc_param, "i");
+MODULE_PARM(num_txdesc_param, "i");
+#endif
+#endif /* BOOTLOADER */
+
+#define TX_ERRORS       12
+#define TX_ERRORS_START 1
+
+#define RX_ERRORS       31
+#define RX_ERRORS_START 1
+
+static const char *rx_error_msg[RX_ERRORS]= {
+	NULL,
+	"A CRC error is detected.",
+	NULL,
+	"A receive error was detected during frame reception.",
+	NULL,NULL,
+	"The frame has seen a collision after the collision window.",
+	"The frame is longer than 1518 bytes.",
+	NULL,NULL,NULL,
+	"The frame is prematurely terminated before the collision window.",	
+	"The actual length does not match with the Length Type field of the incoming frame.",
+	NULL,
+	"No more descriptors for receive frame.",
+	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
+	"The frame failed the address recognizing filtering.",
+};
+
+static const int rx_stat_offset[RX_ERRORS] = {
+	-1,
+	(int)&(((struct net_device_stats *)0)->rx_crc_errors),
+	-1,-1,-1,-1,
+	(int)&(((struct net_device_stats *)0)->collisions),
+	-1,-1,-1,-1,-1,
+	(int)&(((struct net_device_stats *)0)->rx_length_errors),
+	-1,
+	(int)&(((struct net_device_stats *)0)->rx_over_errors),
+	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+}; 
+
+static const char *tx_error_msg[TX_ERRORS]= {
+	NULL,
+	"Late data arrival from the memory.",
+	"Excessive deferral.",
+	NULL,NULL,NULL,NULL,
+	"Heartbeat collision check failure.",
+	"Transmission aborted after 16 collisions.",
+	"Transmission aborted due to collision.",
+	"No carrier signal from the tranceiver.",
+	"Loss of carrier during transmission.",	
+};
+
+static const int tx_stat_offset[TX_ERRORS] = {
+	-1,
+	(int)&(((struct net_device_stats *)0)->tx_aborted_errors),
+	(int)&(((struct net_device_stats *)0)->tx_aborted_errors),
+	-1,-1,-1,-1,
+	(int)&(((struct net_device_stats *)0)->tx_heartbeat_errors),
+	(int)&(((struct net_device_stats *)0)->collisions),
+	(int)&(((struct net_device_stats *)0)->collisions),
+	(int)&(((struct net_device_stats *)0)->tx_carrier_errors),
+	(int)&(((struct net_device_stats *)0)->tx_carrier_errors),
+}; 
+
+/* Helper routine */
+static void wait_ms (int ms)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	if (!in_interrupt()) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 + ms * HZ / 1000);
+	} else {
+		mdelay(ms);
+	}
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+
+/* MDIO access routines - used by MII standard Linux API */
+static int mdio_read (struct net_device *dev, int phy_addr, int reg_num)
+{
+	u32 addr;
+	u16 ret;
+	int count;
+	
+#ifdef DEBUG_MDIO
+	DBG_PRINT("%s: start addr %d reg %d\n", __func__, phy_addr, reg_num);
+#endif
+    /* Wait while the PHY is busy */
+	for (count = 1000; count != 0; count--) {
+		if (!(em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy))
+			break;
+	}
+	/* Set PHY & register to read */
+	addr = ((phy_addr & 0x1F) << 11) | ((reg_num & 0x1F) << 6);
+	em86xx_write_reg(EM86XX_MIIAR_REG, addr);
+	/* Work-around Sigma-Designs MAC bug */
+	udelay(40);
+	/* Wait while PHY is busy */
+	for (count = 1000; count != 0; count--) {
+		if (!(em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy))
+			break;
+	}
+	ret = em86xx_read_reg(EM86XX_MIIDR_REG) & 0xFFFF;
+#ifdef DEBUG_MDIO
+	DBG_PRINT(" => %04x\n", ret);
+#endif
+	
+	return ret;
+}
+
+static void mdio_write (struct net_device *dev,
+                        int phy_addr, int reg_num, int value)
+{
+	u32 addr;
+	int count;
+	
+#ifdef DEBUG_MDIO
+	DBG_PRINT("%s: start addr %d reg %d val %04x\n",
+	       __func__, phy_addr, reg_num, value);
+#endif
+	/* Wait while the PHY is busy */
+	for (count = 1000; count != 0; count--) {
+		if (!(em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy))
+			break;
+	}
+	/* Set PHY & register to write */
+	addr = ((phy_addr & 0x1F) << 11) | ((reg_num & 0x1F) << 6) | (1 << 1);
+	em86xx_write_reg(EM86XX_MIIDR_REG, value);
+	em86xx_write_reg(EM86XX_MIIAR_REG, addr);
+
+	while (em86xx_read_reg(EM86XX_MIIAR_REG) & MiiBusy);
+
+}
+
+static int dump_ethtool_cmd(struct ethtool_cmd *ep)
+{
+
+        printk("       Speed: ");
+        switch (ep->speed) {
+        case SPEED_10:
+                printk("10Mb/s\n");
+                break;
+        case SPEED_100:
+                printk("100Mb/s\n");
+                break;
+        case SPEED_1000:
+                printk("1000Mb/s\n");
+                break;
+        default:
+                printk("Unknown! (%i)\n", ep->speed);
+                break;
+        };
+
+        printk("       Duplex: ");
+        switch (ep->duplex) {
+        case DUPLEX_HALF:
+                printk("Half\n");
+                break;
+        case DUPLEX_FULL:
+                printk("Full\n");
+                break;
+        default:
+                printk("Unknown! (%i)\n", ep->duplex);
+                break;
+        };
+
+        printk("       Auto-negotiation: %s\n",
+                (ep->autoneg == AUTONEG_DISABLE) ?
+                "off" : "on");
+        return 0;
+}
+
+
+
+/* Routine to configure the PHY */
+void setup_phy (struct mii_if_info *mii_if)
+{
+	struct net_device *dev = mii_if->dev;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	u16 phy_cntl, phy_caps, ad_caps, status;
+	int timeout;
+	struct ethtool_cmd cmd = { ETHTOOL_GSET };
+	
+	DBG_PRINT_INOUT_FUNC("START");
+	phy_cntl = mdio_read(dev, mii_if->phy_id, MII_BMCR);
+
+	/* Avoid multiple instances */
+	if (private->autoneg_active || !(phy_cntl & BMCR_ANENABLE) )
+		return;
+
+	private->autoneg_active = 1;
+	/* Reset the PHY */
+	phy_cntl = BMCR_RESET;
+	if (private->phy_loopback)
+		phy_cntl |= BMCR_LOOPBACK;
+	DBG_PRINT("%s: Reset PHY\n", __func__);
+	mdio_write(dev, mii_if->phy_id, MII_BMCR, phy_cntl);
+	/* Wait up to 5 seconds for the reset to complete */
+	for (timeout = 10; timeout != 0; timeout--) {
+		phy_cntl = mdio_read(dev, mii_if->phy_id, MII_BMCR);
+		if (!(phy_cntl & BMCR_RESET))
+			break;
+		/* Wait 500 milliseconds */
+		wait_ms(500);
+	}
+	if (timeout == 0) {
+		DBG_PRINT("PHY reset timeout\n");
+		goto out;
+	}
+	/* Read phy & advertising capabilities */
+	DBG_PRINT("%s: set up caps\n", __func__);
+	phy_caps = mdio_read(dev, mii_if->phy_id, MII_BMSR);
+	ad_caps = ADVERTISE_CSMA;
+	if (phy_caps & BMSR_100BASE4)
+		ad_caps |= ADVERTISE_100BASE4;
+	if (phy_caps & BMSR_100FULL)
+		ad_caps |= ADVERTISE_100FULL;
+	if (phy_caps & BMSR_100HALF)
+		ad_caps |= ADVERTISE_100HALF;
+	if (phy_caps & BMSR_10FULL)
+		ad_caps |= ADVERTISE_10FULL;
+	if (phy_caps & BMSR_10HALF)
+		ad_caps |= ADVERTISE_10HALF;
+
+	/* Update auto-negociation advertisement register */
+	mdio_write(dev, mii_if->phy_id, MII_ADVERTISE, ad_caps);
+	/* Read the register back. Some (buggy) PHY won't negociate properly
+	 * if this is not done.
+	 */
+	status = mdio_read(dev, mii_if->phy_id, MII_ADVERTISE);
+	timeout = 30;
+	/* Restart auto-negociation with our new advertisement capabilities */
+	DBG_PRINT("%s: start autonegociation\n", __func__);
+ restart_autoneg:
+	phy_cntl = BMCR_ANRESTART | BMCR_ANENABLE;
+	if (private->phy_loopback)
+		phy_cntl |= BMCR_LOOPBACK;
+	mdio_write(dev, mii_if->phy_id, MII_BMCR, phy_cntl);
+	/* Wait for the auto-negociation to complete.
+	 * This can take up to 3 seconds.
+	 */
+	for (; timeout != 0; timeout--) {
+		status = mdio_read(dev, mii_if->phy_id, MII_BMSR);
+		if (status & BMSR_ANEGCOMPLETE)
+			break;
+		if (status & BMSR_RFAULT) {
+            /* In case of remote fault, restart negociation */
+			DBG_PRINT("%s: restart autonegociation\n", __func__);
+			goto restart_autoneg;
+		}
+		wait_ms(100);
+	}
+	status = mdio_read(dev, mii_if->phy_id, MII_BMSR);
+	if (!(status & BMSR_ANEGCOMPLETE))
+		DBG_PRINT("Auto-negociation timeout\n");
+	else if (status & BMSR_RFAULT)
+		DBG_PRINT("Auto-negociation remote fault\n");
+	else
+		DBG_PRINT("Auto-negociation done\n");
+
+	netdev_get_settings(dev, &cmd);
+	dump_ethtool_cmd(&cmd);
+ out:
+	private->autoneg_active = 0;
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+/* PHY detection */
+/* XXX: to be moved into mii.c */
+int phy_detect (struct net_device *dev, struct mii_if_info *mii_if)
+{
+	int phy_n;
+	int mii_status, phy_id1, phy_id2;
+	
+	DBG_PRINT_INOUT_FUNC("START");
+	mii_if->dev = dev;
+	mii_if->mdio_read = mdio_read;
+	mii_if->mdio_write = mdio_write;
+	mii_if->phy_id_mask = 0x1f;
+	mii_if->reg_num_mask = 0x1f;
+	mii_if->phy_id = -1; /* No PHY found */
+	for (phy_n = 0; phy_n < 32; phy_n++) {
+		DBG_PRINT("%s: check PHY %d\n", __func__, phy_n);
+		mii_status = mdio_read(dev, phy_n, MII_BMSR);
+		phy_id1 = mdio_read(dev, phy_n, MII_PHYSID1);
+		phy_id2 = mdio_read(dev, phy_n, MII_PHYSID2);
+		/* PHY_ID1 is zero in some realtek PHYs */
+		if (/*phy_id1 > 0 &&*/ phy_id1 < 0xFFFF && phy_id1 != 0x8000 &&
+		    phy_id2 > 0 && phy_id2 < 0xFFFF && phy_id2 != 0x8000 &&
+		    mii_status != 0xffff && mii_status != 0x0000) {
+			mii_if->advertising = mdio_read(dev, phy_n, 4);
+			mii_if->phy_id = phy_n;
+			DBG_PRINT(KERN_INFO "%s: MII PHY found at address %d, status "
+			       "0x%4.4x advertising %4.4x Link %4.4x.\n",
+			       dev->name, phy_n, mii_status, mii_if->advertising,
+			       mdio_read(dev, phy_n, 5));
+			/* set IFF_RUNNING */
+			if (mii_status & BMSR_LSTATUS) {
+				DBG_PRINT("%s: netif_carrier_on\n", __func__);
+				netif_carrier_on(dev);
+			}
+			else {
+				DBG_PRINT("%s: netif_carrier_off\n", __func__);
+				netif_carrier_off(dev);
+			}
+			break;
+		}
+	}
+	if (phy_n == 32) {
+		DBG_PRINT("failed to detect PHY\n");
+		return -1;
+	}
+	
+	DBG_PRINT_INOUT_FUNC("END");
+	return phy_n;
+}
+
+/* Getting MAC address from local RAM */
+static int get_mac_address(unsigned long *mac_lo, unsigned long *mac_hi)
+{
+	unsigned long cksum, lo, hi;
+	const unsigned char marker = 'M';
+	
+	DBG_PRINT_INOUT_FUNC("START");
+	lo = em86xx_read_reg(REG_BASE_cpu_block + LR_ETH_MAC_LO);
+	hi = em86xx_read_reg(REG_BASE_cpu_block + LR_ETH_MAC_HI);
+
+	if (((unsigned char)((hi >> 16) & 0xff)) != marker)
+		return(1); /* Not valid MAC */
+	cksum = ((lo & 0xff) + ((lo >> 8) & 0xff) + ((lo >> 16) & 0xff) + ((lo >> 24) & 0xff) + 
+		 (hi & 0xff) + ((hi >> 8) & 0xff)) & 0xff;
+	if (((hi >> 24) & 0xff) != cksum)
+		return(1); /* Not valid MAC */
+	*mac_lo = lo;
+	*mac_hi = hi & 0xffff;
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return(0); /* Got valid MAC */
+}
+
+/* Get the device mac address */
+static int em86xx_get_macaddr(unsigned char *addr)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+#if defined(CONFIG_TANGOX)
+	unsigned long hi, lo;
+	if (get_mac_address(&lo, &hi) == 0) {
+		*addr++ = (hi & 0x0000ff00) >> 8;
+		*addr++ = (hi & 0x000000ff);
+		*addr++ = (lo & 0xff000000) >> 24;
+		*addr++ = (lo & 0x00ff0000) >> 16;
+		*addr++ = (lo & 0x0000ff00) >> 8;
+		*addr   = (lo & 0x000000ff);
+	} else if (tangox_ethernet_getmac(0, addr) == 0) {
+		*addr++ = (def_mac_hi & 0x0000ff00) >> 8;
+		*addr++ = (def_mac_hi & 0x000000ff);
+		*addr++ = (def_mac_lo & 0xff000000) >> 24;
+		*addr++ = (def_mac_lo & 0x00ff0000) >> 16;
+		*addr++ = (def_mac_lo & 0x0000ff00) >> 8;
+		*addr   = (def_mac_lo & 0x000000ff);
+	}
+#else
+#ifdef BOOTLOADER
+	if(	mac_read(addr) == -1) {
+		*addr++ = (def_mac_hi & 0x0000ff00) >> 8;
+		*addr++ = (def_mac_hi & 0x000000ff);
+		*addr++ = (def_mac_lo & 0xff000000) >> 24;
+		*addr++ = (def_mac_lo & 0x00ff0000) >> 16;
+		*addr++ = (def_mac_lo & 0x0000ff00) >> 8;
+		*addr   = (def_mac_lo & 0x000000ff);
+	}
+#else
+#ifdef CONFIG_SD_BOOTLOADER_INTEGRATION
+	{
+		unsigned long lo, hi;
+
+		if (get_mac_address(&lo, &hi) == 0) {
+			def_mac_hi = hi;
+			def_mac_lo = lo;
+		}
+	}
+#endif
+	*addr++ = (def_mac_hi & 0x0000ff00) >> 8;
+	*addr++ = (def_mac_hi & 0x000000ff);
+	*addr++ = (def_mac_lo & 0xff000000) >> 24;
+	*addr++ = (def_mac_lo & 0x00ff0000) >> 16;
+	*addr++ = (def_mac_lo & 0x0000ff00) >> 8;
+	*addr   = (def_mac_lo & 0x000000ff);
+#endif /* BOOTLOADER */	
+#endif /* CONFIG_TANGOX */
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Setting up MAC address of ethernet PHY and device data */
+static int em86xx_set_mac(struct net_device *dev)
+{
+	unsigned long hi_mac, low_mac;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Set up device mac address */
+	if (em86xx_get_macaddr(dev->dev_addr))
+		return(-EIO);
+
+	if (!is_valid_ether_addr(dev->dev_addr))
+		MSG_PRINT("%s: bogus mac address detected.\n", dev->name);
+
+	hi_mac =  (dev->dev_addr[5] << 8)  | dev->dev_addr[4];
+	low_mac = (dev->dev_addr[3] << 24) | (dev->dev_addr[2] << 16) | 
+		  (dev->dev_addr[1] << 8)  | dev->dev_addr[0];
+
+	/* Set up MAC address */
+	em86xx_write_reg(EM86XX_MACAHR_REG, hi_mac);
+	em86xx_write_reg(EM86XX_MACALR_REG, low_mac);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+#ifndef BOOTLOADER
+/* Setting customized mac address */
+static int em86xx_eth_set_macaddr(struct net_device *dev, void *addr)
+{
+	unsigned long hi_mac, low_mac;
+	struct sockaddr *sock = addr;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Check if given address is valid ethernet MAC address */
+	if (!is_valid_ether_addr(sock->sa_data))
+		return(-EIO);
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+	netif_carrier_off(dev); /* Shutdown interface */
+
+	/* Save the customize mac address */
+	memcpy(dev->dev_addr, sock->sa_data, ETH_ALEN);
+	hi_mac  = (dev->dev_addr[5] << 8) | dev->dev_addr[4];
+	low_mac = (dev->dev_addr[3] << 24)| (dev->dev_addr[2] << 16) | 
+		  (dev->dev_addr[1] << 8) | dev->dev_addr[0];
+
+	def_mac_hi = hi_mac;
+	def_mac_lo = low_mac;
+
+	/* Set up MAC address */
+	em86xx_write_reg(EM86XX_MACAHR_REG, hi_mac );
+	em86xx_write_reg(EM86XX_MACALR_REG, low_mac );
+
+	netif_carrier_on(dev);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+#endif /* BOOTLOADER */
+
+/* RTL8201BL is a single-port PHY with an MII/SNI. The MAC layer device can 
+   control a maximum of 31 devices, configured with different PHY addresses
+   (00001b to 11111b). We need to find out which PHY address is using in 
+   order to obtain the mode status after the auto-neotiation is completed.
+
+   There is a module parameter phy_address to be used to override this probe,
+   to set PHY address if one already knew it.
+*/
+static int em86xx_phy_probe(void)
+{
+
+        int phy_addr 	= 0;
+	u16 phy_id 	= 0;
+        u16 phy_status 	= 0;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	if (phy_address < 0) {
+		/* search for total of 31 possible mii phy addresses */
+		for (phy_addr = 1; phy_addr < 32; phy_addr++) {
+			phy_status = em86xx_mii_read(phy_addr,GEN_sts);
+
+			if (phy_status != 0xffff && phy_status != 0x0000)
+				break;
+		}
+	} else {
+		phy_addr = phy_address;
+		phy_status = em86xx_mii_read(phy_addr,GEN_sts);
+	}
+	phy_id =  em86xx_mii_read(phy_addr,GEN_id_lo);
+	MSG_PRINT("Found PHY %04x at Addr = %d Status=0x%x\n", phy_id, phy_addr, phy_status);
+ 
+	DBG_PRINT_INOUT_FUNC("END");
+	return phy_addr;
+}
+
+/* Initialize the ethernet link status, mac, and flow control */
+static int em86xx_link_config(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	struct mii_if_info *mii = &(private->mii_if);
+	unsigned long word = 0;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	// Turn off IRQ and stop receive/transmit 
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+	setup_phy(mii);
+
+	/* set the descriptor base address */
+	em86xx_write_reg(EM86XX_RLBAR_REG, PHYSADDR((u32)private->rxdsc) );
+	em86xx_write_reg(EM86XX_TLBAR_REG, PHYSADDR((u32)private->txdsc));
+
+	/* set bus mode: burst length = 32 | BLE | ~DBO */
+	word = (32 << 8) /*| (1 << 7) | (1 << 20)*/ ;
+	em86xx_write_reg(EM86XX_BMR_REG, word); 
+
+	/* enable MAC flow ctrl */
+	word = (1 << 1);
+	em86xx_write_reg(EM86XX_FCR_REG, word); 
+
+	/* configure MAC ctrller */
+	word = ETH_MAC_FLAGS;
+	word |= MacLoopbackOff; 
+        if (mii->full_duplex)
+                word |= MacFullDuplex;
+        else
+                word &= ~MacFullDuplex;
+	em86xx_write_reg(EM86XX_MACCR_REG, word);
+
+	/* Turn on the IRQ and start receive/transmit */
+	em86xx_write_reg(EM86XX_IER_REG, ETH_IRQ_FLAGS);
+	em86xx_write_reg(EM86XX_CR_REG, ETH_RXTX_FLAGS); 
+
+	netif_carrier_on(dev);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Ethernet hardware initialization */
+static int em86xx_eth_hw_init(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	int rc;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+	/* reset dma engine*/
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOn);
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOff);
+
+	if (em86xx_set_mac(dev))
+		return(-EIO);
+
+	/* stop MAC engine */
+	em86xx_write_reg(EM86XX_CR_REG, 0x0); 
+#ifndef USE_HW_FILTERING
+	/* set up multicast hash table to MCHTHR MCHTLR */
+	/* set multicast hash table to accept all */
+	em86xx_write_reg(EM86XX_MCHTHR_REG, 0xffffffff); 
+	em86xx_write_reg(EM86XX_MCHTLR_REG, 0xffffffff); 
+#else
+	/* clear hash table */
+        em86xx_write_reg( EM86XX_MCHTHR_REG, 0 );
+        em86xx_write_reg( EM86XX_MCHTLR_REG, 0 );
+
+	em86xx_eth_set_multicast_list(dev);
+#endif
+
+	/* resetting descriptors */
+#ifdef BOOTLOADER
+        if (em86xx_eth_reset_desc(dev, &private->reset_flag))
+#else
+        if (em86xx_eth_reset_desc(&em86xx_eth_dev, &private->reset_flag))
+#endif
+		return(-EIO);
+
+	/* configure PHY and speed */
+	rc = em86xx_link_config(dev);
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+#ifndef BOOTLOADER
+/* Monitor the status of link, re-do link initialization if necessary. */
+#ifdef USE_KERNEL_TIMER
+static void em86xx_eth_link_monitor(unsigned long dummy)
+#else
+static int em86xx_eth_link_monitor(void *dummy)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dummy;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+        int link;
+	int res;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+#ifndef USE_KERNEL_TIMER
+	daemonize("em86xx_eth");
+
+	while (private->stop_thread == 0) {
+#endif
+		spin_lock_irqsave(&private->lock, flags);
+		link = mii_link_ok(&private->mii_if);
+		spin_unlock_irqrestore(&private->lock, flags);
+		
+		if (netif_carrier_ok(dev) && !link) {			
+			MSG_PRINT("%s: detected link DOWN.\n", dev->name);
+			netif_carrier_off(dev);
+		}
+		else if (!netif_carrier_ok(dev) && link) {
+			MSG_PRINT("%s: detected link UP.\n", dev->name);
+			res = em86xx_eth_hw_init(dev);
+			netif_carrier_on(dev);
+		}
+
+#ifndef USE_KERNEL_TIMER
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ);
+	}
+#endif
+
+#ifdef USE_KERNEL_TIMER
+	/* Schedule for the next time */
+	mod_timer(&private->eth_timer, jiffies + HZ); 
+	DBG_PRINT_INOUT_FUNC("END (with timer)");
+#else
+	DBG_PRINT_INOUT_FUNC("END (IRQ)");
+	return(0);
+#endif
+}
+#endif
+
+/* Setting rx/tx descriptors */
+static void em86xx_eth_setup_desc(struct net_device *dev)
+{
+	register int i;
+	struct em86xx_desc *desc_ptr = NULL;
+	unsigned long base_addr = 0;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Setup rx descriptor */
+	desc_ptr = (struct em86xx_desc *)(private->rxdsc);
+	for (i = 0; i < (private->num_rxdesc - 1); i++, desc_ptr++) {
+		desc_ptr->desc3 = PHYSADDR((unsigned long)(desc_ptr + 1));
+		desc_ptr->desc1 = (DescChain | R_BUF_SIZE);
+  		desc_ptr->desc0 = DescOwnByDma; 
+	}
+	desc_ptr->desc3 = PHYSADDR((unsigned long)(private->rxdsc));
+	desc_ptr->desc1 = (DescChain | DescEndOfRing | R_BUF_SIZE);
+	desc_ptr->desc0 = DescOwnByDma; 
+
+	/* Setup tx descriptor */
+	desc_ptr = (struct em86xx_desc *)(private->txdsc); 
+	for (i =0;  i < (private->num_txdesc - 1); i++, desc_ptr++) {
+		desc_ptr->desc3 = PHYSADDR((unsigned long)(desc_ptr + 1));
+		desc_ptr->desc1 = (TX_DESC1_FLAGS | T_BUF_SIZE);
+  		desc_ptr->desc0 = DescOwnByCPU;
+	}
+	desc_ptr->desc3 = PHYSADDR((unsigned long)(private->txdsc));
+	desc_ptr->desc1 = (TX_DESC1_FLAGS | DescEndOfRing | T_BUF_SIZE);
+	desc_ptr->desc0 = DescOwnByCPU;
+
+	/* Point rx descriptor to buffer */
+	desc_ptr = (struct em86xx_desc *)(private->rxdsc);
+#ifdef BOOTLOADER 
+      	base_addr = PHYSADDR((unsigned long)(private->rxbuf)); 
+	for (i = 0; i < private->num_rxdesc; i++, desc_ptr++, base_addr += R_BUF_SIZE) 
+		desc_ptr->desc2 = base_addr;
+#else
+        for (i = 0; i < private->num_rxdesc; i++, desc_ptr++){
+                private->rx_skb_list[i] = dev_alloc_skb(R_BUF_SIZE);
+                skb_reserve(private->rx_skb_list[i], 2);
+                desc_ptr->desc2 = PHYSADDR((u32)private->rx_skb_list[i]->data);
+#ifdef CONFIG_NONCOHERENT_IO
+		dma_cache_inv((u32)private->rx_skb_list[i]->data, R_BUF_SIZE);
+#endif
+        }
+#endif
+
+	/* Point tx descriptor to buffer */
+	desc_ptr = (struct em86xx_desc *)(private->txdsc);
+        base_addr = PHYSADDR((unsigned long)(private->txbuf));
+	for (i = 0; i < private->num_txdesc; i++, desc_ptr++, base_addr += T_BUF_SIZE) 
+		desc_ptr->desc2 = base_addr;
+
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+/* Starting up the ethernet device */
+static int em86xx_eth_open(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	DBG_PRINT_INOUT_FUNC("END");
+	if ((dev == NULL) || (private == NULL))
+		return(-EIO);
+	DBG_PRINT("%s: starting interface.\n", dev->name);
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+	/*Get phy address*/
+	private->phy_id = em86xx_phy_probe();
+	em86xx_eth_hw_init(dev);
+
+#ifdef BOOTLOADER
+        dev->state = NETDEV_UP;
+#else
+#ifdef USE_KERNEL_TIMER 
+	/* Schedule timer for monitoring link status */
+	init_timer(&private->eth_timer);
+	private->eth_timer.function = em86xx_eth_link_monitor;
+	private->eth_timer.data = (unsigned long)dev;
+	mod_timer(&private->eth_timer, jiffies + HZ/10);
+#else
+	private->stop_thread = 0;
+	if (kernel_thread(em86xx_eth_link_monitor, dev, CLONE_FS|CLONE_FILES) < 0)
+		return(-ENODEV);
+#endif
+	netif_start_queue(dev);
+#endif /*BOOTLOADER*/
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Stopping the ethernet device */
+static int em86xx_eth_close(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	if (dev == NULL) {
+		DBG_PRINT_INOUT_FUNC("END");
+  		return(-EIO);
+	}
+
+	private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+
+#ifdef BOOTLOADER
+	dev->state = NETDEV_DOWN;
+#else
+
+#ifdef USE_KERNEL_TIMER
+	/* Kill timer */
+	del_timer_sync(&private->eth_timer);
+#else
+	private->stop_thread = 1;
+	schedule_timeout(5*HZ); /* Wait for kernel thread to terminate */
+#endif
+
+	/* Stop the transmit queue */
+	netif_stop_queue(dev);
+	netif_carrier_off(dev);
+
+#endif /*BOOTLOADER*/
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+#ifndef BOOTLOADER
+#ifdef USE_HW_FILTERING
+/* Setup multicast list */
+static void em86xx_eth_set_multicast_list(struct net_device *dev)
+{
+	/* Multicast hash filter */
+        u32 mc_filter[2] = { 0, 0 };
+        int i, rx_mode;
+ 	u8  broadcast_addr[6]  = DEFAULT_BROADCAST_ADDRESS;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	rx_mode =  em86xx_read_reg(EM86XX_MACCR_REG);  
+        DBG_PRINT(KERN_DEBUG"%s:   set_rx_mode(0x%x) done -- rx_mode=0x%x.\n",
+                           dev->name, dev->flags, rx_mode);
+
+        if (dev->flags & IFF_PROMISC) {
+                MSG_PRINT("%s: Promiscuous mode enabled.\n", dev->name);
+                rx_mode |= MacPromiscuousModeOn;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else {
+                struct dev_mc_list *mclist;
+		int n;
+                rx_mode &=  ~MacPromiscuousModeOn;
+                for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+                         i++, mclist = mclist->next){
+			n = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			mc_filter[n >> 5] |= 1 << (n & 31);
+		}
+		n = ether_crc(ETH_ALEN, broadcast_addr) >> 26;
+		mc_filter[n >> 5] |= 1 << (n & 31);
+        }
+	em86xx_write_reg(EM86XX_MACCR_REG, rx_mode );
+        em86xx_write_reg(EM86XX_MCHTLR_REG, mc_filter[0]);
+        em86xx_write_reg(EM86XX_MCHTHR_REG, mc_filter[1]);
+
+	DBG_PRINT_INOUT_FUNC("END");
+        return;
+}
+#endif
+#endif
+
+/* Transmit a packet */
+#ifdef BOOTLOADER
+static int em86xx_eth_tx(struct sk_buff *skb, struct net_device *dev, int async)
+#else
+static int em86xx_eth_tx(struct sk_buff *skb, struct net_device *dev)
+#endif
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	volatile struct em86xx_desc *desc_ptr;
+	struct net_device_stats *stats;
+	unsigned long length, err;
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&private->lock, flags);
+
+	if ((length = ((ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN)) > T_BUF_SIZE) {
+      		DBG_PRINT("em86xx_eth_tx: too big\n");
+		ret = -ENOMEM; 
+		goto out_unlock;
+	}
+
+	stats = &(private->stats);
+
+	/* Send packet to device */
+	desc_ptr = (volatile struct em86xx_desc *)(&private->txdsc[private->next_txidx]);
+	if ((desc_ptr->desc0 & DescOwnByDma) != 0) {
+		stats->tx_dropped++;
+		
+		/* cannot queue anymore */
+		netif_stop_queue(dev);
+		private->need_restart_tx_queue = 1;
+
+        	ERR_PRINT("%s desc_ptr=0x%x: tx error (descriptor not owned by CPU).\n",
+				 dev->name, (u32)desc_ptr);
+		ret = -EIO;
+		goto out_unlock;
+	} 
+
+	/* Check if previous transmission has error */
+	if ((err = (desc_ptr->desc0 & TX_ERROR_FLAGS)) != 0) {
+		int i;
+		ERR_PRINT("%s: got a tx error:0x%08lx\n", dev->name, desc_ptr->desc0);
+		for (i = TX_ERRORS_START; (i < TX_ERRORS) && (err != 0); i++) {
+			int *ptr;
+			if (err & (1 << i)) {
+				err &= ~(1<<i);
+				if (tx_error_msg[i] != NULL)
+					ERR_PRINT("%s\n",tx_error_msg[i]);
+				if (tx_stat_offset[i] >= 0) {
+					ptr = (int *)(((char *)stats) + tx_stat_offset[i]);
+					*ptr++;
+				}
+			}
+		}
+
+		/* Update stats */
+ 		stats->collisions += (desc_ptr->desc0 >> 3) & 15;
+		stats->tx_errors++;
+		stats->tx_packets--;
+		stats->tx_bytes -= (desc_ptr->desc1 & DescSize1Mask);
+	}
+
+	/* Copy packet data to tx buffer */
+//	DBG_PRINT("tx copy data from skb->data=0x%x to desc2=0x%x length=0x%x\n",
+//		(u32)skb->data, (u32)desc_ptr->desc2, (u32)length );
+
+	memcpy((void *)NON_CACHED(desc_ptr->desc2), skb->data, length);
+
+	/* Setup tx descriptor */
+	desc_ptr->desc1 = ( TX_DESC1_FLAGS | length );
+	if (private->next_txidx == (private->num_txdesc - 1))
+		desc_ptr->desc1 |=  DescEndOfRing ;
+	desc_ptr->desc0 |= DescOwnByDma;
+
+	/* Start transmission (should be in suspend mode already) */
+	em86xx_write_reg(EM86XX_TPDR_REG, 0x1);
+
+#ifdef BOOTLOADER
+        private->next_txidx = imodulus((private->next_txidx + 1), private->num_txdesc);
+#else
+	private->next_txidx = ((private->next_txidx + 1) % private->num_txdesc);
+	dev->trans_start = jiffies;
+#endif
+	/* Update stats */
+	stats->tx_packets++;
+	stats->tx_bytes += length;
+
+	/* Check to see if TX queue is full */
+	desc_ptr = (volatile struct em86xx_desc *)(&private->txdsc[private->next_txidx]);
+	if ((desc_ptr->desc0 & DescOwnByDma) != 0) {
+		/* cannot queue anymore */
+		netif_stop_queue(dev);
+		private->need_restart_tx_queue = 1;
+	} 
+
+	/* Free up socket buffer */
+#ifdef BOOTLOADER
+	async = 0;
+	skb_free(skb);
+#else
+	dev_kfree_skb(skb);
+#endif
+ out_unlock:
+	spin_unlock_irqrestore(&private->lock, flags);
+	return ret;
+}
+
+
+static inline int is_sw_filtered_packet(struct net_device *dev, unsigned char *data)
+{
+#ifdef USE_SW_FILTERING
+        if (((data[0] & 0x80) == 0) && (dev->dev_addr[5] != data[5])) {
+                return 1;
+	}
+        else {
+                return 0;
+	}
+#else
+        return 0;
+#endif
+}
+
+
+/* Receiving packet(s) */
+static int em86xx_eth_rx(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private;
+#ifdef BOOTLOADER
+	struct sk_buff *skb;
+#endif
+	struct net_device_stats *stats;
+	unsigned char *data;
+	volatile struct em86xx_desc *desc_ptr;
+	unsigned long length;
+	unsigned long dsc;
+	unsigned long count=0, cnt= 0, err;
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+	volatile struct em86xx_desc *mdf_desc_ptr;
+	long mdf_start = -1;
+#endif
+//	unsigned long flags;
+
+  	private = (EM86XX_ETH_PRIV *)dev->priv;
+  	stats = &(private->stats);
+
+	/* Go thru descriptors list until we ran out or encounterred
+	   the one being processed by DMA */
+#ifdef BOOTLOADER 
+	for (cnt = 0, count = private->last_rxidx; cnt < private->num_rxdesc; cnt++, count = imodulus(count + 1, private->num_rxdesc)) {
+#else
+	for (cnt = 0, count = private->last_rxidx; cnt < private->num_rxdesc; cnt++, count = ((count + 1) % private->num_rxdesc)) {
+#endif
+
+		desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[count]);
+	 	dsc = desc_ptr->desc0;
+
+	  	if ((dsc & DescOwnByDma) != 0) {
+    			/* DMA is processing this one, break out the loop */
+			break;
+    		}
+
+		/*filter out those are not for me */
+      		data = (unsigned char *)NON_CACHED(desc_ptr->desc2);
+		if (is_sw_filtered_packet(dev, data)
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+		    && (mdf_start < 0)
+#endif
+				) {
+			ERR_PRINT("%s: mac mismatched, dropped.\n", dev->name);
+		} else	if ((err = (dsc & RX_ERROR_FLAGS)) != 0)  {
+			int i;
+
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+			 /* First check are we in MDF mode */
+			 if (mdf_start >= 0) { /* Yes, we are */
+				 MSG_PRINT("%s: rx error in MDF mode (s:0x%x,c:0x%x)\n", dev->name, mdf_start, count);
+				 /* Something is wrong, drop all MDF related descriptors */
+				 for (i = mdf_start; i != count; i = (i + 1) % private->num_rxdesc) {
+					 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+					 mdf_desc_ptr->desc0 = DescOwnByDma;
+					 wmb();
+				 }
+				 mdf_start = -1; /* Reset so we're out of this mode */
+			 }
+#endif
+			/*Filtering fail is valid only when Last desc bit is set, 
+			  length is 64 bytes or longer and Receive All bit is set. */
+			if (dsc & DescFilteringFail) {		
+				unsigned long len, rx_mode;
+				len = (dsc & DescFrameLengthMask) >> DescFrameLengthShift;
+				rx_mode = em86xx_read_reg(EM86XX_MACCR_REG);
+				if(!((dsc & DescRxLast) && (len >= 64) && (rx_mode & MacFilterOff)))
+					goto sync_up;
+			}
+
+      			ERR_PRINT("%s: rx error 0x%08lx:%ld desc2=0x%08x\n", 
+				dev->name, dsc, count, (u32)desc_ptr->desc2);
+
+			for (i = RX_ERRORS_START; (i < RX_ERRORS) && (err != 0); i++) {
+				int *ptr;
+				if (err & (1 << i)) {
+					err &= ~(1<<i);
+					if (rx_error_msg[i] != NULL)
+						ERR_PRINT("%s\n", rx_error_msg[i]);
+					if (rx_stat_offset[i] >= 0) {
+						ptr = (int *)(((char *)stats) + rx_stat_offset[i]);
+						*ptr++;
+					}
+				}
+			}
+
+			/* We dropped any error descriptor */
+		        stats->rx_errors++;
+		 } else if ((dsc & MD_FRAME_FLAGS) != MD_FRAME_FLAGS) {
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+			 /* We encounterred multi-descriptor frame */
+			 if (((dsc & DescRxFirst) != 0) && ((dsc & DescRxLast) == 0)) {
+				 /* First descriptor of multi-descriptor frame */
+				 if (mdf_start >= 0) { 
+					 int i;
+					 MSG_PRINT("%s: MDF mode error at beginning (s:0x%x,c:0x%x)\n", dev->name, mdf_start, count);
+					 /* Something is wrong, drop all MDF related descriptors */
+					 for (i = mdf_start; i != count; i = (i + 1) % private->num_rxdesc) {
+						 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+						 mdf_desc_ptr->desc0 = DescOwnByDma;
+						 wmb();
+					 }
+				 }
+				 mdf_start = (long)count;
+				 continue; /* Loop until we can get the whole frame */
+			 } else if ((dsc & MD_FRAME_FLAGS) == 0) {
+				 if (mdf_start >= 0) {
+					 /* Interim descriptor within multi-descriptor frame */
+					 continue; /* Loop until we can get the whole frame */
+				 } else {
+					 MSG_PRINT("%s: MDF mode error (c:0x%x)\n", dev->name, count);
+					 /* Bogus: drop it */
+					 goto sync_up;
+				 }
+			 } else {
+				 /* Last descriptor of multi-descriptor frame */
+				 unsigned long mdf_size, length;
+				 long i, mdf_end;
+				 char *ptr, *mdf_data;
+				 struct sk_buff *mdf_skb;
+
+				 if (mdf_start < 0) {
+					 MSG_PRINT("%s: MDF mode error at the end (c:0x%x)\n", dev->name, count);
+					 /* Bogus: drop it */
+					 goto sync_up;
+				 }
+
+				 /* First we get the size of the frame, and allocate a new skb */
+				 length = mdf_size = (dsc & DescFrameLengthMask) >> DescFrameLengthShift;
+				 mdf_end = (count + 1) % private->num_rxdesc;
+#ifdef BOOTLOADER
+				 mdf_skb = skb_alloc(mdf_size);
+#else
+				 mdf_skb = dev_alloc_skb(mdf_size);
+#endif
+				 if (mdf_skb == NULL) {
+					 /* Error: no memory available, dropping all descriptors in this frame */
+					 stats->rx_dropped += (((mdf_start + private->num_rxdesc) - mdf_end) % private->num_rxdesc);
+					 for (i = mdf_start; i != mdf_end; i = (i + 1) % private->num_rxdesc) {
+						 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+						 mdf_desc_ptr->desc0 = DescOwnByDma;
+						 wmb();
+					 }
+				 } else {
+#ifndef BOOTLOADER
+					 skb_reserve(mdf_skb, 2);
+#endif
+					 stats->rx_bytes += mdf_size;
+					 stats->rx_packets += (((mdf_start + private->num_rxdesc) - mdf_end) % private->num_rxdesc);
+
+					 /* Collecting all descriptors into skb  */
+					 for (ptr = mdf_skb->data, i = mdf_start; i != mdf_end; i = (i + 1) % private->num_rxdesc) {
+						 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+						 mdf_data = (unsigned char *)NON_CACHED(mdf_desc_ptr->desc2);
+						 memcpy(ptr, mdf_data, (length > R_BUF_SIZE) ? R_BUF_SIZE : length);
+						 ptr += R_BUF_SIZE;
+						 length -= R_BUF_SIZE;
+						 mdf_desc_ptr->desc0 = DescOwnByDma;
+						 wmb();
+					 }
+					 mdf_skb->dev = dev;
+					 mdf_skb->len = mdf_size - 4;
+
+					 /* Send the frame back up */
+#ifdef BOOTLOADER
+					 skb_put(mdf_skb);
+#else
+					 mdf_skb->protocol = eth_type_trans(mdf_skb, dev);
+					 mdf_skb->ip_summed = CHECKSUM_NONE;
+					 dev->last_rx = jiffies;
+					 netif_rx(mdf_skb);
+#endif
+				 }
+				 mdf_start = -1;
+				 continue; /* No need go to the end of the loop */
+			}
+#else
+			/* We encounterred multi-descriptor frame */
+	        	DBG_PRINT("%s: multi-descriptor frame detected 0x%08lx\n", dev->name, dsc);
+		        /* Don't handle multi-descriptor frame */
+		        stats->rx_dropped++;
+#endif /* MULTI_DESCS_FRAME_SUPPORT */
+		 } else if ((length = ((dsc & DescFrameLengthMask) >> DescFrameLengthShift)) > R_BUF_SIZE) {
+			/* Should not happen for single-descriptor frame */
+      			ERR_PRINT("%s: rx dropped (size too large: %ld)\n", dev->name, length);
+			stats->rx_length_errors++;	
+			stats->rx_dropped++;
+#ifdef BOOTLOADER
+                 } else if ((skb = skb_alloc(length)) == NULL) {
+			ERR_PRINT("%s: rx dropped (memory unavailable)\n", dev->name);
+	        	stats->rx_dropped++;
+#endif
+		 } else {
+			 /* We got single descriptor frame */
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+			 /* First check are we in MDF mode */
+			 if (mdf_start >= 0) { /* Yes, we are */
+				 int i;
+				 /* Something is wrong, drop all MDF related descriptors */
+				 for (i = mdf_start; i != count; i = (i + 1) % private->num_rxdesc) {
+					 mdf_desc_ptr = (volatile struct em86xx_desc *)(&private->rxdsc[i]);
+					 mdf_desc_ptr->desc0 = DescOwnByDma;
+				 }
+				 mdf_start = -1; /* Reset so we're out of this mode */
+			 }
+#endif
+#ifdef BOOTLOADER
+		  	 skb->dev = dev;
+                         skb->len = length - 4;
+                         memcpy(skb->data, data, length-4);
+                         skb_put(skb);
+
+                         /* Update stats */
+                         stats->rx_packets++;
+                         stats->rx_bytes += length;
+#else
+                         private->rx_skb_list[count]->dev = dev;
+                         private->rx_skb_list[count]->len = length-4;
+                         private->rx_skb_list[count]->protocol = eth_type_trans(private->rx_skb_list[count], dev);
+                         private->rx_skb_list[count]->ip_summed = CHECKSUM_NONE;
+
+                         /* Send the packet to kernel */
+                         netif_rx(private->rx_skb_list[count]);
+
+	        	 /* Update stats */
+		       	 stats->rx_packets++;
+		         stats->rx_bytes += length;
+		       	 dev->last_rx = jiffies;
+#endif /*BOOTLOADER*/
+  	 	}
+#ifndef BOOTLOADER
+                private->rx_skb_list[count] = dev_alloc_skb(R_BUF_SIZE);
+                skb_reserve(private->rx_skb_list[count], 2);
+                desc_ptr->desc2 = PHYSADDR((u32)private->rx_skb_list[count]->data);
+#ifdef CONFIG_NONCOHERENT_IO
+		dma_cache_inv((u32)private->rx_skb_list[count]->data, R_BUF_SIZE);
+#endif
+#endif
+
+sync_up:
+  		desc_ptr->desc0 = DescOwnByDma;
+		wmb();
+  	}
+
+#ifdef MULTI_DESCS_FRAME_SUPPORT
+	/* This is the last desc we read */
+	if (mdf_start >= 0)
+		/* We haven't reached the end of multi-descriptor frame, mark it here
+		 * so we can come back and pick it up again */
+		private->last_rxidx = mdf_start; 
+	else
+		private->last_rxidx = count; 
+#else
+	/* This is the last desc we read */
+	private->last_rxidx = count; 
+#endif
+	/* make sure rx is not suspended */
+	em86xx_write_reg(EM86XX_RPDR_REG, 0x1);
+  	return cnt;
+}
+
+/* Resetting rx descriptor: error recovery for "rx buf unavailable" */
+static void em86xx_eth_reset_rx_buf(struct net_device *dev)
+{
+	register int i;
+	volatile struct em86xx_desc *desc_ptr = NULL;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	em86xx_clear_reg(EM86XX_CR_REG, DmaRxStart); 
+
+	/* Reset rx desc */
+	desc_ptr = (struct em86xx_desc *)(private->rxdsc); 
+	for (i = 0; i < private->num_rxdesc; i++, desc_ptr++) 
+		desc_ptr->desc0 = DescOwnByDma; 
+  	
+  	em86xx_write_reg(EM86XX_RPDR_REG,  0x1);
+	em86xx_set_reg(EM86XX_CR_REG, DmaRxStart); 
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+#ifndef BOOTLOADER
+/* Get the stats information */
+static struct net_device_stats *em86xx_eth_stats(struct net_device *dev)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	if (dev != NULL) {
+		DBG_PRINT_INOUT_FUNC("END");
+    		return(&(((EM86XX_ETH_PRIV *)dev->priv)->stats));
+	}
+  	else {
+		DBG_PRINT_INOUT_FUNC("END");
+    		return(NULL);
+	}
+
+}
+#endif
+
+/* Ethernet interrupt handler */
+#ifdef BOOTLOADER
+static void em86xx_eth_intr_handler(int irq, void *dev_id)
+#else
+static irqreturn_t em86xx_eth_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+#endif
+{
+	int num_rx_desc_freed = 0;
+	unsigned long status;
+	struct net_device *dev = (struct net_device *)dev_id;
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+
+#ifdef BOOTLOADER
+        if( memcmp(dev->name,DRIVER, sizeof(DRIVER)) != 0) 
+                return;
+#else
+        if (dev_id != (void *)&em86xx_eth_dev)
+                return IRQ_NONE;
+#endif
+        /* Check status */
+        status = em86xx_read_reg(EM86XX_SR_REG);
+
+        // clear all interrupt requests
+        em86xx_write_reg(EM86XX_SR_REG, status) ;
+
+        if (status & DmaIntNormal) {
+                if (status & DmaIntRxCompleted) {
+	                num_rx_desc_freed = em86xx_eth_rx(dev);
+		}
+                else if(status & DmaIntTxCompleted){
+			if(private->need_restart_tx_queue){
+				private->need_restart_tx_queue = 0;
+				netif_start_queue(dev);
+			}
+/*			else if (status & DmaIntTxCompleted ) {
+				ERR_PRINT("\t%s: DmaIntTxCompleted : Transmit completed (Normal)\n", dev->name);
+			}
+			else if (status & DmaIntTxNoBuffer ) {
+				ERR_PRINT("\t%s: DmaIntTxNoBuffer : Transmit buffer unavailable (Normal)\n", dev->name);
+			}
+			else if (status & DmaIntRxCompleted ) {
+				ERR_PRINT("\t%s: DmaIntRxCompleted : Completion of frame reception (Normal)\n", dev->name);
+			}
+			else if (status & DmaIntEarlyRx) {
+				ERR_PRINT("\t%s: DmaIntEarlyRx : Early receive interrupt (Normal)\n", dev->name);
+			}
+*/
+		}
+		else {
+                        ERR_PRINT("%s: unhandled NIS 0x%08lx\n", dev->name, status);
+		}
+	}
+ 
+	if (status & DmaIntAbnormal) { 
+                if (status & DmaIntRxNoBuffer) {
+			if (num_rx_desc_freed == 0)
+	                	num_rx_desc_freed = em86xx_eth_rx(dev);
+
+			if(num_rx_desc_freed == 0){
+                        	ERR_PRINT("%s: receive buffer unavailable 0x%08lx\n", dev->name, status);
+                        	em86xx_eth_reset_rx_buf(dev);			
+			}		
+                } else if (status & DmaIntRxStopped) {
+                        ERR_PRINT("%s: receive process stopped\n", dev->name);
+                        em86xx_set_reg(EM86XX_CR_REG, DmaRxStart); 
+                } else if (status & DmaIntTxStopped ) {
+                        ERR_PRINT("%s: transmit process stopped\n", dev->name);
+                        em86xx_write_reg(EM86XX_CR_REG, DmaTxStart); 
+                } else if (status & DmaIntTxUnderflow) {
+                        ERR_PRINT("%s: transmit underflow\n", dev->name);
+                } else if (status & DmaIntEarlyTx ) {
+                        ERR_PRINT("%s: Early transmit interrupt\n", dev->name);
+                } else if (status & DmaIntBusError ) {
+                        ERR_PRINT("%s: Fatal bus error\n", dev->name);
+			if (status & DmaRxAbort) {
+				ERR_PRINT("\t%s : DmaRxAbort : receiver bus abort\n", dev->name);
+			}
+			else if (status & DmaTxAbort) {
+				ERR_PRINT("\t%s : DmaTxAbort : transmitter bus abort\n", dev->name);
+			}
+                } else {
+                        ERR_PRINT("%s: unhandled AIS 0x%08lx\n", dev->name, status);
+                }
+        }
+ 
+	if ((status & (DmaIntAbnormal | DmaIntNormal)) == 0) {
+#ifdef DEBUG_RX_TX_STATE
+		unsigned long st;
+#endif
+                DBG_PRINT("%s: Unhandled SR 0x%08lx --> %s %s\n", dev->name, status, (status & DmaTxState)?"DmaTxState":"", (status & DmaRxState)?"DmaRxState":"");
+#ifdef DEBUG_RX_TX_STATE
+		if (status & DmaTxState) {
+			st = (status & DmaTxState);
+			ERR_PRINT("\t%s: DmaTxState : Transmit process state (status == 0x%X)\n", dev->name, st);
+			switch (st){
+			case DmaTxStopped:
+				ERR_PRINT("\t%s: DmaTxStopped : Stopped\n", dev->name);
+				break;
+			case DmaTxFetching:
+				ERR_PRINT("\t%s: DmaTxFetching : Running - fetching the descriptor\n", dev->name);
+				break;
+			case DmaTxWaiting:
+				ERR_PRINT("\t%s: DmaTxWaiting : Running - waiting for end of transmission\n", dev->name);
+				break;
+			case DmaTxReading:
+				ERR_PRINT("\t%s: DmaTxReading : Running - reading the data from memory\n", dev->name);
+				break;
+			case DmaTxSuspended:
+				ERR_PRINT("\t%s: DmaTxSuspended : Suspended\n", dev->name);
+				break;
+			case DmaTxClosing:
+				ERR_PRINT("\t%s: DmaTxClosing : Running - closing descriptor\n", dev->name);
+				break;
+			default:
+				ERR_PRINT("\t%s: UNKNOWN Tx state\n", dev->name);
+				break;
+			}
+		}
+		
+		if (status & DmaRxState) {
+			st = (status & DmaRxState);
+			ERR_PRINT("\t%s: DmaRxState : Receive process state (status == 0x%X)\n", dev->name, st);
+			switch (st){
+			case DmaRxStopped: 
+				ERR_PRINT("\t%s: DmaRxStopped : Stopped\n", dev->name); 
+				break;
+			case DmaRxFetching:
+				ERR_PRINT("\t%s: DmaRxFetching : Running - fetching the descriptor\n", dev->name); 
+				break;
+			case DmaRxChecking:
+				ERR_PRINT("\t%s: DmaRxChecking : Running - checking for end of packet \n", dev->name);
+				break;
+			case DmaRxWaiting:
+				ERR_PRINT("\t%s: DmaRxWaiting : Running - waiting for packet\n", dev->name);
+				break;
+			case DmaRxSuspended:
+				ERR_PRINT("\t%s: DmaRxSuspended : Suspended\n", dev->name);
+				break;
+			case DmaRxClosing:
+				ERR_PRINT("\t%s: DmaRxClosing : Running - closing descriptor\n", dev->name);
+				break;
+			case DmaRxFlushing:
+				ERR_PRINT("\t%s: DmaRxFlushing : Running - flushing the current frame\n", dev->name);
+				break;
+			case DmaRxQueuing:
+				ERR_PRINT("\t%s: DmaRxQueuing : Running - queuing the recieve frame into host memory\n", dev->name);
+				break;
+			default:
+				ERR_PRINT("\t%s: UNKNOWN Rx state\n", dev->name);
+				break;
+			}
+		}
+#endif
+        }
+	
+#ifdef BOOTLOADER
+	 return;
+#else
+        return IRQ_HANDLED;
+#endif
+ }
+
+static void netdev_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, "GBUS");
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+static int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+	int rc;
+
+	DBG_PRINT_INOUT_FUNC("START");
+        spin_lock_irqsave(&private->lock, flags);
+	rc = mii_ethtool_gset(&private->mii_if, cmd);
+        spin_unlock_irqrestore(&private->lock, flags);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+	int rc;
+
+	DBG_PRINT_INOUT_FUNC("START");
+        spin_lock_irqsave(&private->lock, flags);
+	rc = mii_ethtool_sset(&private->mii_if, cmd);
+        spin_unlock_irqrestore(&private->lock, flags);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static int netdev_nway_reset(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	int rc;
+	DBG_PRINT_INOUT_FUNC("START");
+	rc = mii_nway_restart(&private->mii_if);
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static u32 netdev_get_link(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+	int rc;
+	DBG_PRINT_INOUT_FUNC("START");
+	rc = mii_link_ok(&private->mii_if);
+	DBG_PRINT_INOUT_FUNC("END");
+	return rc;
+}
+
+static u32 netdev_get_msglevel(struct net_device *dev)
+{
+	DBG_PRINT_INOUT_FUNC("START");
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+static void netdev_set_msglevel(struct net_device *dev, u32 value)
+{
+}
+
+static struct ethtool_ops netdev_ethtool_ops = {
+	.get_drvinfo		= netdev_get_drvinfo,
+	.get_settings		= netdev_get_settings,
+	.set_settings		= netdev_set_settings,
+	.nway_reset		= netdev_nway_reset,
+	.get_link		= netdev_get_link,
+	.get_msglevel		= netdev_get_msglevel,
+	.set_msglevel		= netdev_set_msglevel,
+	.get_sg			= ethtool_op_get_sg,
+	.get_tx_csum		= ethtool_op_get_tx_csum,
+};
+
+#ifndef BOOTLOADER
+/* Handling ioctl call */
+//static int em86xx_eth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+static int em86xx_eth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+#if 1
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        int ret;
+        unsigned long flags;
+
+        spin_lock_irqsave(&private->lock, flags);
+        ret = generic_mii_ioctl(&private->mii_if, if_mii(ifr), cmd, NULL);
+        spin_unlock_irqrestore(&private->lock, flags);
+
+        return ret;
+
+#else
+	EM86XX_ETH_PRIV *private = (EM86XX_ETH_PRIV *)dev->priv;
+        unsigned long flags;
+	int ret = 0;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+	struct ifr_data_struct
+ 	{
+		u32 unit;
+    		u32 addr;
+    		u32 data;
+  	} *req = (struct ifr_data_struct *)ifr->ifr_data;
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	if (!netif_running(dev)) {
+		DBG_PRINT( "%s : ioctl, but device not running !!\n", dev->name);
+		return -EINVAL;
+	}
+
+        spin_lock_irqsave(&private->lock, flags);
+	
+	if( req->unit == 3 ) {
+		DBG_PRINT( "em86xx::read/write MII registers(%s, cmd=%08x) unit=0x%x  reg=0x%x\n", 
+			   dev->name, cmd, req->unit, req->addr );
+		ret = generic_mii_ioctl(&private->mii_if, data, cmd, NULL);
+	}
+	else {
+		switch( cmd ) {
+		case SIOCDEVPRIVATE:  
+			DBG_PRINT( "em86xx::read registers(%s, cmd=%08x) unit=0x%x  reg=0x%x\n", 
+				   dev->name, cmd, req->unit, req->addr );
+			
+			if( req->unit == 0 ){        /* Read register */
+      				req->data = em86xx_read_reg( req->addr );
+    			}
+			else if( req->unit == 1 ){   /* Read MAC register */
+      				req->data = em86xx_read_mac_reg( req->addr );
+    			}
+    			else if( req->unit == 2 ) {   /* Read DMA register */
+      				req->data = em86xx_read_dma_reg( req->addr );
+    			}
+			else {
+				DBG_PRINT( "Unknow read request : %d\n", req->unit);
+				ret = -EOPNOTSUPP;
+			}
+    			break;
+  		case SIOCDEVPRIVATE+1:                /* Write registers */
+			DBG_PRINT( "em86xx::write registers(%s, cmd=%08x) unit=0x%x reg=0x%x data=0x%x\n", 
+				    dev->name, cmd ,req->unit, req->addr, req->data);
+
+    			if( req->unit == 0 ) {        /* Write register */
+      				em86xx_write_reg( req->addr, req->data );
+    			}
+    			else if( req->unit == 1 ) {        /* Write MAC register */
+      				em86xx_write_mac_reg( req->addr, req->data );
+    			}
+    			else if( req->unit == 2 ) {   /* Write DMA register */
+      				em86xx_write_dma_reg( req->addr, req->data );
+    			}
+			else {
+				DBG_PRINT( "Unknow write request : %d\n", req->unit);
+				ret = -EOPNOTSUPP;
+			}
+    			break;			
+		default:
+			DBG_PRINT( "Unknow cmd : %d\n", cmd);
+    			ret = -EOPNOTSUPP;
+		}
+	}
+	
+        spin_unlock_irqrestore(&private->lock, flags);
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return ret;
+#endif
+}
+#endif
+
+/* Kernel level ethernet initialization */
+static int em86xx_eth_init(struct net_device *dev)
+{
+	EM86XX_ETH_PRIV *private;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+	em86xx_write_reg(EM86XX_SR_REG, em86xx_read_reg(EM86XX_SR_REG));
+
+	if (dev == NULL)
+  		goto failed;
+
+	private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	/* Initialize private data */
+	spin_lock_init(&private->lock);
+	
+	private->rxdsc = (volatile struct em86xx_desc *)NON_CACHED((u32)private->eth_rxdsc);
+	private->txdsc = (volatile struct em86xx_desc *)NON_CACHED((u32)private->eth_txdsc);
+	private->rxbuf = (volatile unsigned char *)NON_CACHED((u32)private->eth_rxbuf);
+	private->txbuf = (volatile unsigned char *)NON_CACHED((u32)private->eth_txbuf);
+
+	/* Ethernet device initialization */
+#ifdef BOOTLOADER
+        /* Fill in the fields of the device structure with ethernet-generic values.*/
+//      dev->type               = ARPHRD_ETHER;
+        dev->mtu                = ETH_DATA_LEN; /* eth_mtu */
+        dev->addr_len           = ETH_ALEN;
+        memset(dev->broadcast, 0xff, ETH_ALEN);
+        dev->hard_header_len = ETH_HLEN;
+#else
+	ether_setup(dev);
+#endif
+
+	/* reset dma engine*/
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOn);
+	em86xx_write_reg(EM86XX_BMR_REG, DmaResetOff);
+
+	if (em86xx_set_mac(dev))
+  		goto failed;
+
+	/* Hook up with handlers */
+#ifdef BOOTLOADER
+        dev->send_packet         = em86xx_eth_tx;
+        dev->open                = em86xx_eth_open;
+        dev->close               = em86xx_eth_close;
+#else
+	dev->get_stats		 = em86xx_eth_stats;
+	dev->hard_start_xmit	 = em86xx_eth_tx;
+	dev->open		 = em86xx_eth_open;
+	dev->stop		 = em86xx_eth_close;
+#ifdef USE_HW_FILTERING
+	dev->set_multicast_list  = em86xx_eth_set_multicast_list;
+#endif
+	dev->do_ioctl		 = em86xx_eth_ioctl;
+	dev->set_mac_address	 = em86xx_eth_set_macaddr;
+        dev->ethtool_ops         = &netdev_ethtool_ops;
+
+	dev->tx_queue_len = private->num_txdesc; 
+//	dev->flags &= ~IFF_MULTICAST;
+//	dev->flags |= IFF_DEBUG;
+#endif
+	DBG_PRINT("Detect PHY\n");
+	if (phy_detect(dev, &private->mii_if) < 0) {
+		DBG_PRINT_INOUT_FUNC("END");
+		return -ENODEV;
+	}
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+
+failed:
+	DBG_PRINT_INOUT_FUNC("END");
+	return(-EIO);
+}
+
+static int em86xx_eth_reset_desc(struct net_device *dev, int *reset)
+{
+	EM86XX_ETH_PRIV *private;
+	int i;
+
+	DBG_PRINT_INOUT_FUNC("START");
+	if (dev == NULL)
+  		return(-EIO);
+	else
+		private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	if (*reset) {
+		memset((void*)&private->stats, 0, sizeof(struct net_device_stats));
+		memset((void*)&private->mii_if, 0, sizeof(struct mii_if_info));
+		private->autoneg_active = 0;
+		private->phy_loopback = 0;	
+
+#ifndef BOOTLOADER
+
+#ifdef USE_KERNEL_TIMER 
+		memset((void*)&private->eth_timer, 0, sizeof(struct timer_list));
+#endif
+		private->need_restart_tx_queue = 0; 
+#endif
+	}
+
+	*reset = 0;
+
+	/* Clear all tx/rx buffer memory */
+	memset((void *)(private->rxbuf), 0, private->num_rxdesc * R_BUF_SIZE);
+	memset((void *)(private->txbuf), 0, private->num_txdesc * T_BUF_SIZE);
+
+	/* Initialize the indices */
+	private->last_rxidx = 0;
+	private->next_txidx = 0;
+
+#ifndef BOOTLOADER
+	if (private->rx_skb_list != NULL) {
+		for (i = 0; i < private->num_rxdesc; i++) {
+			if (private->rx_skb_list[i] != NULL)
+				dev_kfree_skb(private->rx_skb_list[i]);
+		}
+	}
+	memset((void *)private->rx_skb_list, 0, sizeof(struct skb_buff *) * private->num_rxdesc);
+#endif
+
+	/* Intialize the descriptors */
+	em86xx_eth_setup_desc(dev);
+
+	phy_detect(dev, &private->mii_if);
+
+
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+}
+
+/* Driver installation: this is where the thing starts */
+#ifdef BOOTLOADER
+int em86xx_eth_probe(struct net_device *dev)
+#else
+static int __init em86xx_eth_startup(void)
+#endif
+{
+#ifndef BOOTLOADER
+	struct net_device *dev 	= &em86xx_eth_dev;
+#endif
+	int err = 0, i;
+	EM86XX_ETH_PRIV *private= NULL;
+#ifndef STATIC_BUF_ALLOC
+	unsigned long max_num_rxdsc, max_num_txdsc;
+	unsigned long rxbuf_size, txbuf_size;
+#endif
+
+	DBG_PRINT_INOUT_FUNC("START");
+#if defined(CONFIG_TANGOX)
+        extern int tangox_ethernet_enabled(int);
+        if (tangox_ethernet_enabled(0) == 0) {
+                MSG_PRINT(KERN_WARNING "TangoX builtin ethernet is disabled.\n");
+                return(0);
+        }
+#endif
+	/* Turn off IRQ and stop receive/transmit */
+	em86xx_write_reg(EM86XX_CR_REG, 0);
+	em86xx_write_reg(EM86XX_IER_REG, 0);
+	em86xx_write_reg(EM86XX_SR_REG, em86xx_read_reg(EM86XX_SR_REG));
+
+	if(dev != NULL) {
+		if(dev->priv != NULL) {
+			private = (EM86XX_ETH_PRIV *)dev->priv;
+			if (private->dev_count != 0) {
+				err = -EIO;
+				goto failed;
+			} 
+		}
+	}
+
+	/* Allocate memory for private data */
+#ifdef BOOTLOADER
+        dev->priv = private = (EM86XX_ETH_PRIV *)malloc(sizeof(EM86XX_ETH_PRIV));//, GFP_KERNEL);
+#else
+	
+	DBG_PRINT("KMALLOC\n");
+	dev->priv = private = (EM86XX_ETH_PRIV *)kmalloc(sizeof(EM86XX_ETH_PRIV), GFP_KERNEL);
+#endif
+	if (dev->priv == NULL) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	memset(dev->priv, 0, sizeof(EM86XX_ETH_PRIV));
+
+	private->num_rxdesc = num_rxdesc_param;;
+	private->num_txdesc = num_txdesc_param;
+
+	DBG_PRINT("private->num_rxdesc = %lu, private->num_txdesc = %lu \n", private->num_rxdesc, private->num_txdesc);
+#ifndef STATIC_BUF_ALLOC	
+	DBG_PRINT("NON STATIC_BUF_ALLOC\n");
+	/* Validating module parameters */
+	max_num_rxdsc = max_num_txdsc = PAGE_SIZE / (2 * sizeof(struct em86xx_desc));
+ #ifdef BOOTLOADER
+	DBG_PRINT("BOOTLOADER\n");
+	if (((private->num_rxdesc < MIN_NUM_RDESC) || (private->num_rxdesc > max_num_rxdsc)) ||
+	    ((private->num_txdesc < MIN_NUM_TDESC) || (private->num_txdesc > max_num_txdsc))) {
+		err = -EIO;
+		goto failed;
+	} else if ((private->desc_page = NON_CACHED(malloc(PAGE_SIZE))) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	}
+ #else
+	DBG_PRINT("NOT BOOTLOADER\n");
+	if (((private->num_rxdesc < MIN_NUM_RDESC) || (private->num_rxdesc > max_num_rxdsc)) ||
+	    ((private->num_txdesc < MIN_NUM_TDESC) || (private->num_txdesc > max_num_txdsc))) {
+		err = -EIO;
+		goto failed;
+	} else if ((private->desc_page = __get_free_page(GFP_KERNEL | GFP_DMA)) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	} else if ((private->rx_skb_list = (struct skb_buff **)kmalloc(sizeof(struct skb_buff *) 
+				                 * private->num_rxdesc, GFP_KERNEL)) == NULL) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	memset((void *)private->rx_skb_list, 0, sizeof(struct skb_buff *) * private->num_rxdesc);
+ #endif
+
+	/* Split a page for both rx/tx descriptor */
+	private->eth_rxdsc = (struct em86xx_desc *)private->desc_page;
+	private->eth_txdsc = (struct em86xx_desc *)(private->desc_page + ((1 << PAGE_SHIFT) / 2));
+
+	/* Calculate the size needed for tx/rx -- aligned by pages */
+	rxbuf_size = private->num_rxdesc * R_BUF_SIZE;
+	txbuf_size = private->num_txdesc * T_BUF_SIZE;
+	if ((rxbuf_size & (PAGE_SIZE - 1)) != 0)
+		rxbuf_size = (rxbuf_size & PAGE_MASK) + PAGE_SIZE;
+	if ((txbuf_size & (PAGE_SIZE - 1)) != 0)
+		txbuf_size = (txbuf_size & PAGE_MASK) + PAGE_SIZE;
+	DBG_PRINT("txbuf_size = 0x%08lx, rxbuf_size = 0x%08lx\n", txbuf_size, rxbuf_size);
+
+ #ifndef BOOTLOADER
+	/* Calculate the order needed for tx/rx */
+	for (private->rxbuf_order = 0; private->rxbuf_order < MAX_ORDER; private->rxbuf_order++) {
+		if ((PAGE_SIZE * (1 << private->rxbuf_order)) >= rxbuf_size)
+			break;
+	}
+
+	for (private->txbuf_order = 0; private->txbuf_order < MAX_ORDER; private->txbuf_order++) {
+		if ((PAGE_SIZE * (1 << private->txbuf_order)) >= txbuf_size)
+			break;
+	}
+
+	if ((private->rxbuf_order >= MAX_ORDER) || (private->txbuf_order >= MAX_ORDER)) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	DBG_PRINT("private->txbuf_order = 0x%08lx, private->rxbuf_order = 0x%08lx\n", private->txbuf_order, private->rxbuf_order);
+ #endif
+		
+ #ifdef BOOTLOADER
+	if ((private->rxbuf_pages = NON_CACHED(malloc(rxbuf_size))) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	} else if ((private->txbuf_pages = NON_CACHED(malloc(txbuf_size))) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	}
+ #else
+	if ((private->rxbuf_pages = __get_free_pages(GFP_KERNEL | GFP_DMA, private->rxbuf_order)) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	} else if ((private->txbuf_pages = __get_free_pages(GFP_KERNEL | GFP_DMA, private->txbuf_order)) == 0) {
+		err = -ENOMEM;
+		goto failed;
+	}
+ #endif
+
+	private->eth_rxbuf  = (unsigned char *)private->rxbuf_pages;
+	private->eth_txbuf  = (unsigned char *)private->txbuf_pages;
+#else
+	DBG_PRINT("STATIC_BUF_ALLOC\n");
+#endif
+
+#ifndef BOOTLOADER
+	SET_MODULE_OWNER(&em86xx_eth_dev);
+#endif
+
+	MSG_PRINT("Ethernet driver for EM86XX (v1.0)");
+        dev->irq = IRQ_ETHERNET;
+
+	private->reset_flag 	= 1;
+
+	/* Get a device name: normally it'll be eth0 */
+#ifdef BOOTLOADER
+        memcpy( dev->name, DRIVER, sizeof(DRIVER));
+
+        /* Register ISR */
+        em86xx_request_irq(IRQ_ETHERNET, em86xx_eth_intr_handler, dev);
+#else
+	if ((err = dev_alloc_name(&em86xx_eth_dev, "eth%d")) < 0)
+  		goto failed;
+
+	/* Register ISR */
+	if ((err = request_irq(IRQ_ETHERNET, em86xx_eth_intr_handler, SA_SHIRQ, "ethernet", 
+      	 	 &em86xx_eth_dev)) != 0) {
+  		err = -EIO;
+  		goto failed;
+	} else
+#endif 
+  		MSG_PRINT(" on %s (IRQ: %d)", dev->name, IRQ_ETHERNET);
+
+
+	if (em86xx_get_macaddr(dev->dev_addr)) {
+  		err = -EIO;
+  		goto failed;
+	}
+
+	MSG_PRINT("\n(MAC %02x", dev->dev_addr[0]);
+	for (i = 1; i < 6; i++)
+	  	MSG_PRINT(":%02x", dev->dev_addr[i]);
+	MSG_PRINT(", tx_desc/rx_desc = %ld/%ld), ", private->num_txdesc, private->num_rxdesc);
+	if (phy_address < 0)
+		MSG_PRINT("PHY probing enabled\n");
+	else
+		MSG_PRINT("PHY address: %d\n", phy_address);
+
+	/* Point to driver initialization routine and register the device with kernel */
+	dev->init = em86xx_eth_init;
+#ifdef BOOTLOADER
+        em86xx_eth_init(dev);
+	DBG_PRINT("AFTER em86xx_eth_init\n");
+        dev->state = NETDEV_DOWN;
+	DBG_PRINT("AFTER STATE\n");
+#else
+	if (register_netdev(dev) != 0) {
+  		err = -EIO;
+  		goto failed;
+	}
+#endif
+
+	MSG_PRINT("%s: driver installation completed.\n", dev->name);
+	private->dev_count++;
+	netif_carrier_off(dev); /* By default the carrier is off */
+	DBG_PRINT_INOUT_FUNC("END");
+	return 0;
+
+failed:
+  	if (dev->priv != NULL) {
+#ifdef BOOTLOADER
+                free(dev->priv);
+#else
+    		kfree(dev->priv);
+#endif
+    		dev->priv = NULL;
+  	}
+#ifndef STATIC_BUF_ALLOC
+#ifdef BOOTLOADER
+	if (private->desc_page   != 0)
+		free((void *)CACHED(private->desc_page));
+	if (private->rxbuf_pages != 0)
+		free((void *)CACHED(private->rxbuf_pages));
+	if (private->txbuf_pages != 0)
+		free((void *)CACHED(private->txbuf_pages));
+#else
+	if (private->desc_page   != 0)
+		free_page(private->desc_page);
+	if (private->rxbuf_pages != 0)
+		free_pages(private->rxbuf_pages, private->rxbuf_order);
+	if (private->txbuf_pages != 0)
+		free_pages(private->txbuf_pages, private->txbuf_order);
+	if (private->rx_skb_list != NULL);
+		kfree(private->rx_skb_list);
+#endif
+#endif
+  	MSG_PRINT("%s: driver installation failed.\n", dev->name);
+	DBG_PRINT_INOUT_FUNC("END");
+  	return(err);
+}
+
+#ifndef BOOTLOADER
+/* Uninstallation of drive */
+static void __exit em86xx_eth_shutdown(void)
+{
+	struct net_device *dev 	= &em86xx_eth_dev;
+	EM86XX_ETH_PRIV *private= NULL;
+#if defined(CONFIG_TANGOX)
+        extern int tangox_ethernet_enabled(int);
+        if (tangox_ethernet_enabled(0) == 0) 
+                return;
+#endif
+
+	DBG_PRINT_INOUT_FUNC("START");
+
+	if (dev == NULL)
+  		return;
+	else
+		private = (EM86XX_ETH_PRIV *)dev->priv;
+
+	if (private == NULL) {
+		return;
+	}
+
+	if (private->dev_count != 0) {
+		/* Turn off IRQ and stop receive/transmit */
+  		em86xx_write_reg(EM86XX_CR_REG, 0);
+  		em86xx_write_reg(EM86XX_IER_REG, 0);
+
+  		/* Unregister the device and ISR */
+  		free_irq(IRQ_ETHERNET, &em86xx_eth_dev);
+		unregister_netdev(&em86xx_eth_dev);
+
+		/* Set desc base address registers to 0 */
+		em86xx_write_reg(EM86XX_RLBAR_REG, 0);
+		em86xx_write_reg(EM86XX_TLBAR_REG, 0);
+#ifndef STATIC_BUF_ALLOC
+#ifdef BOOTLOADER
+		if (private->desc_page   != 0)
+			free((void *)CACHED(private->desc_page));
+		if (private->rxbuf_pages != 0)
+			free((void *)CACHED(private->rxbuf_pages));
+		if (private->txbuf_pages != 0)
+			free((void *)CACHED(private->txbuf_pages));
+#else
+		if (private->desc_page   != 0)
+			free_page(private->desc_page);
+		if (private->rxbuf_pages != 0)
+			free_pages(private->rxbuf_pages, private->rxbuf_order);
+		if (private->txbuf_pages != 0)
+			free_pages(private->txbuf_pages, private->txbuf_order);
+		if (private->rx_skb_list != NULL) {
+			int i;
+			for (i = 0; i < private->num_rxdesc; i++) {
+				if (private->rx_skb_list[i] != NULL)
+					dev_kfree_skb(private->rx_skb_list[i]);
+			}
+			kfree(private->rx_skb_list);
+		}
+#endif
+#endif
+		/* Free up memory */
+		if (em86xx_eth_dev.priv != NULL) {
+			kfree(em86xx_eth_dev.priv);
+			em86xx_eth_dev.priv = NULL;
+  		}
+	} 
+
+	DBG_PRINT_INOUT_FUNC("END");
+}
+
+/* Register startup/shutdown routines */
+module_init(em86xx_eth_startup);
+module_exit(em86xx_eth_shutdown);
+#endif
+
diff -Naur linux-2.6.25.8/drivers/net/tango2_enet_old.h linux-2.6.25.8-clean/drivers/net/tango2_enet_old.h
--- linux-2.6.25.8/drivers/net/tango2_enet_old.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/net/tango2_enet_old.h	2008-06-26 15:00:17.000000000 -0400
@@ -0,0 +1,827 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*  
+ * Definitions used to for ethernet module.
+ */
+
+#ifndef __EM86XX_ETH_H__ 
+#define __EM86XX_ETH_H__ 
+
+#ifndef BOOTLOADER
+#include <asm/io.h>
+#include <linux/delay.h>
+#ifdef CONFIG_TANGOX
+#include <asm/addrspace.h>
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#endif
+#define NON_CACHED(x)		KSEG1ADDR((u32)(x))
+#define CACHED(x)		KSEG0ADDR((u32)(x))
+#define PHYSADDR(x)		tangox_dma_address(CPHYSADDR(x))
+#define IRQ_ETHERNET 		(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_ETH_MAC_INT)//38
+#elif defined(CONFIG_ARCH_TANGO15)
+#include <asm/arch/hardware.h>
+#define NON_CACHED(x)		em86xx_to_ncaddr((u32)(x))
+#define CACHED(x)		em86xx_to_caddr((u32)(x))
+#define PHYSADDR(x)		NON_CACHED(x)
+#else
+#error "Not support platform/architecture."
+#endif
+
+#include <asm/types.h>
+
+#else
+
+#include "config.h"
+#include "version.h"
+#include "hardware.h"
+#include "io.h"
+
+typedef unsigned int u32;
+typedef unsigned short int u16;
+typedef unsigned char u8;
+typedef int     bool;
+
+#define NON_CACHED(x)           (((u32)(x)) & 0x7fffffff)
+#define PHYSADDR(x)		NON_CACHED(x)
+
+struct net_device_stats
+{
+        unsigned long   rx_packets;             /* total packets received       */
+        unsigned long   tx_packets;             /* total packets transmitted    */
+        unsigned long   rx_bytes;               /* total bytes received         */
+        unsigned long   tx_bytes;               /* total bytes transmitted      */
+        unsigned long   rx_errors;              /* bad packets received         */
+        unsigned long   tx_errors;              /* packet transmit problems     */
+        unsigned long   rx_dropped;             /* no space in linux buffers    */
+        unsigned long   tx_dropped;             /* no space available in linux  */
+        unsigned long   multicast;              /* multicast packets received   */
+        unsigned long   collisions;
+
+        /* detailed rx_errors: */
+        unsigned long   rx_length_errors;
+        unsigned long   rx_over_errors;         /* receiver ring buff overflow  */
+        unsigned long   rx_crc_errors;          /* recved pkt with crc error    */
+        unsigned long   rx_frame_errors;        /* recv'd frame alignment error */
+        unsigned long   rx_fifo_errors;         /* recv'r fifo overrun          */
+        unsigned long   rx_missed_errors;       /* receiver missed packet       */
+
+        /* detailed tx_errors */
+        unsigned long   tx_aborted_errors;
+        unsigned long   tx_carrier_errors;
+        unsigned long   tx_fifo_errors;
+        unsigned long   tx_heartbeat_errors;
+        unsigned long   tx_window_errors;
+
+        /* for cslip etc */
+        unsigned long   rx_compressed;
+        unsigned long   tx_compressed;
+
+};
+
+static inline int is_valid_ether_addr( u8 *addr )
+{
+        const char zaddr[6] = {0,};
+
+        return !(addr[0]&1) && memcmp( addr, zaddr, 6);
+}
+
+#endif//BOOTLOADER
+
+#define EM86XX_HOST_BASE	REG_BASE_host_interface
+#define EM86XX_HOST_ETHMAC	0x00006000 
+#define EM86XX_HOST_ETHDMA	0x00007000 
+#define EM86XX_ETHDMA_BASE	CPHYSADDR(EM86XX_HOST_BASE + EM86XX_HOST_ETHDMA)
+#define EM86XX_BMR_REG		(EM86XX_ETHDMA_BASE + 0x0)
+#define EM86XX_TPDR_REG		(EM86XX_ETHDMA_BASE + 0x4)
+#define EM86XX_RPDR_REG		(EM86XX_ETHDMA_BASE + 0x8)
+#define EM86XX_RLBAR_REG	(EM86XX_ETHDMA_BASE + 0xc)
+#define EM86XX_TLBAR_REG	(EM86XX_ETHDMA_BASE + 0x10)
+#define EM86XX_SR_REG		(EM86XX_ETHDMA_BASE + 0x14)
+#define EM86XX_CR_REG		(EM86XX_ETHDMA_BASE + 0x18)
+#define EM86XX_IER_REG		(EM86XX_ETHDMA_BASE + 0x1c)
+#define EM86XX_MFCR_REG		(EM86XX_ETHDMA_BASE + 0x20)
+#define EM86XX_IFR_REG		(EM86XX_ETHDMA_BASE + 0x24) /*reserved ?*/
+#define EM86XX_TDVPAR_REG	(EM86XX_ETHDMA_BASE + 0x4c) /*reserved ?*/
+#define EM86XX_CHTBAR_REG	(EM86XX_ETHDMA_BASE + 0x50)
+#define EM86XX_CHRBAR_REG	(EM86XX_ETHDMA_BASE + 0x54)
+
+#define EM86XX_ETHMAC_BASE	CPHYSADDR(EM86XX_HOST_BASE + EM86XX_HOST_ETHMAC)
+#define EM86XX_MACCR_REG	(EM86XX_ETHMAC_BASE + 0x0)
+#define EM86XX_MACAHR_REG	(EM86XX_ETHMAC_BASE + 0x4)
+#define EM86XX_MACALR_REG	(EM86XX_ETHMAC_BASE + 0x8)
+#define EM86XX_MCHTHR_REG	(EM86XX_ETHMAC_BASE + 0xc)
+#define EM86XX_MCHTLR_REG	(EM86XX_ETHMAC_BASE + 0x10)
+#define EM86XX_MIIAR_REG	(EM86XX_ETHMAC_BASE + 0x14)
+#define EM86XX_MIIDR_REG	(EM86XX_ETHMAC_BASE + 0x18)
+#define EM86XX_FCR_REG		(EM86XX_ETHMAC_BASE + 0x1c)
+#define EM86XX_V1TR_REG		(EM86XX_ETHMAC_BASE + 0x20)
+#define EM86XX_V2TR_REG		(EM86XX_ETHMAC_BASE + 0x24)
+#define EM86XX_WUFF_REG	        (EM86XX_ETHMAC_BASE + 0x28)
+#define EM86XX_WUCS_REG		(EM86XX_ETHMAC_BASE + 0x2C)
+
+/* MII interface */
+#define MiiIfSpeed10M     	0x00000000
+#define MiiIfSpeed100M		0x00000004
+#define MiiIfExtPhyMii		0x00000000
+#define MiiIfExtPhyRmii		0x00000001
+#define MiiIfIntPhy    		0x00000002
+
+#ifndef __ASSEMBLY__ 
+
+/* Descriptor related ... */
+struct em86xx_desc {
+  volatile unsigned long desc0;
+  volatile unsigned long desc1;
+  volatile unsigned long desc2;
+  volatile unsigned long desc3;
+};
+
+/**********************************************************
+ * MAC110 Network interface registers
+ **********************************************************/
+
+enum MacControlReg      /* MAC Control register layout */
+{                                         /* Bit description                        R/W   Reset value */
+  MacFilterOff            = 0x80000000,     /* Receive all incoming packets         RW                */
+  MacFilterOn             = 0,              /* Receive filtered packets only                  0       */
+
+  MacBigEndian            = 0x40000000,     /* Big endian mode                      RW                */
+  MacLittleEndian         = 0,              /* Little endian                                  0       */
+
+  MacHeartBeatOff         = 0x10000000,     /* Heart beat signal quality disable    RW                */
+  MacHeartBeatOn          = 0,              /* Heart beat signal quality enable               0       */
+
+  MacSelectSrl            = 0x08000000,     /* Select SRL port                      RW                */
+  MacSelectMii            = 0,              /* Select MII port                                0       */
+
+  MacDisableRxOwn         = 0x00800000,     /* Disable receive own packets          RW                */
+  MacEnableRxOwn          = 0,              /* Enable receive own packets                     0       */
+
+  MacLoopbackExt          = 0x00400000,     /* External loopback                    RW                */
+  MacLoopbackInt          = 0x00200000,     /* Internal loopback                                      */
+  MacLoopbackOff          = 0,              /* Normal mode                                    00      */
+
+  MacFullDuplex           = 0x00100000,     /* Full duplex mode                     RW                */
+  MacHalfDuplex           = 0,              /* Half duplex mode                               0       */
+
+  MacMulticastFilterOff   = 0x00080000,     /* Pass all multicast packets           RW                */
+  MacMulticastFilterOn    = 0,              /* Pass filtered multicast packets                0       */
+
+  MacPromiscuousModeOn    = 0x00040000,     /* Receive all valid packets            RW        1       */
+  MacPromiscuousModeOff   = 0,              /* Receive filtered packets only                          */
+
+  MacFilterInverce        = 0x00020000,     /* Inverse filtering                    RW                */
+  MacFilterNormal         = 0,              /* Normal filtering                               0       */
+
+  MacBadFramesEnable      = 0x00010000,     /* Pass bad frames                      RW                */
+  MacBadFramesDisable     = 0,              /* Do not pass bad frames                         0       */
+
+  MacPerfectFilterOff     = 0x00008000,     /* Hash filtering only                  RW                */
+  MacPerfectFilterOn      = 0,              /* Both perfect and hash filtering                0       */
+
+  MacHashFilterOn         = 0x00002000,     /* perfom hash filtering                RW                */
+  MacHashFilterOff        = 0,              /* perfect filtering only                         0       */
+
+  MacLateCollisionOn      = 0x00001000,     /* Enable late collision control        RW                */
+  MacLateCollisionOff     = 0,              /* Disable late collision control                 0       */
+
+  MacBroadcastDisable     = 0x00000800,     /* Disable reception of broadcast frames RW               */
+  MacBroadcastEnable      = 0,              /* Enable broadcast frames                        0       */
+
+  MacRetryDisable         = 0x00000400,     /* Disable retransmission               RW                */
+  MacRetryEnable          = 0,              /* Enable retransmission                          0       */
+
+  MacPadStripEnable       = 0x00000100,     /* Pad stripping enable                 RW                */
+  MacPadStripDisable      = 0,              /* Pad stripping disable                          0       */
+
+  MacBackoff10            = 0,              /* Backoff Limit (not documented)       RW        00      */
+  MacBackoff8             = 0x00000040,     /* Backoff Limit (not documented)       RW        01      */
+  MacBackoff4             = 0x00000080,     /* Backoff Limit (not documented)       RW        10      */
+  MacBackoff1             = 0x000000c0,     /* Backoff Limit (not documented)       RW        11      */
+
+  MacDeferralCheckEnable  = 0x00000020,     /* Deferral check enable                RW                */
+  MacDeferralCheckDisable = 0,              /* Deferral check disable                         0       */
+
+  MacTxEnable             = 0x00000008,     /* Transmitter enable                   RW                */
+  MacTxDisable            = 0,              /* Transmitter disable                            0       */
+
+  MacRxEnable             = 0x00000004,     /* Receiver enable                      RW                */
+  MacRxDisable            = 0,              /* Receiver disable                               0       */
+};
+
+enum MiiRegisters
+{
+  GEN_ctl   = 0x00,	/* Basic Mode Control Register */
+			/* bit 0-7, 10: Reserved, 
+			   bit 8:  	Duplex Mode: 1=FD, 0=HD
+			   bit 9:	Restart Auto negotiation 1=restart, 0=normal operation
+			   bit11:	1=Power Down, 0=normal operation
+			   bit12:	1=enable auto-negotiation, bit13 and 8 will be ingnored
+					0=disable auto-negotiation, bit13 & 8 to determine the speed and mode
+			   bit13	1=100Mbps 0=10Mbps
+			   bit14	1=enable loopback 0=normal operation
+			   bit15	1=software reset  0=normal operation*/     	
+  GEN_sts   = 0x01,	/* Basic Mode Status Register  */
+			/* bit 0:	1=extended register capability 0=basic register capability only
+			   bit 1:	1=jabber condidtion detected 0=no jabber condition detected
+			   bit 2:	1=valid link established 0=no link
+			   bit 3:	1=Auto-negotiation ok 0=fail
+			   bit 4:	1=remote fault 0=no remote fault
+			   bit 5:	1=auto-negotiation process completed, 0=not completed
+			   bit 6:	MF Preamble suppression
+			   bit 7-10:	Reserved
+			   bit 11:	1=enable 10Base-T HD 0=suppress 10/HD
+			   bit 12:	1=enable 10Base-T FD 0=suppress 10/FD
+			   bit 13:	1=enable 100Base-T FD 0=suppress 100/FD
+			   bit 14:	1=enable 100Base-T FD 0=suppress 100/FD
+			   bit 15:	1=enable 100Base-T4 0=suppress 100-T4*/
+  GEN_id_hi = 0x02,	/* PHY Identifier Register 1   bit 0-15: High PHY identifier default=0000 for RTL8201BL*/
+  GEN_id_lo = 0x03,	/* PHY Identifier Register 2   bit 0-15: Low PHY identifier  default=8201 for RTL8201BL*/
+  AN_adv    = 0x04,	/* Auto-negotiation Advertisement Register */
+			/* bit 0-4:	Selector, only CSMA/CD<0001> is specified
+			   bit 5:	1=10Base-T is supported      0=10Base-T is not supported by local node
+			   bit 6:	1=10Base-T FD is supported   0=10Base-T FD is not supported by local node
+			   bit 7:	1=100Base-TX is supported    0=100Base-TX is not supported by local node
+			   bit 8:	1=100Base-TX FD is supported 0=100Base-TX FD is not supported by local node
+			   bit 9:	1=100Base-T4 is supported    0=100Base-T4 is not supported by local node
+			   bit10 :	1=iflow control is supported 0=flow control is not supported by local node
+			   bit11-12:	Reserved
+			   bit13:	1=advertise remote fault detectioncapability 0=do not advertise remote fault detection capability
+			   bit14:	1=ack reception of link partner capability data word 0=donot ack reception
+			   bit15:	1=transmitting the protocol specific data page 0=transmitting the primary capability data page*/
+  AN_lpa    = 0x05,	/* Auto-negotiation Link partner Ability Register */
+  AN_exp    = 0x06,	/* Auto-negotiation Expansion Register */
+  AN_np     = 0x07,	/* Auto-negotiation Next Page TX */
+  TST       = 0x19,     /* Test register, for checking link10/100 is established*/
+			/* bit 0:	1=Link 100Base Ok, 0=No 100Base link 
+			   bit 1:	1=Link 10Base Ok,  0=No 10Base link */
+
+};
+
+enum Mii_GEN_ctl
+{
+  RESET		= 0x8000,	/* Reset */
+  SPEED		= 0x2000,	/* 100 Mbit/s */
+  AUTONEG_ENB	= 0x1000,	/* Auto negotiation enabled */
+  POWER_DWN	= 0x800, 	/* Power-down enabled */
+  AUTONEG_REST	= 0x200,	/* Restart auto negotiation */
+  DUPLEX 	= 0x0100,	/* Duplex mode */
+};
+
+enum Mii_GEN_sts
+{
+  AUTOCMPLT 	= 0x0020,   	/* Autonegotiation completed */
+  LINK     	= 0x0004,   	/* Link status */
+};
+
+enum Mii_AN_adv
+{
+  CSMACD	= 0x1,		/* CSMA/CD protocol */
+  BASET10	= 0x20, 	/* 10 BaseT support */
+  BASET10FD	= 0x40, 	/* 10 BaseT full duplex support */
+  BASET100	= 0x80, 	/* 100 BaseT support */
+  BASET100FD	= 0x100, 	/* 100 BaseT full duplux support */
+  FLOWCONTROL	= 0x400, 	/* Flow control support */
+  RF		= 0x2000,	/* Remote fault support */
+};
+
+enum Mii_TST
+{
+  LINK100	= 0x1,		/* Link 100 status */
+  LINK10	= 0x2,		/* Link 10  status */
+};
+
+
+enum MacMiiAddrReg     		/* MII address register layout */
+{
+  MiiDevMask    = 0x0000F800,   /* MII device address */
+  MiiDevShift   = 11,
+
+  MiiRegMask    = 0x000007C0,   /* MII register */
+  MiiRegShift   = 6,
+
+  MiiWrite      = 0x00000002,   /* Write to register */
+  MiiRead       = 0,            /* Read from register */
+  MiiBusy       = 0x00000001,   /* MII interface is busy */
+};
+
+enum MacMiiDataReg     		/* MII address register layout */
+{
+  MiiDataMask   = 0x0000FFFF,   /* MII Data */
+};
+
+enum MacFlowControlReg 		/* MAC flow control register layout */
+{                                         /* Bit description                        R/W   Reset value */
+  MacPauseTimeMask        = 0xFFFF0000,   /* PAUSE TIME field in the control frame  RW      0000      */
+  MacPauseTimeShift       = 15,
+
+  MacControlFrameEnable   = 0x00000004,   /* Enable pass control frames to the host RW                */
+  MacControlFrameDisable  = 0,            /* Do not pass control frames to host               0       */
+
+  MacFlowControlEnable    = 0x00000002,   /* Enable flow control                    RW                */
+  MacFlowControlDisable   = 0,            /* Disable flow control                             0       */
+
+  MacSendPauseFrame       = 0x00000001,   /* send pause frame                       RW        0       */
+};
+
+/**********************************************************
+ * DMA Engine registers
+ **********************************************************/
+
+enum DmaBusModeReg         /* DMA bus mode register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaBigEndianDesc        = 0x00100000,   /* Big endian data buffer descriptors     RW                */
+  DmaLittleEndianDesc     = 0,            /* Little endian data descriptors                   0       */
+
+  DmaBurstLength32        = 0x00002000,   /* Dma burst length = 32                  RW                */
+  DmaBurstLength16        = 0x00001000,   /* Dma burst length = 16                                    */
+  DmaBurstLength8         = 0x00000800,   /* Dma burst length = 8                                     */
+  DmaBurstLength4         = 0x00000400,   /* Dma burst length = 4                                     */
+  DmaBurstLength2         = 0x00000200,   /* Dma burst length = 2                                     */
+  DmaBurstLength1         = 0x00000100,   /* Dma burst length = 1                                     */
+  DmaBurstLength0         = 0x00000000,   /* Dma burst length = 0                             0       */
+
+  DmaBigEndianData        = 0x00000080,   /* Big endian data buffers                RW                */
+  DmaLittleEndianData     = 0,            /* Little endian data buffers                       0       */
+
+  DmaDescriptorSkip16     = 0x00000040,   /* number of dwords to skip               RW                */
+  DmaDescriptorSkip8      = 0x00000020,   /* between two unchained descriptors                        */
+  DmaDescriptorSkip4      = 0x00000010,   /*                                                          */
+  DmaDescriptorSkip2      = 0x00000008,   /*                                                          */
+  DmaDescriptorSkip1      = 0x00000004,   /*                                                          */
+  DmaDescriptorSkip0      = 0,            /*                                                  0       */
+
+  DmaReceivePriorityOff   = 0x00000002,   /* equal rx and tx priorities             RW                */
+  DmaReceivePriorityOn    = 0,            /* Rx has prioryty over Tx                          0       */
+
+  DmaResetOn              = 0x00000001,   /* Reset DMA engine                       RW                */
+  DmaResetOff             = 0,            /*                                                  0       */
+};
+
+enum DmaStatusReg         /* DMA Status register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaRxAbort              = 0x01000000,   /* receiver bus abort                     R         0       */
+  DmaTxAbort              = 0x00800000,   /* transmitter bus abort                  R         0       */
+
+  DmaTxState              = 0x00700000,   /* Transmit process state                 R         000     */
+  DmaTxStopped            = 0x00000000,   /* Stopped                                                  */
+  DmaTxFetching           = 0x00100000,   /* Running - fetching the descriptor                        */
+  DmaTxWaiting            = 0x00200000,   /* Running - waiting for end of transmission                */
+  DmaTxReading            = 0x00300000,   /* Running - reading the data from memory                   */
+  DmaTxSuspended          = 0x00600000,   /* Suspended                                                */
+  DmaTxClosing            = 0x00700000,   /* Running - closing descriptor                             */
+
+  DmaRxState              = 0x000E0000,   /* Receive process state                  R         000     */
+  DmaRxStopped            = 0x00000000,   /* Stopped                                                  */
+  DmaRxFetching           = 0x00020000,   /* Running - fetching the descriptor                        */
+  DmaRxChecking           = 0x00040000,   /* Running - checking for end of packet                     */
+  DmaRxWaiting            = 0x00060000,   /* Running - waiting for packet                             */
+  DmaRxSuspended          = 0x00080000,   /* Suspended                                                */
+  DmaRxClosing            = 0x000A0000,   /* Running - closing descriptor                             */
+  DmaRxFlushing           = 0x000C0000,   /* Running - flushing the current frame                     */
+  DmaRxQueuing            = 0x000E0000,   /* Running - queuing the recieve frame into host memory     */
+
+  DmaIntNormal            = 0x00010000,   /* Normal interrupt summary               RW        0       */
+  DmaIntAbnormal          = 0x00008000,   /* Abnormal interrupt summary             RW        0       */
+
+  DmaIntEarlyRx           = 0x00004000,   /* Early receive interrupt (Normal)       RW        0       */
+  DmaIntBusError          = 0x00002000,   /* Fatal bus error (Abnormal)             RW        0       */
+  DmaIntEarlyTx           = 0x00000400,   /* Early transmit interrupt (Abnormal)    RW        0       */
+  DmaIntRxStopped         = 0x00000100,   /* Receive process stopped (Abnormal)     RW        0       */
+  DmaIntRxNoBuffer        = 0x00000080,   /* Receive buffer unavailable (Abnormal)  RW        0       */
+  DmaIntRxCompleted       = 0x00000040,   /* Completion of frame reception (Normal) RW        0       */
+  DmaIntTxUnderflow       = 0x00000020,   /* Transmit underflow (Abnormal)          RW        0       */
+  DmaIntTxNoBuffer        = 0x00000004,   /* Transmit buffer unavailable (Normal)   RW        0       */
+  DmaIntTxStopped         = 0x00000002,   /* Transmit process stopped (Abnormal)    RW        0       */
+  DmaIntTxCompleted       = 0x00000001,   /* Transmit completed (Normal)            RW        0       */
+};
+
+enum DmaControlReg        /* DMA control register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaStoreAndForward      = 0x00200000,   /* Store and forward                      RW        0       */
+  DmaTxStart              = 0x00002000,   /* Start/Stop transmission                RW        0       */
+  DmaTxSecondFrame        = 0x00000004,   /* Operate on second frame                RW        0       */
+  DmaRxStart              = 0x00000002,   /* Start/Stop reception                   RW        0       */
+};
+
+enum  DmaInterruptReg     /* DMA interrupt enable register */
+{                                         /* Bit description                        R/W   Reset value */
+  DmaIeNormal            = DmaIntNormal     ,   /* Normal interrupt enable                 RW        0       */
+  DmaIeAbnormal          = DmaIntAbnormal   ,   /* Abnormal interrupt enable               RW        0       */
+
+  DmaIeEarlyRx           = DmaIntEarlyRx    ,   /* Early receive interrupt enable          RW        0       */
+  DmaIeBusError          = DmaIntBusError   ,   /* Fatal bus error enable                  RW        0       */
+  DmaIeEarlyTx           = DmaIntEarlyTx    ,   /* Early transmit interrupt enable         RW        0       */
+  DmaIeRxStopped         = DmaIntRxStopped  ,   /* Receive process stopped enable          RW        0       */
+  DmaIeRxNoBuffer        = DmaIntRxNoBuffer ,   /* Receive buffer unavailable enable       RW        0       */
+  DmaIeRxCompleted       = DmaIntRxCompleted,   /* Completion of frame reception enable    RW        0       */
+  DmaIeTxUnderflow       = DmaIntTxUnderflow,   /* Transmit underflow enable               RW        0       */
+  DmaIeTxNoBuffer        = DmaIntTxNoBuffer ,   /* Transmit buffer unavailable enable      RW        0       */
+  DmaIeTxStopped         = DmaIntTxStopped  ,   /* Transmit process stopped enable         RW        0       */
+  DmaIeTxCompleted       = DmaIntTxCompleted,   /* Transmit completed enable               RW        0       */
+};
+
+/**********************************************************
+ * DMA Engine descriptors
+ **********************************************************/
+
+enum DmaDescriptorStatus    /* status word of DMA descriptor */
+{
+  DescOwnByDma          = 0x80000000,   /* Descriptor is owned by DMA engine  */
+  DescOwnByCPU          = 0x0,          /* Descriptor is owned by CPU  */
+
+  DescFilteringFail	= 0x40000000,   /* Filtering fail*/
+
+  DescFrameLengthMask   = 0x3FFF0000,   /* Receive descriptor frame length */
+  DescFrameLengthShift  = 16,
+
+  DescError             = 0x00008000,   /* Error summary bit  - OR of the following bits:    v  */
+
+  DescRxTruncated       = 0x00004000,   /* Rx - no more descriptors for receive frame        E  */
+  DescLengthError	= 0x00001000,   /* Rx - length doesn't match 			     E	*/
+  DescRxDamaged         = 0x00000800,   /* Rx - frame was damaged by a collision             E  */
+  DescRxMulticast       = 0x00000400,   /* Rx - received frame is multicast                     */
+  DescRxFirst           = 0x00000200,   /* Rx - first descriptor of the frame                   */
+  DescRxLast            = 0x00000100,   /* Rx - last descriptor of the frame                    */
+  DescRxLongFrame       = 0x00000080,   /* Rx - frame is longer than 1518 bytes              E  */
+  DescRxCollision       = 0x00000040,   /* Rx - frame was damaged by a collision             E  */
+  DescRxFrameEther      = 0x00000020,   /* Rx - Frame type - Ethernet, otherwise 802.3          */
+  DescRxMiiError        = 0x00000008,   /* Rx - error reported by MII interface              E  */
+  DescRxDribbling       = 0x00000004,   /* Rx - frame contains noninteger multiple of 8 bits    */
+  DescRxCrc             = 0x00000002,   /* Rx - CRC error                                    E  */
+
+  DescTxTimeout         = 0x00004000,   /* Tx - Transmit jabber timeout                      E  */
+  DescTxLostCarrier     = 0x00000800,   /* Tx - carrier lost during tramsmission             E  */
+  DescTxNoCarrier       = 0x00000400,   /* Tx - no carrier signal from the tranceiver        E  */
+  DescTxLateCollision   = 0x00000200,   /* Tx - transmission aborted due to collision        E  */
+  DescTxExcCollisions   = 0x00000100,   /* Tx - transmission aborted after 16 collisions     E  */
+  DescTxHeartbeatFail   = 0x00000080,   /* Tx - heartbeat collision check failure               */
+  DescTxCollMask        = 0x00000078,   /* Tx - Collision count                                 */
+  DescTxCollShift       = 3,
+  DescTxExcDeferral     = 0x00000004,   /* Tx - excessive deferral                           E  */
+  DescTxUnderflow       = 0x00000002,   /* Tx - late data arrival from the memory            E  */
+  DescTxDeferred        = 0x00000001,   /* Tx - frame transmision deferred                      */
+};
+
+enum DmaDescriptorLength    /* length word of DMA descriptor */
+{
+  DescTxIntEnable       = 0x80000000,   /* Tx - interrupt on completion                         */
+  DescTxLast            = 0x40000000,   /* Tx - Last segment of the frame                       */
+  DescTxFirst           = 0x20000000,   /* Tx - First segment of the frame                      */
+  DescTxDisableCrc      = 0x04000000,   /* Tx - Add CRC disabled (first segment only)           */
+
+  DescEndOfRing         = 0x02000000,   /* End of descriptors ring                              */
+  DescChain             = 0x01000000,   /* Second buffer address is chain address               */
+
+  DescSize2Mask         = 0x003FF800,   /* Buffer 2 size                                        */
+  DescSize2Shift        = 11,
+  DescSize1Mask         = 0x000007FF,   /* Buffer 1 size                                        */
+  DescSize1Shift        = 0,
+};
+
+/**********************************************************
+ * Initial register values
+ **********************************************************/
+
+enum InitialRegisters
+{
+  MacControlInitFdx       /* Full-duplex mode with perfect filter on */
+                          = MacFilterOn           | MacLittleEndian         | MacHeartBeatOn      | MacSelectMii
+                          | MacEnableRxOwn        | MacLoopbackOff          | MacFullDuplex       | MacMulticastFilterOn
+                          | MacPromiscuousModeOff | MacFilterNormal         | MacBadFramesDisable | MacPerfectFilterOn
+                          | MacHashFilterOff      | MacLateCollisionOff     | MacBroadcastEnable  | MacRetryEnable
+                          | MacPadStripDisable    | MacDeferralCheckDisable | MacTxEnable         | MacRxEnable,
+
+  MacFlowControlInitFdx   /* Full-duplex mode */
+                          = MacControlFrameDisable | MacFlowControlEnable,
+
+  MacControlInitHdx       /* Half-duplex mode with perfect filter on */
+                          = MacFilterOn           | MacLittleEndian         | MacHeartBeatOn      | MacSelectMii
+                          | MacDisableRxOwn       | MacLoopbackOff          | MacHalfDuplex       | MacMulticastFilterOn 
+                          | MacPromiscuousModeOff | MacFilterNormal         | MacBadFramesDisable | MacPerfectFilterOn
+                          | MacHashFilterOff      | MacLateCollisionOff     | MacBroadcastEnable  | MacRetryEnable
+                          | MacPadStripDisable    | MacDeferralCheckDisable | MacTxEnable         | MacRxEnable,
+
+  MacFlowControlInitHdx   /* Half-duplex mode */
+                          = MacControlFrameDisable | MacFlowControlDisable,
+
+  DmaBusModeInit          /* Little-endian mode */
+                          = DmaLittleEndianDesc   | DmaBurstLength8         | DmaLittleEndianData | DmaDescriptorSkip2
+                          | DmaReceivePriorityOn  | DmaResetOff,
+
+  DmaControlInit100       /* 100 Mb/s mode */
+                          = DmaStoreAndForward,
+
+  DmaControlInit10        /* 10 Mb/s mode */
+                          = DmaStoreAndForward,
+
+                          /* Interrupt groups */
+  DmaIntErrorMask         = DmaIntBusError,           /* Error */
+  DmaIntRxAbnMask         = DmaIntRxNoBuffer,         /* receiver abnormal interrupt */
+  DmaIntRxNormMask        = DmaIntRxCompleted,        /* receiver normal interrupt   */
+  DmaIntRxStoppedMask     = DmaIntRxStopped,          /* receiver stopped */
+  DmaIntTxAbnMask         = DmaIntTxUnderflow,        /* transmitter abnormal interrupt */
+  DmaIntTxNormMask        = DmaIntTxCompleted,        /* transmitter normal interrupt */
+  DmaIntTxStoppedMask     = DmaIntTxStopped,          /* receiver stopped */
+
+  DmaIntEnable            = DmaIeNormal | DmaIeAbnormal
+                          | DmaIntErrorMask
+                          | DmaIntRxAbnMask | DmaIntRxNormMask | DmaIntRxStoppedMask
+                          | DmaIntTxAbnMask | DmaIntTxNormMask | DmaIntTxStoppedMask,
+
+  DmaIntDisable           = 0,
+};
+
+/* some status test functions */
+static inline int em86xx_dma_rx_valid( u32 Status )
+{
+  return ( (Status & DescError) == 0 )      /* no errors, whole frame is in the buffer */
+      && ( (Status & DescRxFirst) != 0 )
+      && ( (Status & DescRxLast) != 0 );
+}
+
+static inline u32 em86xx_dma_rx_length( u32 Status )
+{
+  return (Status & DescFrameLengthMask) >> DescFrameLengthShift;
+}
+
+static inline int em86xx_dma_rx_collisions( u32 Status )
+{
+  if( Status & (DescRxDamaged | DescRxCollision) ) return 1;
+    return 0;
+}
+
+static inline int em86xx_dma_rx_crc( u32 Status )
+{
+  if( Status & DescRxCrc ) return 1;
+    return 0;
+}
+
+static inline int em86xx_dma_tx_valid( u32 Status )   /* Test the status word if the descriptor is valid */
+{
+  return ( (Status & DescError) == 0 );
+}
+
+static inline int em86xx_dma_tx_collisions( u32 Status )
+{
+  return (Status & DescTxCollMask) >> DescTxCollShift;
+}
+
+static inline int em86xx_dma_tx_aborted( u32 Status )
+{
+  if( Status & (DescTxLateCollision | DescTxExcCollisions )) return 1;
+    return 0;
+}
+
+static inline int em86xx_dma_tx_carrier( u32 Status )
+{
+  if( Status & (DescTxLostCarrier | DescTxNoCarrier )) return 1;
+    return 0;
+}
+
+static inline int em86xx_rdesc_owned_by_host(volatile struct em86xx_desc *desc)
+{
+  return((desc->desc0 & 0x80000000) ? 0 : 1);
+}
+
+static inline int em86xx_rdesc_last_desc(volatile struct em86xx_desc *desc)
+{
+  return(desc->desc0 & 0x00000100);
+}
+
+static inline int em86xx_rdesc_first_desc(volatile struct em86xx_desc *desc)
+{
+  return(desc->desc0 & 0x00000200);
+}
+
+static inline unsigned long em86xx_rdesc_frame_len(volatile struct em86xx_desc *desc)
+{
+  return((desc->desc0 & 0x3fff0000) >> 16);
+}
+
+static inline int em86xx_tdesc_owned_by_host(volatile struct em86xx_desc *desc)
+{
+  return((desc->desc0 & 0x80000000) ? 0 : 1);
+}
+
+static u32 __inline__ em86xx_read_reg( u32 Reg )
+{
+#ifdef CONFIG_TANGOX
+       u32 data = gbus_readl(Reg);
+	u32 tmp = 0;
+	extern int is_tango2_es6(void);
+	if (is_tango2_es6()) 
+		tmp = gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt);
+#else
+       u32 data = __raw_readl(Reg);
+#endif
+
+//        printk("read data=0x%08x from addr=0x%08x\n", data, Reg);
+        return data;
+}
+
+static u32 em86xx_read_mac_reg(u32 Reg)
+{
+	return em86xx_read_reg( EM86XX_ETHMAC_BASE + Reg );
+}
+
+static u32 em86xx_read_dma_reg(u32 Reg)
+{
+	return em86xx_read_reg( EM86XX_ETHDMA_BASE + Reg );
+}
+
+static void __inline__ em86xx_write_reg( u32 Reg, u32 Data )
+{
+//       printk("write data=0x%08x to addr=0x%08x\n", Data, Reg);
+#ifdef CONFIG_TANGOX
+        gbus_writel(Reg, Data);
+#else
+        __raw_writel(Data,Reg);
+#endif
+}
+
+static void em86xx_write_mac_reg(u32 Reg, u32 Data)
+{
+	em86xx_write_reg( EM86XX_ETHMAC_BASE + Reg, Data );
+}
+
+static void em86xx_write_dma_reg(u32 Reg, u32 Data)
+{
+	em86xx_write_reg( EM86XX_ETHDMA_BASE + Reg, Data );
+}
+
+
+static void __inline__ em86xx_set_reg( u32 reg, u32 data )
+{
+
+#ifdef CONFIG_TANGOX
+	data |= gbus_readl(reg);
+	gbus_writel(reg, data);
+#else
+	data |= __raw_readl(reg);
+	__raw_writel(data, reg);
+#endif
+}
+
+static void __inline__ em86xx_clear_reg( u32 reg, u32 data )
+{
+#ifdef CONFIG_TANGOX
+	gbus_writel(reg,  (gbus_readl(reg) & (~data)));
+#else
+	__raw_writel(( __raw_readl(reg) & (~data)), reg);
+#endif
+}
+
+
+/* There are two registers, MII address (EM86XX_MIIAR_REG) and 
+   MII data (EM86XX_MIIDR_REG), for accessing PHY registers.
+
+   In order to access  mii register data, one need to program the
+   MII address and wait till MII not busy.
+   
+   MII address register description:
+	bit 31-16	reserved
+	bit 15-11	PHY address
+	bit 10-6	MII Register one want to access 
+	bit 1		0:MII read 1:MII write
+	bit 0		0:MII not busy 1:MII busy
+*/
+static inline u16 em86xx_mii_read(int phy_addr, u8 Reg )
+{
+        u32 addr;
+        u16 data;
+
+#ifdef CONFIG_TANGOX
+	u32 count = 100;
+#endif
+
+        addr = ((phy_addr << MiiDevShift) & MiiDevMask) |
+        	((Reg << MiiRegShift) & MiiRegMask);
+        em86xx_write_reg(EM86XX_MIIAR_REG, addr );
+
+#ifdef CONFIG_TANGOX
+	do{
+		udelay(1);
+		count --;
+		if(count == 0) break;
+	} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#else
+        do{} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#endif
+
+        data = em86xx_read_reg(EM86XX_MIIDR_REG ) & 0xFFFF;
+/* 	printk("em86xx_mii_read: addr %d - reg %d - value: %04x\n", */
+/* 	       phy_addr, Reg, data); */
+        return data;
+}
+
+#ifndef BOOTLOADER
+static void em86xx_mii_write(int phy_addr, u8 Reg, u16 Data )
+{
+        u32 addr;
+
+#ifdef CONFIG_TANGOX
+	u32 count = 100;
+#endif
+
+        em86xx_write_reg( EM86XX_MIIDR_REG, Data );
+        addr = ((phy_addr << MiiDevShift) & MiiDevMask) |
+               ((Reg << MiiRegShift) & MiiRegMask) |
+                 MiiWrite;
+
+        em86xx_write_reg( EM86XX_MIIAR_REG, addr );
+
+#ifdef CONFIG_TANGOX
+	do{
+		udelay(1);
+		count --;
+		if(count == 0) break;
+	} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#else
+        do{} while( (em86xx_read_reg(EM86XX_MIIAR_REG ) & MiiBusy) == MiiBusy );
+#endif
+
+/* 	printk("em86xx_write_read: addr %d - reg %d - data: %04x\n", */
+/* 	       phy_addr, Reg, Data); */
+
+}
+#endif
+#if 0 /* for debug purpose*/
+static void mac_dump(void)
+{
+	int i;
+	u32 data, addr;
+	addr = 0;
+	printk("*********************** MAC Registers *************************\n");
+        for(i = 0; i < 12; i++) {
+		data = em86xx_read_mac_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+}
+static void dma_dump(void)
+{
+	int i;
+	u32 data, addr;
+	addr = 0;
+	printk("*********************** DMA Registers *************************\n");
+        for(i = 0; i < 24; i++) {
+		data = em86xx_read_dma_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+
+}
+static void rx_desc_dump(void)
+{
+	int i;
+	u32 data, addr;
+	addr = em86xx_read_reg(EM86XX_RLBAR_REG);
+	printk("*********************** RX DESC *************************\n");
+        for(i = 0; i < 128; i++) {
+		data = em86xx_read_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+}
+static void tx_desc_dump(void) 
+{
+	int i;
+	u32 data, addr;
+	addr = em86xx_read_reg(EM86XX_TLBAR_REG);
+	printk("*********************** TX DESC *************************\n");
+        for(i = 0; i < 128; i++) {
+		data = em86xx_read_reg(addr);		
+        	if(!(i%4))
+                	printk( "0x%08x  ", addr);
+	        printk( "%08x ", data );
+        	if(!((i+1)%4))
+                	printk("\n");
+       		 addr += 4;
+	}
+}
+#endif /* #if 0*/
+#endif /* !__ASSEMBLY__ */
+#endif /* __EM86XX_ETH_H__ */
+
diff -Naur linux-2.6.25.8/drivers/serial/8250.c linux-2.6.25.8-clean/drivers/serial/8250.c
--- linux-2.6.25.8/drivers/serial/8250.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/serial/8250.c	2008-06-26 14:59:44.000000000 -0400
@@ -41,6 +41,20 @@
 #include <linux/nmi.h>
 #include <linux/mutex.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#endif
+
+#ifdef CONFIG_TANGOX
+extern unsigned long tangox_get_sysclock(void);
+#endif
+
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -363,8 +377,21 @@
 
 	case UPIO_MEM:
 	case UPIO_DWAPB:
+#ifdef CONFIG_TANGOX
+	{
+		unsigned long v;
+
+		/* no EFR on tango2/tango3 */
+		if (offset == (UART_EFR << up->port.regshift))
+			v = 0;
+		else
+			v = gbus_readl((unsigned long)up->port.membase +
+				       offset);
+		return v;
+	}
+#else
 		return readb(up->port.membase + offset);
-
+#endif
 	case UPIO_RM9000:
 	case UPIO_MEM32:
 		return readl(up->port.membase + offset);
@@ -400,8 +427,29 @@
 		break;
 
 	case UPIO_MEM:
+#ifdef CONFIG_TANGOX
+		/*
+		 * we add  a special case for  UART_DL register, since
+		 * register content has a different meaning for us.
+		 */
+		if (offset == (UART_DL << up->port.regshift)) {
+			/* select right clock source */
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+			value = (tangox_get_sysclock() / up->port.uartclk);
+#else
+			value = (TANGOX_BASE_FREQUENCY / up->port.uartclk) + 1;
+#endif
+		}
+
+		/* no EFR on tango2/tango3 */
+		if (offset != (UART_EFR << up->port.regshift))
+			gbus_writel((unsigned long)up->port.membase +
+				    offset, value);
+		break;
+#else
 		writeb(value, up->port.membase + offset);
 		break;
+#endif
 
 	case UPIO_RM9000:
 	case UPIO_MEM32:
@@ -462,19 +510,6 @@
 #define serial_inp(up, offset)		serial_in(up, offset)
 #define serial_outp(up, offset, value)	serial_out(up, offset, value)
 
-/* Uart divisor latch read */
-static inline int _serial_dl_read(struct uart_8250_port *up)
-{
-	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
-}
-
-/* Uart divisor latch write */
-static inline void _serial_dl_write(struct uart_8250_port *up, int value)
-{
-	serial_outp(up, UART_DLL, value & 0xff);
-	serial_outp(up, UART_DLM, value >> 8 & 0xff);
-}
-
 #if defined(CONFIG_SERIAL_8250_AU1X00)
 /* Au1x00 haven't got a standard divisor latch */
 static int serial_dl_read(struct uart_8250_port *up)
@@ -510,7 +545,30 @@
 		_serial_dl_write(up, value);
 	}
 }
+#elif defined(CONFIG_TANGOX)
+static inline int serial_dl_read(struct uart_8250_port *up)
+{
+	return serial_inp(up, UART_DL);
+}
+
+/* Uart divisor latch write */
+static inline void serial_dl_write(struct uart_8250_port *up, int value)
+{
+	serial_outp(up, UART_DL, value);
+}
 #else
+/* Uart divisor latch read */
+static inline int _serial_dl_read(struct uart_8250_port *up)
+{
+	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
+}
+
+/* Uart divisor latch write */
+static inline void _serial_dl_write(struct uart_8250_port *up, int value)
+{
+	serial_outp(up, UART_DLL, value & 0xff);
+	serial_outp(up, UART_DLM, value >> 8 & 0xff);
+}
 #define serial_dl_read(up) _serial_dl_read(up)
 #define serial_dl_write(up, value) _serial_dl_write(up, value)
 #endif
@@ -689,6 +747,16 @@
 	old_lcr = serial_inp(p, UART_LCR);
 	serial_outp(p, UART_LCR, UART_LCR_DLAB);
 
+#ifdef CONFIG_TANGOX
+	old_dll = serial_inp(p, UART_DL) & 0xff;
+	old_dlm = serial_inp(p, UART_DL) >> 8;
+
+	serial_outp(p, UART_DL, 0);
+
+	id = serial_inp(p, UART_DL);
+
+	serial_outp(p, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
 
@@ -699,6 +767,7 @@
 
 	serial_outp(p, UART_DLL, old_dll);
 	serial_outp(p, UART_DLM, old_dlm);
+#endif
 	serial_outp(p, UART_LCR, old_lcr);
 
 	return id;
@@ -991,7 +1060,6 @@
 	unsigned char status1, scratch, scratch2, scratch3;
 	unsigned char save_lcr, save_mcr;
 	unsigned long flags;
-
 	if (!up->port.iobase && !up->port.mapbase && !up->port.membase)
 		return;
 
@@ -2043,7 +2111,6 @@
 	 */
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
 	quot = serial8250_get_divisor(port, baud);
-
 	/*
 	 * Oxford Semi 952 rev B workaround
 	 */
@@ -2397,11 +2464,11 @@
 	struct uart_8250_port *up;
 	static int first = 1;
 	int i;
-
 	if (!first)
 		return;
 	first = 0;
 
+
 	for (i = 0; i < nr_uarts; i++) {
 		struct uart_8250_port *up = &serial8250_ports[i];
 
@@ -2440,7 +2507,6 @@
 serial8250_register_ports(struct uart_driver *drv, struct device *dev)
 {
 	int i;
-
 	serial8250_isa_init_ports();
 
 	for (i = 0; i < nr_uarts; i++) {
diff -Naur linux-2.6.25.8/drivers/serial/8250_early.c linux-2.6.25.8-clean/drivers/serial/8250_early.c
--- linux-2.6.25.8/drivers/serial/8250_early.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/serial/8250_early.c	2008-06-26 14:59:44.000000000 -0400
@@ -106,8 +106,13 @@
 
 	lcr = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	dll = serial_in(port, UART_DL) & 0xff;
+	dlm = serial_in(port, UART_DL) >> 8;
+#else
 	dll = serial_in(port, UART_DLL);
 	dlm = serial_in(port, UART_DLM);
+#endif
 	serial_out(port, UART_LCR, lcr);
 
 	quot = (dlm << 8) | dll;
@@ -128,8 +133,12 @@
 	divisor = port->uartclk / (16 * device->baud);
 	c = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, c | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	serial_out(port, UART_DL, divisor & 0xffff);
+#else
 	serial_out(port, UART_DLL, divisor & 0xff);
 	serial_out(port, UART_DLM, (divisor >> 8) & 0xff);
+#endif
 	serial_out(port, UART_LCR, c & ~UART_LCR_DLAB);
 }
 
diff -Naur linux-2.6.25.8/drivers/serial/serial_core.c linux-2.6.25.8-clean/drivers/serial/serial_core.c
--- linux-2.6.25.8/drivers/serial/serial_core.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/serial/serial_core.c	2008-06-26 14:59:44.000000000 -0400
@@ -385,7 +385,8 @@
 		tty_termios_encode_baud_rate(termios, 9600, 9600);
 	}
 
-	return 0;
+//	return 0;
+	return baud;
 }
 
 EXPORT_SYMBOL(uart_get_baud_rate);
@@ -410,7 +411,8 @@
 	else
 		quot = (port->uartclk + (8 * baud)) / (16 * baud);
 
-	return quot;
+//	return quot;
+	return (quot ? quot : 1);
 }
 
 EXPORT_SYMBOL(uart_get_divisor);
diff -Naur linux-2.6.25.8/drivers/usb/Kconfig linux-2.6.25.8-clean/drivers/usb/Kconfig
--- linux-2.6.25.8/drivers/usb/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/usb/Kconfig	2008-06-26 15:01:02.000000000 -0400
@@ -42,6 +42,7 @@
 	default y if PPC_MPC52xx
 	# MIPS:
 	default y if SOC_AU1X00
+	default y if TANGOX
 	# SH:
 	default y if CPU_SUBTYPE_SH7720
 	default y if CPU_SUBTYPE_SH7721
@@ -54,6 +55,7 @@
 	boolean
 	default y if PPC_83xx
 	default y if SOC_AU1200
+	default y if TANGOX				
 	default y if ARCH_IXP4XX
 	default PCI
 
diff -Naur linux-2.6.25.8/drivers/usb/Makefile linux-2.6.25.8-clean/drivers/usb/Makefile
--- linux-2.6.25.8/drivers/usb/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/usb/Makefile	2008-06-26 15:01:02.000000000 -0400
@@ -16,6 +16,8 @@
 obj-$(CONFIG_USB_SL811_HCD)	+= host/
 obj-$(CONFIG_USB_U132_HCD)	+= host/
 obj-$(CONFIG_USB_R8A66597_HCD)	+= host/
+obj-$(CONFIG_TANGOX_EHCI_HCD)	+= host/
+obj-$(CONFIG_TANGOX_OHCI_HCD)	+= host/
 
 obj-$(CONFIG_USB_ACM)		+= class/
 obj-$(CONFIG_USB_PRINTER)	+= class/
diff -Naur linux-2.6.25.8/drivers/usb/core/Makefile linux-2.6.25.8-clean/drivers/usb/core/Makefile
--- linux-2.6.25.8/drivers/usb/core/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/usb/core/Makefile	2008-06-26 15:01:02.000000000 -0400
@@ -14,6 +14,10 @@
 	usbcore-objs	+= inode.o devices.o
 endif
 
+ifeq ($(CONFIG_TANGOX),y)
+        usbcore-objs    += tangox-usb.o
+endif
+
 obj-$(CONFIG_USB)	+= usbcore.o
 
 ifeq ($(CONFIG_USB_DEBUG),y)
diff -Naur linux-2.6.25.8/drivers/usb/core/tangox-usb.c linux-2.6.25.8-clean/drivers/usb/core/tangox-usb.c
--- linux-2.6.25.8/drivers/usb/core/tangox-usb.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/usb/core/tangox-usb.c	2008-06-26 16:21:21.000000000 -0400
@@ -0,0 +1,98 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+
+#include "tangox-usb.h"
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+void tangox_usb_init(void)
+{
+        int  i;
+        unsigned long temp;
+#ifdef CONFIG_TANGOX_XENV_READ
+	if (!tangox_usb_enabled())
+		return;
+#endif
+	/*check see if it's inited*/
+        temp = gbus_read_uint32(pGBus, TANGOX_USB_CTL_STATUS_REG_BASE + 0x0);
+	if(temp && (1<<19)){
+		printk("TangoX USB was initialized.\n");
+		return;
+	}
+	else
+		printk("TangoX USB initializing...\n");
+
+	/*
+	1. Program the clean divider and clock multiplexer to provide 
+	   a 48 MHz reference to the USB block.
+	   This is done in bootloader.
+	*/
+
+
+#if 0   /* If you want to use external crystal at 24MHZ*/
+	printk("TangoX USB using 24MHz external crystal.\n");
+        gbus_write_uint32(pGBus , REG_BASE_system_block + SYS_hostclk_mux, 0x300);
+        gbus_write_uint32(pGBus , TANGOX_USB_CTL_STATUS_REG_BASE + 0x0, 0x70);
+	wait_ms(5);
+        gbus_write_uint32(pGBus , TANGOX_USB_CTL_STATUS_REG_BASE + 0xc, 0xf9931);
+	wait_ms(30);
+#endif
+
+        /*2. PHY software reset*/
+        DBG("Performing PHY Reseting...\n");
+        temp = gbus_read_uint32(pGBus, TANGOX_USB_CTL_STATUS_REG_BASE + 0x0);
+        gbus_write_uint32(pGBus, TANGOX_USB_CTL_STATUS_REG_BASE + 0x0, temp | 0x01);
+        udelay (30);
+        gbus_write_uint32(pGBus, TANGOX_USB_CTL_STATUS_REG_BASE + 0x0, temp);
+        wait_ms(5);
+
+	/*3. Reset Bit 1 of USB register 0x21700 to enable the USB Host controller.
+	     This is done in bootloader 
+	*/
+
+        /*4. OHCI Software reset*/
+        DBG("Performing USB OHCI Reseting...\n");
+        temp = gbus_read_uint32(pGBus, TANGOX_OHCI_BASE_ADDR + 0x08);
+        gbus_write_uint32(pGBus, TANGOX_OHCI_BASE_ADDR + 0x08,  temp | 0x01);
+        wait_ms(5);
+
+        /*5. OHCI DPLL Software reset, it says the bit is for simulation*/
+        DBG("Performing USB OHCI DPLL Reseting...\n");
+        temp = gbus_read_uint32(pGBus, TANGOX_USB_CTL_STATUS_REG_BASE + 0x0);
+        gbus_write_uint32(pGBus,  TANGOX_USB_CTL_STATUS_REG_BASE + 0x0, temp | (1<<19));
+        wait_ms(5);
+	
+	/*6. EHCI Host Software Reset*/
+        DBG("Performing USB EHCI Reseting...\n");
+        temp = gbus_read_uint32(pGBus, TANGOX_EHCI_BASE_ADDR + 0x10);
+        gbus_write_uint32(pGBus, TANGOX_EHCI_BASE_ADDR + 0x10,  temp | 0x02);
+        wait_ms(5);
+
+        for(i = 0; i < 4; i++){
+                temp = gbus_read_uint32(pGBus, TANGOX_USB_CTL_STATUS_REG_BASE + i*4);
+                DBG("TangoX USB register %d = 0x%x\n", i, temp);
+        }
+
+        return;
+}
+
+EXPORT_SYMBOL(tangox_usb_init);
+
diff -Naur linux-2.6.25.8/drivers/usb/core/tangox-usb.h linux-2.6.25.8-clean/drivers/usb/core/tangox-usb.h
--- linux-2.6.25.8/drivers/usb/core/tangox-usb.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/usb/core/tangox-usb.h	2008-06-26 15:01:02.000000000 -0400
@@ -0,0 +1,78 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __TANGOX_USB_H
+#define __TANGOX_USB_H
+ 
+#include <asm/addrspace.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#endif
+
+#define NON_CACHED(x)                   KSEG1ADDR((u32)(x))
+#define CACHED(x)                       KSEG0ADDR((u32)(x))
+
+
+#define TANGOX_EHCI_BASE_ADDR           /*NON_CACHED*/(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR           /*NON_CACHED*/(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE  /*NON_CACHED*/(REG_BASE_host_interface + 0x1700)
+#define TANGOX_EHCI_IRQ                 IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT
+#define TANGOX_OHCI_IRQ                 IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT
+
+/* tangox ehci */
+#define TANGOX_EHCI_BUS_NAME 		"tangox-ehci-bus"
+#define TANGOX_EHCI_PRODUCT_DESC 	"TangoX Integrated USB 2.0"
+#define hcd_name	 		"tangox-ehci-hcd"
+/* tangox ohci */
+#define ohci_hcd_name	 		"tangox-ohci-hcd"
+#define TANGOX_OHCI_BUS_NAME 		"tangox-ohci-bus"
+
+
+static u32 __inline__ tangox_read_reg( u32 Reg )
+{
+#ifdef CONFIG_TANGOX
+        u32 data = gbus_readl(Reg);
+#else
+        u32 data = __raw_readl(Reg);
+#endif
+
+//        printk("read data=0x%08x from addr=0x%08x\n", data, Reg);
+        return data;
+}
+
+static void __inline__ tangox_write_reg( u32 Reg, u32 Data )
+{
+//       printk("write data=0x%08x to addr=0x%08x\n", Data, Reg);
+#ifdef CONFIG_TANGOX
+        gbus_writel(Reg, Data);
+#else
+        __raw_writel(Data,Reg);
+#endif
+}
+
+static __inline__ void wait_ms(unsigned int ms)
+{
+        if(!in_interrupt()) {
+                current->state = TASK_UNINTERRUPTIBLE;
+                schedule_timeout(1 + ms * HZ / 1000);
+        }
+        else
+                mdelay(ms);
+}
+#ifdef CONFIG_TANGOX_XENV_READ
+extern int tangox_usb_enabled(void);
+#endif
+extern int is_tango2_es89(void);
+extern int is_tango3_chip(void);
+extern void tangox_usb_init (void);
+#endif
diff -Naur linux-2.6.25.8/drivers/usb/host/Kconfig linux-2.6.25.8-clean/drivers/usb/host/Kconfig
--- linux-2.6.25.8/drivers/usb/host/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/usb/host/Kconfig	2008-06-26 16:53:22.000000000 -0400
@@ -31,7 +31,7 @@
 
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD && EXPERIMENTAL
+	depends on (USB_EHCI_HCD || TANGOX_EHCI_HCD) && EXPERIMENTAL
 	---help---
 	  Some EHCI chips have vendor-specific extensions to integrate
 	  transaction translators, so that no OHCI or UHCI companion
@@ -97,7 +97,7 @@
 
 config USB_OHCI_HCD
 	tristate "OHCI HCD support"
-	depends on USB && USB_ARCH_HAS_OHCI
+	depends on USB && (USB_ARCH_HAS_OHCI || PCI)
 	select ISP1301_OMAP if MACH_OMAP_H2 || MACH_OMAP_H3
 	select I2C if ARCH_PNX4008
 	---help---
diff -Naur linux-2.6.25.8/drivers/usb/host/ehci-hcd.c linux-2.6.25.8-clean/drivers/usb/host/ehci-hcd.c
--- linux-2.6.25.8/drivers/usb/host/ehci-hcd.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/usb/host/ehci-hcd.c	2008-06-26 20:02:44.000000000 -0400
@@ -1043,6 +1043,12 @@
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
+#ifdef CONFIG_TANGOX
+#include "ehci-tangox.c"
+#define	PLATFORM_DRIVER		ehci_hcd_tangox_driver
+#endif
+
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
diff -Naur linux-2.6.25.8/drivers/usb/host/ehci-hub.c linux-2.6.25.8-clean/drivers/usb/host/ehci-hub.c
--- linux-2.6.25.8/drivers/usb/host/ehci-hub.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/usb/host/ehci-hub.c	2008-06-26 15:01:02.000000000 -0400
@@ -111,8 +111,36 @@
 
 #endif
 
-#ifdef	CONFIG_PM
 
+#ifdef CONFIG_TANGOX
+
+#define COMPANION_PORT     2  /* For B+ or ES7+, set to 0 instead */
+
+extern int is_tango2_es89(void);
+extern int is_tango3_chip(void);
+
+static int is_tangox_ehci(struct usb_hcd *hcd)
+{
+	if (!strcmp(hcd->product_desc,"TangoX USB 2.0"))
+		return 1;
+	else
+		return 0;
+}
+
+/* 0: no companion port to be set to
+   1: companion port#0
+   2: companion port#1
+*/
+static int set_to_companion_port(struct usb_hcd *hcd)
+{
+	if (!is_tangox_ehci(hcd) || is_tango2_es89() || is_tango3_chip()) 
+		return 0;
+	else 
+		return COMPANION_PORT;
+}
+#endif /* CONFIG_TANGOX */
+
+#if 1//def	CONFIG_PM
 static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
diff -Naur linux-2.6.25.8/drivers/usb/host/ehci-tangox.c linux-2.6.25.8-clean/drivers/usb/host/ehci-tangox.c
--- linux-2.6.25.8/drivers/usb/host/ehci-tangox.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/usb/host/ehci-tangox.c	2008-06-27 10:58:40.000000000 -0400
@@ -0,0 +1,207 @@
+/*
+ * Modified for SMP86XX.
+ *
+ * Copyright (c) 2004-2007 Sigma Designs, Inc.
+ *
+ * EHCI HCD (Host Controller Driver) PCI Bus Glue.
+ *
+ * Copyright (c) 2000-2004 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/platform_device.h>
+#ifndef CONFIG_TANGOX
+#error "This file is TANGOX EHCI bus glue.  CONFIG_TANGOX must be defined."
+#endif
+#include "../core/tangox-usb.h"
+
+/* called during probe() after chip reset completes */
+static int ehci_tangox_setup(struct usb_hcd *hcd)
+{
+        struct ehci_hcd         *ehci = hcd_to_ehci(hcd);
+        u32                     temp;
+        int                     retval;
+
+        ehci->caps = hcd->regs;
+        ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+        dbg_hcs_params(ehci, "reset");
+        dbg_hcc_params(ehci, "reset");
+
+        /* cache this readonly data; minimize chip reads */
+        ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+        retval = ehci_halt(ehci);
+        if (retval)
+                return retval;
+
+        /* data structure init */
+        retval = ehci_init(hcd);
+        if (retval)
+                return retval;
+
+        if (ehci_is_TDI(ehci))
+                ehci_reset(ehci);
+
+        /* at least the Genesys GL880S needs fixup here */
+        temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
+        temp &= 0x0f;
+        if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
+                ehci_dbg(ehci, "bogus port configuration: "
+                        "cc=%d x pcc=%d < ports=%d\n",
+                        HCS_N_CC(ehci->hcs_params),
+                        HCS_N_PCC(ehci->hcs_params),
+                        HCS_N_PORTS(ehci->hcs_params));
+        }
+
+        return retval;
+}
+
+
+static const struct hc_driver ehci_tangox_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"SMP863x/SMP865x EHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ehci_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		 ehci_tangox_setup,
+	.start =		ehci_run,
+	.stop =			ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ehci_urb_enqueue,
+	.urb_dequeue =		ehci_urb_dequeue,
+	.endpoint_disable =	ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ehci_hub_status_data,
+	.hub_control =		ehci_hub_control,
+	.bus_suspend =		ehci_bus_suspend,
+	.bus_resume =		ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+};
+
+/*-------------------------------------------------------------------------*/
+
+int usb_ehci_tangox_probe(const struct hc_driver *driver,
+			  struct usb_hcd **hcd_out, struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+
+    tangox_usb_init();
+
+	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+		pr_debug("resource[1] is not IORESOURCE_IRQ");
+		retval = -ENOMEM;
+	}
+	hcd = usb_create_hcd(driver, &dev->dev, "tangox");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	/* ehci_hcd_init(hcd_to_ehci(hcd)); */
+
+	retval =
+	    usb_add_hcd(hcd, dev->resource[1].start, IRQF_SHARED);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+static int ehci_hcd_tangox_drv_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_ehci_tangox_probe(&ehci_tangox_hc_driver, &hcd, pdev);
+	return ret;
+}
+
+void usb_ehci_tangox_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+static int ehci_hcd_tangox_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_ehci_tangox_remove(hcd, pdev);
+	return 0;
+}
+
+MODULE_ALIAS("tangox-ehci");
+
+static struct platform_driver ehci_hcd_tangox_driver = {
+	.probe = ehci_hcd_tangox_drv_probe,
+	.remove = ehci_hcd_tangox_drv_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "tangox-ehci",
+		.bus = &platform_bus_type
+	}
+};
diff -Naur linux-2.6.25.8/drivers/usb/host/ohci-hcd.c linux-2.6.25.8-clean/drivers/usb/host/ohci-hcd.c
--- linux-2.6.25.8/drivers/usb/host/ohci-hcd.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/drivers/usb/host/ohci-hcd.c	2008-06-27 11:00:36.000000000 -0400
@@ -1057,6 +1057,11 @@
 #define PLATFORM_DRIVER		ohci_hcd_sm501_driver
 #endif
 
+#ifdef CONFIG_TANGOX
+#include "ohci-tangox.c"
+#define PLATFORM_DRIVER		ohci_hcd_tangox_driver
+#endif
+
 #if	!defined(PCI_DRIVER) &&		\
 	!defined(PLATFORM_DRIVER) &&	\
 	!defined(OF_PLATFORM_DRIVER) &&	\
diff -Naur linux-2.6.25.8/drivers/usb/host/ohci-tangox.c linux-2.6.25.8-clean/drivers/usb/host/ohci-tangox.c
--- linux-2.6.25.8/drivers/usb/host/ohci-tangox.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/drivers/usb/host/ohci-tangox.c	2008-06-27 11:05:29.000000000 -0400
@@ -0,0 +1,205 @@
+/*
+ * OHCI HCD (Host Controller Driver) for TangoX USB 1.1.
+ *
+ * (C) Copyright 2007 Sigma Designs, Inc.
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ * (C) Copyright 2003-2005 MontaVista Software Inc.
+ * 
+ * Bus Glue for TANGOX OHCI driver. Sigma Designs, Inc.
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+#ifndef CONFIG_TANGOX
+#error "This file is TANGOX OHCI bus glue.  CONFIG_TANGOX must be defined."
+#endif
+
+#include "../core/tangox-usb.h"
+
+/*-------------------------------------------------------------------------*/
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_ohci_tangox_probe - initialize tangox-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+static int usb_ohci_tangox_probe(const struct hc_driver *driver,
+			  struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+
+	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+		pr_debug("resource[1] is not IORESOURCE_IRQ\n");
+		return -ENOMEM;
+	}
+
+	hcd = usb_create_hcd(driver, &dev->dev, "tangox");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed\n");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+    tangox_usb_init();
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+ err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+ err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_tangox_remove - shutdown processing for tangox-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_tangox_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+static void usb_ohci_tangox_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+ohci_tangox_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
+
+	ohci_dbg (ohci, "ohci_tangox_start, ohci:%p", ohci);
+
+	if ((ret = ohci_init (ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run (ohci)) < 0) {
+		err ("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_tangox_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"tangox OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_tangox_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+	.hub_irq_enable =	ohci_rhsc_enable,
+#ifdef	CONFIG_PM
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_tangox_drv_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	pr_debug ("In ohci_hcd_tangox_drv_probe");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_ohci_tangox_probe(&ohci_tangox_hc_driver, pdev);
+	return ret;
+}
+
+static int ohci_hcd_tangox_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_ohci_tangox_remove(hcd, pdev);
+	return 0;
+}
+
+static struct platform_driver ohci_hcd_tangox_driver = {
+	.probe		= ohci_hcd_tangox_drv_probe,
+	.remove		= ohci_hcd_tangox_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	/*.suspend	= ohci_hcd_tangox_drv_suspend, */
+	/*.resume	= ohci_hcd_tangox_drv_resume, */
+	.driver		= {
+		.name	= "tangox-ohci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:tangox-ohci");
diff -Naur linux-2.6.25.8/fs/Kconfig linux-2.6.25.8-clean/fs/Kconfig
--- linux-2.6.25.8/fs/Kconfig	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/Kconfig	2008-07-10 14:48:20.000000000 -0400
@@ -1367,6 +1367,56 @@
 
 	  If unsure, say N.
 
+config SQUASHFS
+	tristate "SquashFS 3.3 - Squashed file system support"
+	select ZLIB_INFLATE
+	help
+	  Saying Y here includes support for SquashFS 3.3 (a Compressed
+	  Read-Only File System).  Squashfs is a highly compressed read-only
+	  filesystem for Linux.  It uses zlib compression to compress both
+	  files, inodes and directories.  Inodes in the system are very small
+	  and all blocks are packed to minimise data overhead. Block sizes
+	  greater than 4K are supported up to a maximum of 1 Mbytes (default
+	  block size 128K).  SquashFS 3.3 supports 64 bit filesystems and files
+	  (larger than 4GB), full uid/gid information, hard links and timestamps.  
+
+	  Squashfs is intended for general read-only filesystem use, for
+	  archival use (i.e. in cases where a .tar.gz file may be used), and in
+	  embedded systems where low overhead is needed.  Further information
+	  and filesystem tools are available from http://squashfs.sourceforge.net.
+
+	  If you want to compile this as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called squashfs.  Note that the root file system (the one
+	  containing the directory /) cannot be compiled as a module.
+
+	  If unsure, say N.
+
+config SQUASHFS_EMBEDDED
+
+	bool "Additional option for memory-constrained systems" 
+	depends on SQUASHFS
+	default n
+	help
+	  Saying Y here allows you to specify cache size.
+
+	  If unsure, say N.
+
+config SQUASHFS_FRAGMENT_CACHE_SIZE
+	int "Number of fragments cached" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default "3"
+	help
+	  By default SquashFS caches the last 3 fragments read from
+	  the filesystem.  Increasing this amount may mean SquashFS
+	  has to re-read fragments less often from disk, at the expense
+	  of extra system memory.  Decreasing this amount will mean
+	  SquashFS uses less memory at the expense of extra reads from disk.
+
+	  Note there must be at least one cached fragment.  Anything
+	  much more than three will probably not make much difference.
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	depends on BLOCK
diff -Naur linux-2.6.25.8/fs/Makefile linux-2.6.25.8-clean/fs/Makefile
--- linux-2.6.25.8/fs/Makefile	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/Makefile	2008-07-10 14:48:20.000000000 -0400
@@ -73,6 +73,7 @@
 obj-$(CONFIG_JBD2)		+= jbd2/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
 obj-y				+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
diff -Naur linux-2.6.25.8/fs/cifs/cifsfs.c linux-2.6.25.8-clean/fs/cifs/cifsfs.c
--- linux-2.6.25.8/fs/cifs/cifsfs.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/cifsfs.c	2009-04-13 19:17:00.000000000 -0400
@@ -68,7 +68,7 @@
 /* extern struct task_struct * dnotifyThread; remove sparse warning */
 static struct task_struct *dnotifyThread = NULL;
 static const struct super_operations cifs_super_ops;
-unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
+unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE*4-4096;
 module_param(CIFSMaxBufSize, int, 0);
 MODULE_PARM_DESC(CIFSMaxBufSize, "Network buffer size (not including header). "
 				 "Default: 16384 Range: 8192 to 130048");
diff -Naur linux-2.6.25.8/fs/cifs/cifsglob.h linux-2.6.25.8-clean/fs/cifs/cifsglob.h
--- linux-2.6.25.8/fs/cifs/cifsglob.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/cifsglob.h	2008-12-10 16:11:21.000000000 -0500
@@ -410,6 +410,19 @@
 
 #endif
 
+/* FIXME remove this debug stuff eventually */
+#if 0
+#define dprintk(fmt, args...)	\
+	printk("DBG at %s:%d: "fmt, __FUNCTION__, __LINE__, ##args)
+#else
+#define dprintk(fmt, args...)	do { } while (0)
+#endif
+
+#define CIFS_NEW_READPAGES	/* use new async ->readpages() */
+
+#define CIFS_READPAGES_MAX	32 /* gives us 32*4k = 128k (just as a maximum
+				      for CIFSMaxBufSize) */
+
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {
 	struct list_head qhead;	/* mids waiting on reply from this server */
@@ -429,6 +442,18 @@
 	unsigned largeBuf:1;    /* if valid response, is pointer to large buf */
 	unsigned multiRsp:1;   /* multiple trans2 responses for one request  */
 	unsigned multiEnd:1; /* both received */
+	struct page *pages[CIFS_READPAGES_MAX]; /* pages for ->readpages() */
+	unsigned nr_pages;	/* number of pages in the request */
+	struct list_head midq_entry; /* mids linked into midq_list */
+};
+
+/* ->readpages() private data */
+struct cifs_readpages_data {
+	struct file *file;
+	struct page *pages[CIFS_READPAGES_MAX];
+	unsigned nr_pages;
+	int xid;
+	struct list_head midq_list;
 };
 
 struct oplock_q_entry {
diff -Naur linux-2.6.25.8/fs/cifs/cifsproto.h linux-2.6.25.8-clean/fs/cifs/cifsproto.h
--- linux-2.6.25.8/fs/cifs/cifsproto.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/cifsproto.h	2008-12-10 16:14:09.000000000 -0500
@@ -50,6 +50,8 @@
 			int * /* bytes returned */ , const int long_op);
 extern int SendReceiveNoRsp(const unsigned int xid, struct cifsSesInfo *ses,
 			struct smb_hdr *in_buf, int flags);
+ extern int Send(const unsigned int xid, struct cifsSesInfo *ses, 
+ 	     struct kvec *iov, int n_vec, struct cifs_readpages_data *data);
 extern int SendReceive2(const unsigned int /* xid */ , struct cifsSesInfo *,
 			struct kvec *, int /* nvec to send */,
 			int * /* type of buf returned */ , const int flags);
@@ -81,6 +83,7 @@
 			     const int stage,
 			     const struct nls_table *nls_cp);
 extern __u16 GetNextMid(struct TCP_Server_Info *server);
+extern void DeleteMidQEntry(struct mid_q_entry *);
 extern struct oplock_q_entry *AllocOplockQEntry(struct inode *, u16,
 						 struct cifsTconInfo *);
 extern void DeleteOplockQEntry(struct oplock_q_entry *);
@@ -273,7 +276,7 @@
 extern int CIFSSMBRead(const int xid, struct cifsTconInfo *tcon,
 			const int netfid, unsigned int count,
 			const __u64 lseek, unsigned int *nbytes, char **buf,
-			int *return_buf_type);
+			int *return_buf_type, int async_flag);
 extern int CIFSSMBWrite(const int xid, struct cifsTconInfo *tcon,
 			const int netfid, const unsigned int count,
 			const __u64 lseek, unsigned int *nbytes,
diff -Naur linux-2.6.25.8/fs/cifs/cifssmb.c linux-2.6.25.8-clean/fs/cifs/cifssmb.c
--- linux-2.6.25.8/fs/cifs/cifssmb.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/cifssmb.c	2008-12-30 13:17:55.000000000 -0500
@@ -1382,7 +1382,7 @@
 int
 CIFSSMBRead(const int xid, struct cifsTconInfo *tcon, const int netfid,
 	    const unsigned int count, const __u64 lseek, unsigned int *nbytes,
-	    char **buf, int *pbuf_type)
+	    char **buf, int *pbuf_type, int async_flag)
 {
 	int rc = -EACCES;
 	READ_REQ *pSMB = NULL;
@@ -1392,7 +1392,7 @@
 	int resp_buf_type = 0;
 	struct kvec iov[1];
 
-	cFYI(1, ("Reading %d bytes on fid %d", count, netfid));
+	cFYI(1, ("Reading %d bytes on fid %d at %lld", count, netfid, lseek));
 	if (tcon->ses->capabilities & CAP_LARGE_FILES)
 		wct = 12;
 	else
@@ -1429,6 +1429,21 @@
 
 	iov[0].iov_base = (char *)pSMB;
 	iov[0].iov_len = pSMB->hdr.smb_buf_length + 4;
+
+	if (async_flag) {
+		/* FIXME
+		 * We treat the buf argument as a cifs_readpages data there.
+		 * Yeah, it may seem confusing, but I haven't come up with
+		 * anything better yet.
+		 */
+		struct cifs_readpages_data *data = 
+			(struct cifs_readpages_data *) *buf;
+		rc = Send(xid, tcon->ses, iov, 1, data);
+		cifs_stats_inc(&tcon->num_reads);
+		/* return immediately */
+		return rc;
+	}
+ 
 	rc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,
 			 &resp_buf_type, CIFS_STD_OP | CIFS_LOG_ERROR);
 	cifs_stats_inc(&tcon->num_reads);
diff -Naur linux-2.6.25.8/fs/cifs/connect.c linux-2.6.25.8-clean/fs/cifs/connect.c
--- linux-2.6.25.8/fs/cifs/connect.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/connect.c	2009-05-04 20:49:10.000000000 -0400
@@ -2172,9 +2172,9 @@
 	}
 	if (pSesInfo) {
 		if (pSesInfo->capabilities & CAP_LARGE_FILES) {
-			sb->s_maxbytes = (u64) 1 << 63;
+			sb->s_maxbytes = ((u64) (1ULL << 63)-1);
 		} else
-			sb->s_maxbytes = (u64) 1 << 31;	/* 2 GB */
+			sb->s_maxbytes = ((u64) 1 << 31ULL);
 	}
 
 	/* BB FIXME fix time_gran to be larger for LANMAN sessions */
diff -Naur linux-2.6.25.8/fs/cifs/file.c linux-2.6.25.8-clean/fs/cifs/file.c
--- linux-2.6.25.8/fs/cifs/file.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/file.c	2009-05-04 20:49:40.000000000 -0400
@@ -39,6 +39,9 @@
 #include "cifs_debug.h"
 #include "cifs_fs_sb.h"
 
+// JFT Test
+extern long long em86_stats[20];
+
 static inline struct cifsFileInfo *cifs_init_private(
 	struct cifsFileInfo *private_data, struct inode *inode,
 	struct file *file, __u16 netfid)
@@ -1616,7 +1619,7 @@
 					 open_file->netfid,
 					 current_read_size, *poffset,
 					 &bytes_read, &smb_read_data,
-					 &buf_type);
+					 &buf_type, 0);
 			pSMBr = (struct smb_com_read_rsp *)smb_read_data;
 			if (smb_read_data) {
 				if (copy_to_user(current_offset,
@@ -1701,7 +1704,7 @@
 					 open_file->netfid,
 					 current_read_size, *poffset,
 					 &bytes_read, &current_offset,
-					 &buf_type);
+					 &buf_type, 0);
 		}
 		if (rc || (bytes_read == 0)) {
 			if (total_read) {
@@ -1736,6 +1739,185 @@
 	return rc;
 }
 
+#ifdef CIFS_NEW_READPAGES
+
+static int cifs_send_readpages(struct cifs_readpages_data *data)
+{
+	int rc;
+	int bogus_nbytes; /* FIXME CIFSSMBRead expects non-null nbytes arg */
+	struct cifsTconInfo *pTcon;
+	struct cifs_sb_info *cifs_sb;
+	struct cifsFileInfo *open_file;
+	unsigned int read_size;
+	loff_t offset;
+
+	open_file = (struct cifsFileInfo *)data->file->private_data;
+	cifs_sb = CIFS_SB(data->file->f_path.dentry->d_sb);
+	pTcon = cifs_sb->tcon;
+	read_size = data->nr_pages * PAGE_CACHE_SIZE;
+	offset = ((loff_t)data->pages[0]->index) << PAGE_CACHE_SHIFT;
+
+	rc = CIFSSMBRead(data->xid, pTcon, open_file->netfid, read_size,
+			offset, &bogus_nbytes, (char **)&data, 
+			NULL, 1 /* async flag */);
+	return rc;
+}
+
+/**
+ * is_response_received - check whether one or more responses came in
+ *
+ * The routine inspects the state of each of midQ entries that we wait for.
+ * Returns 1 if there is an entry in the data->midq_list that has changed 
+ * its state from MID_REQUEST_SUBMITTED.
+ * Returns 0, otherwise.
+ */
+static inline int is_response_received(struct cifs_readpages_data *data,
+		struct mid_q_entry **midQ_recv)
+{
+	struct mid_q_entry *midQ = NULL;
+
+	list_for_each_entry_reverse(midQ, &data->midq_list, midq_entry) {
+		dprintk("INFO: MIDQ mid=%d, state=%d\n",
+				midQ->mid, midQ->midState);
+		if (midQ->midState != MID_REQUEST_SUBMITTED) {
+			*midQ_recv = midQ;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int wait_for_multiple_responses(struct cifsSesInfo *ses,
+		struct cifs_readpages_data *data)
+{
+	int timeout = 30 * HZ; /* FIXME: is that value good enough? */
+	int ret;
+	struct mid_q_entry *midQ = NULL;
+	READ_RSP *pSMBr = NULL;
+	int bytes_read;
+	char *dst, *src;
+	int i;
+
+	dprintk("NOTICE: wait_for_multiple_responses: in\n");
+	
+	while (!list_empty(&data->midq_list)) {
+		ret = wait_event_timeout(ses->server->response_q,
+				is_response_received(data, &midQ),
+				timeout);
+		if (ret == 0)
+			goto timeout;
+
+		if (midQ == NULL || midQ->resp_buf == NULL || 
+				midQ->midState != MID_RESPONSE_RECEIVED) {
+			dprintk("WARNING: bad mid state\n");
+			goto out;
+		}
+		dprintk("NOTICE: GOT MIDQ: mid=%d\n",
+				midQ->mid);
+		pSMBr = (READ_RSP *)midQ->resp_buf;
+		bytes_read = (le16_to_cpu(pSMBr->DataLengthHigh) << 16) +
+			le16_to_cpu(pSMBr->DataLength);
+		if (bytes_read > midQ->nr_pages * PAGE_CACHE_SIZE) {
+			dprintk("WARNING: response too big, bytes_read = %d\n",
+					bytes_read);
+			goto out;
+		}
+		i = 0;
+		src = (char *)pSMBr + 4 + le16_to_cpu(pSMBr->DataOffset);
+		while (bytes_read > 0) {
+			struct page *page = midQ->pages[i];
+			dst = kmap_atomic(page, KM_USER0);
+			if (PAGE_CACHE_SIZE > bytes_read) {
+				memcpy(dst, src, bytes_read);
+				/* zero the tail end of this partial page */
+				em86_stats[15]+=PAGE_CACHE_SIZE - bytes_read;
+				memset(dst + bytes_read, 0,
+						PAGE_CACHE_SIZE - bytes_read);
+				bytes_read = 0;
+			} else {
+				memcpy(dst, src, PAGE_CACHE_SIZE);
+				bytes_read -= PAGE_CACHE_SIZE;
+			}
+			kunmap_atomic(dst, KM_USER0);
+			flush_dcache_page(page);
+			SetPageUptodate(page);
+			unlock_page(page);
+			i++;
+			src += PAGE_CACHE_SIZE;
+		}
+out:
+		list_del(&midQ->midq_entry);
+		DeleteMidQEntry(midQ);
+		atomic_dec(&ses->server->inFlight);
+		wake_up(&ses->server->request_q);
+	}
+
+	return 0;
+
+timeout:
+	/* FIXME: How do we handle that ? */
+	dprintk("WARNING: wait_for_multiple_responses: timeout occurred\n");
+	return -EIO;
+}
+
+static int cifs_readpages_filler(void *_data, struct page *page)
+{
+	struct cifs_readpages_data *data = _data;
+	struct cifs_sb_info *cifs_sb;
+	int rc;
+
+	cifs_sb = CIFS_SB(data->file->f_path.dentry->d_sb);
+
+	if (data->nr_pages > 0 &&
+		(data->nr_pages == CIFS_READPAGES_MAX ||
+		 (data->nr_pages + 1) * PAGE_CACHE_SIZE > cifs_sb->rsize ||
+		 data->pages[data->nr_pages - 1]->index + 1 != page->index)) {
+		rc = cifs_send_readpages(data);
+		data->nr_pages = 0;
+		if (rc)
+			return rc;
+	}
+	data->pages[data->nr_pages] = page;
+	data->nr_pages++;
+	return 0;
+}
+
+static int cifs_readpages(struct file *file, struct address_space *mapping,
+	struct list_head *pages, unsigned nr_pages)
+{
+	int rc = -EACCES;
+	int xid;
+	struct cifs_readpages_data data;
+	struct cifsTconInfo *pTcon;
+	struct cifs_sb_info *cifs_sb;
+
+	dprintk("cifs_readpages: file=%p, nr_pages = %d\n", file, nr_pages);
+	xid = GetXid();
+	if (file->private_data == NULL) {
+		rc = -EBADF;
+		goto out;
+	}
+
+	cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);
+	pTcon = cifs_sb->tcon;
+	INIT_LIST_HEAD(&data.midq_list);
+	data.xid = xid;
+	data.file = file;
+	data.nr_pages = 0;
+
+	rc = read_cache_pages(mapping, pages, cifs_readpages_filler, &data);
+	if (!rc && data.nr_pages > 0) {
+		rc = cifs_send_readpages(&data);
+	}
+
+	rc = wait_for_multiple_responses(pTcon->ses, &data);
+
+out:
+	FreeXid(xid);
+	return rc;
+}
+
+#else
 
 static void cifs_copy_cache_pages(struct address_space *mapping,
 	struct list_head *pages, int bytes_read, char *data,
@@ -1765,6 +1947,7 @@
 		if (PAGE_CACHE_SIZE > bytes_read) {
 			memcpy(target, data, bytes_read);
 			/* zero the tail end of this partial page */
+			em86_stats[15]+=PAGE_CACHE_SIZE - bytes_read;
 			memset(target + bytes_read, 0,
 			       PAGE_CACHE_SIZE - bytes_read);
 			bytes_read = 0;
@@ -1859,7 +2042,7 @@
 					 open_file->netfid,
 					 read_size, offset,
 					 &bytes_read, &smb_read_data,
-					 &buf_type);
+					 &buf_type, 0);
 			/* BB more RC checks ? */
 			if (rc == -EAGAIN) {
 				if (smb_read_data) {
@@ -1927,6 +2110,8 @@
 	return rc;
 }
 
+#endif
+
 static int cifs_readpage_worker(struct file *file, struct page *page,
 	loff_t *poffset)
 {
@@ -1948,8 +2133,10 @@
 		current_fs_time(file->f_path.dentry->d_inode->i_sb);
 
 	if (PAGE_CACHE_SIZE > rc)
+	{
+		em86_stats[15]+=PAGE_CACHE_SIZE - rc;
 		memset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);
-
+    }
 	flush_dcache_page(page);
 	SetPageUptodate(page);
 	rc = 0;
diff -Naur linux-2.6.25.8/fs/cifs/inode.c linux-2.6.25.8-clean/fs/cifs/inode.c
--- linux-2.6.25.8/fs/cifs/inode.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/inode.c	2009-05-04 20:52:27.000000000 -0400
@@ -51,7 +51,9 @@
 
 		/* check if server can support readpages */
 		if (cifs_sb->tcon->ses->server->maxBuf <
-				PAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE)
+				PAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE 
+			// Test JFT
+			&& ! (cifs_sb->tcon->ses->capabilities & CAP_LARGE_FILES))
 			inode->i_data.a_ops = &cifs_addr_ops_smallbuf;
 		else
 			inode->i_data.a_ops = &cifs_addr_ops;
@@ -308,7 +310,7 @@
 		rc = CIFSSMBRead(xid, pTcon,
 				 netfid,
 				 24 /* length */, 0 /* offset */,
-				 &bytes_read, &pbuf, &buf_type);
+				 &bytes_read, &pbuf, &buf_type, 0);
 		if ((rc == 0) && (bytes_read >= 8)) {
 			if (memcmp("IntxBLK", pbuf, 8) == 0) {
 				cFYI(1, ("Block device"));
diff -Naur linux-2.6.25.8/fs/cifs/readdir.c linux-2.6.25.8-clean/fs/cifs/readdir.c
--- linux-2.6.25.8/fs/cifs/readdir.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/readdir.c	2009-05-05 13:11:38.000000000 -0400
@@ -266,7 +266,9 @@
 
 		if ((cifs_sb->tcon) && (cifs_sb->tcon->ses) &&
 		   (cifs_sb->tcon->ses->server->maxBuf <
-			PAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE))
+			PAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE)
+			// Test JFT
+			&& ! (cifs_sb->tcon->ses->capabilities & CAP_LARGE_FILES))
 			tmp_inode->i_data.a_ops = &cifs_addr_ops_smallbuf;
 		else
 			tmp_inode->i_data.a_ops = &cifs_addr_ops;
@@ -398,7 +400,9 @@
 
 		if ((cifs_sb->tcon) && (cifs_sb->tcon->ses) &&
 		   (cifs_sb->tcon->ses->server->maxBuf <
-			PAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE))
+			PAGE_CACHE_SIZE + MAX_CIFS_HDR_SIZE)
+			// Test JFT
+			&& ! (cifs_sb->tcon->ses->capabilities & CAP_LARGE_FILES))
 			tmp_inode->i_data.a_ops = &cifs_addr_ops_smallbuf;
 		else
 			tmp_inode->i_data.a_ops = &cifs_addr_ops;
diff -Naur linux-2.6.25.8/fs/cifs/transport.c linux-2.6.25.8-clean/fs/cifs/transport.c
--- linux-2.6.25.8/fs/cifs/transport.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/cifs/transport.c	2008-12-10 16:19:15.000000000 -0500
@@ -75,7 +75,7 @@
 	return temp;
 }
 
-static void
+void
 DeleteMidQEntry(struct mid_q_entry *midEntry)
 {
 #ifdef CONFIG_CIFS_STATS2
@@ -442,6 +442,81 @@
 	return rc;
 }
 
+  int
+Send(const unsigned int xid, struct cifsSesInfo *ses, 
+	     struct kvec *iov, int n_vec, struct cifs_readpages_data *data)
+{
+	int rc = 0;
+	struct mid_q_entry *midQ;
+	struct smb_hdr *in_buf = iov[0].iov_base;
+	int i;
+	
+	if ((ses == NULL) || (ses->server == NULL)) {
+		cifs_small_buf_release(in_buf);
+		cERROR(1,("Null session"));
+		return -EIO;
+	}
+
+	if(ses->server->tcpStatus == CifsExiting) {
+		cifs_small_buf_release(in_buf);
+		return -ENOENT;
+	}
+
+	/* Ensure that we do not send more than 50 overlapping requests 
+	   to the same server. We may make this configurable later or
+	   use ses->maxReq */
+
+	rc = wait_for_free_request(ses, 0);
+	if (rc) {
+		cifs_small_buf_release(in_buf);
+		return rc;
+	}
+
+	/* make sure that we sign in the same order that we send on this socket 
+	   and avoid races inside tcp sendmsg code that could cause corruption
+	   of smb data */
+
+	down(&ses->server->tcpSem); 
+
+	rc = allocate_mid(ses, in_buf, &midQ);
+	if (rc) {
+		up(&ses->server->tcpSem);
+		cifs_small_buf_release(in_buf);
+		/* Update # of requests on wire to server */
+		atomic_dec(&ses->server->inFlight); 
+		wake_up(&ses->server->request_q);
+		return rc;
+	}
+
+	for (i = 0; i < data->nr_pages; i++) {
+		midQ->pages[i] = data->pages[i];
+	}
+	midQ->nr_pages = data->nr_pages;
+	list_add_tail(&midQ->midq_entry, &data->midq_list);
+
+	rc = cifs_sign_smb2(iov, n_vec, ses->server, &midQ->sequence_number);
+
+	midQ->midState = MID_REQUEST_SUBMITTED;
+#ifdef CONFIG_CIFS_STATS2
+	atomic_inc(&ses->server->inSend);
+#endif
+	rc = smb_send2(ses->server->ssocket, iov, n_vec,
+		      (struct sockaddr *) &(ses->server->addr.sockAddr));
+#ifdef CONFIG_CIFS_STATS2
+	atomic_dec(&ses->server->inSend);
+	midQ->when_sent = jiffies;
+#endif
+
+	up(&ses->server->tcpSem);
+	cifs_small_buf_release(in_buf);
+
+	dprintk("NOTICE: MIDQ SENT: mid=%d, nr_pages=%d, inFlight=%d\n",
+			midQ->mid, midQ->nr_pages,
+			atomic_read(&ses->server->inFlight));
+
+	return rc;
+}
+
 int
 SendReceive2(const unsigned int xid, struct cifsSesInfo *ses,
 	     struct kvec *iov, int n_vec, int *pRespBufType /* ret */,
diff -Naur linux-2.6.25.8/fs/proc/proc_misc.c linux-2.6.25.8-clean/fs/proc/proc_misc.c
--- linux-2.6.25.8/fs/proc/proc_misc.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/fs/proc/proc_misc.c	2009-04-06 19:56:07.000000000 -0400
@@ -80,6 +80,48 @@
 	return len;
 }
 
+extern long long em86_netstats[20];
+
+static int em86net_read_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n"
+	                              "%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n", 
+		em86_netstats[0],em86_netstats[1],em86_netstats[2],em86_netstats[3],
+		em86_netstats[4],em86_netstats[5],em86_netstats[6],em86_netstats[7],
+		em86_netstats[8],em86_netstats[9],em86_netstats[10],em86_netstats[11],
+		em86_netstats[12],em86_netstats[13],em86_netstats[14],em86_netstats[15],
+		em86_netstats[16],em86_netstats[17],em86_netstats[18],em86_netstats[19]);
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+extern long long em86_stats[20];
+
+static int em86dma_read_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n"
+	                              "%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n%lld time %lld\n", 
+		em86_stats[0],em86_stats[1],em86_stats[2],em86_stats[3],
+		em86_stats[4],em86_stats[5],em86_stats[6],em86_stats[7],
+		em86_stats[8],em86_stats[9],em86_stats[10],em86_stats[11],
+		em86_stats[12],em86_stats[13],em86_stats[14],em86_stats[15],
+		em86_stats[16],em86_stats[17],em86_stats[18],em86_stats[19]);
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+extern int tangox_get_hdmioutput();
+
+static int em86hdmi_read_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "%d\n",tangox_get_hdmioutput());
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
 static int loadavg_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
 {
@@ -839,6 +881,9 @@
 		{"filesystems",	filesystems_read_proc},
 		{"cmdline",	cmdline_read_proc},
 		{"execdomains",	execdomains_read_proc},
+		{"em86dma", em86dma_read_proc},
+		{"em86hdmi", em86hdmi_read_proc},
+		{"em86net", em86net_read_proc},
 		{NULL,}
 	};
 	for (p = simple_ones; p->name; p++)
diff -Naur linux-2.6.25.8/fs/squashfs/LzmaDecode.c linux-2.6.25.8-clean/fs/squashfs/LzmaDecode.c
--- linux-2.6.25.8/fs/squashfs/LzmaDecode.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/LzmaDecode.c	2008-07-23 15:42:36.000000000 -0400
@@ -0,0 +1,584 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
diff -Naur linux-2.6.25.8/fs/squashfs/LzmaDecode.h linux-2.6.25.8-clean/fs/squashfs/LzmaDecode.h
--- linux-2.6.25.8/fs/squashfs/LzmaDecode.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/LzmaDecode.h	2008-07-23 15:42:39.000000000 -0400
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
diff -Naur linux-2.6.25.8/fs/squashfs/LzmaTypes.h linux-2.6.25.8-clean/fs/squashfs/LzmaTypes.h
--- linux-2.6.25.8/fs/squashfs/LzmaTypes.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/LzmaTypes.h	2008-07-23 15:42:42.000000000 -0400
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_NO_SYSTEM_SIZE_T */
+/* You can use it, if you don't want <stddef.h> */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_NO_SYSTEM_SIZE_T
+typedef UInt32 SizeT;
+#else
+#include <stddef.h>
+typedef size_t SizeT;
+#endif
+#endif
+
+#endif
diff -Naur linux-2.6.25.8/fs/squashfs/Makefile linux-2.6.25.8-clean/fs/squashfs/Makefile
--- linux-2.6.25.8/fs/squashfs/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/Makefile	2008-07-23 15:43:31.000000000 -0400
@@ -0,0 +1,15 @@
+#
+# Makefile for the linux squashfs routines.
+#
+
+# the environment variables are not inherited since 2.6.23
+ifdef SQLZMA_EXTRA_CFLAGS
+EXTRA_CFLAGS += ${SQLZMA_EXTRA_CFLAGS}
+endif
+
+obj-$(CONFIG_SQUASHFS) += squashfs.o
+squashfs-y += inode.o
+squashfs-y += squashfs2_0.o
+squashfs-y += module.o
+squashfs-y += uncomp.o
+
diff -Naur linux-2.6.25.8/fs/squashfs/inode.c linux-2.6.25.8-clean/fs/squashfs/inode.c
--- linux-2.6.25.8/fs/squashfs/inode.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/inode.c	2008-07-23 15:21:06.000000000 -0400
@@ -0,0 +1,2332 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * inode.c
+ */
+
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/vmalloc.h>
+#include <linux/smp_lock.h>
+#include <linux/exportfs.h>
+
+#include "squashfs.h"
+#include "sqlzma.h"
+#include "sqmagic.h"
+
+#undef KeepPreemptive
+#if defined(CONFIG_PREEMPT) && !defined(UnsquashNoPreempt)
+#define KeepPreemptive
+#endif
+
+struct sqlzma {
+#ifdef KeepPreemptive
+	struct mutex mtx;
+#endif
+	unsigned char read_data[SQUASHFS_FILE_MAX_SIZE];
+	struct sqlzma_un un;
+};
+static DEFINE_PER_CPU(struct sqlzma *, sqlzma);
+
+#define dpri(fmt, args...) /* printk("%s:%d: " fmt, __func__, __LINE__, ##args) */
+#define dpri_un(un)	dpri("un{%d, {%d %p}, {%d %p}, {%d %p}}\n", \
+			     (un)->un_lzma, (un)->un_a[0].sz, (un)->un_a[0].buf, \
+			     (un)->un_a[1].sz, (un)->un_a[1].buf, \
+			     (un)->un_a[2].sz, (un)->un_a[2].buf)
+
+static int squashfs_cached_blks;
+
+static struct dentry *squashfs_fh_to_dentry(struct super_block *s,
+		struct fid *fid, int fh_len, int fh_type);
+static struct dentry *squashfs_fh_to_parent(struct super_block *s,
+		struct fid *fid, int fh_len, int fh_type);
+static struct dentry *squashfs_get_parent(struct dentry *child);
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode);
+static int squashfs_statfs(struct dentry *, struct kstatfs *);
+static int squashfs_symlink_readpage(struct file *file, struct page *page);
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize);
+static int squashfs_readpage(struct file *file, struct page *page);
+static int squashfs_readdir(struct file *, void *, filldir_t);
+static struct dentry *squashfs_lookup(struct inode *, struct dentry *,
+				struct nameidata *);
+static int squashfs_remount(struct super_block *s, int *flags, char *data);
+static void squashfs_put_super(struct super_block *);
+static int squashfs_get_sb(struct file_system_type *,int, const char *, void *,
+				struct vfsmount *);
+static struct inode *squashfs_alloc_inode(struct super_block *sb);
+static void squashfs_destroy_inode(struct inode *inode);
+static int init_inodecache(void);
+static void destroy_inodecache(void);
+
+static struct file_system_type squashfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "squashfs",
+	.get_sb = squashfs_get_sb,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV
+};
+
+static const unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static struct super_operations squashfs_super_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+	.remount_fs = squashfs_remount
+};
+
+static struct export_operations squashfs_export_ops = {
+	.fh_to_dentry = squashfs_fh_to_dentry,
+	.fh_to_parent = squashfs_fh_to_parent,
+	.get_parent = squashfs_get_parent
+};
+
+SQSH_EXTERN const struct address_space_operations squashfs_symlink_aops = {
+	.readpage = squashfs_symlink_readpage
+};
+
+SQSH_EXTERN const struct address_space_operations squashfs_aops = {
+	.readpage = squashfs_readpage
+};
+
+static const struct file_operations squashfs_dir_ops = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir
+};
+
+SQSH_EXTERN struct inode_operations squashfs_dir_inode_ops = {
+	.lookup = squashfs_lookup
+};
+
+
+static struct buffer_head *get_block_length(struct super_block *s,
+				int *cur_index, int *offset, int *c_byte)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned short temp;
+	struct buffer_head *bh;
+
+	if (!(bh = sb_bread(s, *cur_index)))
+		goto out;
+
+	if (msblk->devblksize - *offset == 1) {
+		if (msblk->swap)
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+		else
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+		brelse(bh);
+		if (!(bh = sb_bread(s, ++(*cur_index))))
+			goto out;
+		if (msblk->swap)
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				bh->b_data); 
+		else
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				bh->b_data); 
+		*c_byte = temp;
+		*offset = 1;
+	} else {
+		if (msblk->swap) {
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		} else {
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		}
+		*c_byte = temp;
+		*offset += 2;
+	}
+
+	if (SQUASHFS_CHECK_DATA(msblk->sblk.flags)) {
+		if (*offset == msblk->devblksize) {
+			brelse(bh);
+			if (!(bh = sb_bread(s, ++(*cur_index))))
+				goto out;
+			*offset = 0;
+		}
+		if (*((unsigned char *) (bh->b_data + *offset)) !=
+						SQUASHFS_MARKER_BYTE) {
+			ERROR("Metadata block marker corrupt @ %x\n",
+						*cur_index);
+			brelse(bh);
+			goto out;
+		}
+		(*offset)++;
+	}
+	return bh;
+
+out:
+	return NULL;
+}
+
+
+SQSH_EXTERN unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+			long long index, unsigned int length,
+			long long *next_index, int srclength)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	struct buffer_head **bh;
+	unsigned int offset = index & ((1 << msblk->devblksize_log2) - 1);
+	unsigned int cur_index = index >> msblk->devblksize_log2;
+	int bytes, avail_bytes, b = 0, k = 0;
+	unsigned int compressed;
+	unsigned int c_byte = length;
+
+	bh = kmalloc(((sblk->block_size >> msblk->devblksize_log2) + 1) *
+								sizeof(struct buffer_head *), GFP_KERNEL);
+	if (bh == NULL)
+		goto read_failure;
+
+	if (c_byte) {
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);
+		c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d, src size %d\n", index,
+					compressed ? "" : "un", (unsigned int) c_byte, srclength);
+
+		if (c_byte > srclength || index < 0 || (index + c_byte) > sblk->bytes_used)
+			goto read_failure;
+
+		bh[0] = sb_getblk(s, cur_index);
+		if (bh[0] == NULL)
+			goto block_release;
+
+		for (b = 1; bytes < c_byte; b++) {
+			bh[b] = sb_getblk(s, ++cur_index);
+			if (bh[b] == NULL)
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b, bh);
+	} else {
+		if (index < 0 || (index + 2) > sblk->bytes_used)
+			goto read_failure;
+
+		bh[0] = get_block_length(s, &cur_index, &offset, &c_byte);
+		if (bh[0] == NULL)
+			goto read_failure;
+
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED(c_byte);
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte);
+
+		if (c_byte > srclength || (index + c_byte) > sblk->bytes_used)
+			goto read_failure;
+
+		for (b = 1; bytes < c_byte; b++) {
+			bh[b] = sb_getblk(s, ++cur_index);
+			if (bh[b] == NULL)
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b - 1, bh + 1);
+	}
+
+	if (compressed) {
+		int zlib_err = Z_STREAM_END;
+		int start;
+		enum {Src, Dst};
+		struct sized_buf sbuf[2];
+		struct sqlzma *percpu;
+		unsigned char *p;
+
+		/*
+	 	* uncompress block
+	 	*/
+
+		/* mutex_lock(&msblk->read_data_mutex); */
+
+		start = k;
+		for (; k < b; k++) {
+			wait_on_buffer(bh[k]);
+			if (!buffer_uptodate(bh[k]))
+				goto release_mutex;
+		}
+
+		/* it disables preemption */
+		percpu = get_cpu_var(sqlzma);
+#ifdef KeepPreemptive
+		put_cpu_var(sqlzma);
+		mutex_lock(&percpu->mtx);
+#endif
+		p = percpu->read_data;
+		k = start;
+		for (bytes = 0; k < b; k++) {
+			avail_bytes = min(c_byte - bytes, msblk->devblksize - offset);
+
+			if (k == 0) {
+				/*
+				 * keep this block structture to simplify the
+				 * diff.
+				 */
+				if (avail_bytes == 0) {
+					offset = 0;
+					brelse(bh[k]);
+					continue;
+				}
+			}
+
+			memcpy(p, bh[k]->b_data + offset, avail_bytes);
+			p += avail_bytes;
+#if 0
+			BUG_ON(percpu->read_data + sizeof(percpu->read_data)
+			       < p);
+#endif
+
+			bytes += avail_bytes;
+			offset = 0;
+			brelse(bh[k]);
+		}
+
+		sbuf[Src].buf = percpu->read_data;
+		sbuf[Src].sz = bytes;
+		sbuf[Dst].buf = buffer;
+		sbuf[Dst].sz = srclength;
+		dpri_un(&percpu->un);
+		dpri("src %d %p, dst %d %p\n", sbuf[Src].sz, sbuf[Src].buf,
+		     sbuf[Dst].sz, sbuf[Dst].buf);
+		zlib_err = sqlzma_un(&percpu->un, sbuf + Src, sbuf + Dst);
+		bytes = percpu->un.un_reslen;
+
+#ifdef KeepPreemptive
+		mutex_unlock(&percpu->mtx);
+#else
+		put_cpu_var(sqlzma);
+#endif
+		if (unlikely(zlib_err)) {
+			dpri("zlib_err %d\n", zlib_err);
+			goto release_mutex;
+		}
+		/* mutex_unlock(&msblk->read_data_mutex); */
+	} else {
+		int i;
+
+		for(i = 0; i < b; i++) {
+			wait_on_buffer(bh[i]);
+			if (!buffer_uptodate(bh[i]))
+				goto block_release;
+		}
+
+		for (bytes = 0; k < b; k++) {
+			avail_bytes = min(c_byte - bytes, msblk->devblksize - offset);
+
+			memcpy(buffer + bytes, bh[k]->b_data + offset, avail_bytes);
+			bytes += avail_bytes;
+			offset = 0;
+			brelse(bh[k]);
+		}
+	}
+
+	if (next_index)
+		*next_index = index + c_byte + (length ? 0 :
+				(SQUASHFS_CHECK_DATA(msblk->sblk.flags) ? 3 : 2));
+
+	kfree(bh);
+	return bytes;
+
+release_mutex:
+	/* mutex_unlock(&msblk->read_data_mutex); */
+
+block_release:
+	for (; k < b; k++)
+		brelse(bh[k]);
+
+read_failure:
+	ERROR("sb_bread failed reading block 0x%x\n", cur_index);
+	kfree(bh);
+	return 0;
+}
+
+
+SQSH_EXTERN int squashfs_get_cached_block(struct super_block *s, void *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int n, i, bytes, return_length = length;
+	long long next_index;
+
+	TRACE("Entered squashfs_get_cached_block [%llx:%x]\n", block, offset);
+
+	while (1) {
+		for (i = 0; i < squashfs_cached_blks; i++) 
+			if (msblk->block_cache[i].block == block)
+				break; 
+		
+		mutex_lock(&msblk->block_cache_mutex);
+
+		if (i == squashfs_cached_blks) {
+			/* read inode header block */
+			if (msblk->unused_cache_blks == 0) {
+				mutex_unlock(&msblk->block_cache_mutex);
+				wait_event(msblk->waitq, msblk->unused_cache_blks);
+				continue;
+			}
+
+			i = msblk->next_cache;
+			for (n = 0; n < squashfs_cached_blks; n++) {
+				if (msblk->block_cache[i].block != SQUASHFS_USED_BLK)
+					break;
+				i = (i + 1) % squashfs_cached_blks;
+			}
+
+			msblk->next_cache = (i + 1) % squashfs_cached_blks;
+
+			if (msblk->block_cache[i].block == SQUASHFS_INVALID_BLK) {
+				msblk->block_cache[i].data = vmalloc(SQUASHFS_METADATA_SIZE);
+				if (msblk->block_cache[i].data == NULL) {
+					ERROR("Failed to allocate cache block\n");
+					mutex_unlock(&msblk->block_cache_mutex);
+					goto out;
+				}
+			}
+	
+			msblk->block_cache[i].block = SQUASHFS_USED_BLK;
+			msblk->unused_cache_blks --;
+			mutex_unlock(&msblk->block_cache_mutex);
+
+			msblk->block_cache[i].length = squashfs_read_data(s,
+				msblk->block_cache[i].data, block, 0, &next_index,
+				SQUASHFS_METADATA_SIZE);
+
+			if (msblk->block_cache[i].length == 0) {
+				ERROR("Unable to read cache block [%llx:%x]\n", block, offset);
+				mutex_lock(&msblk->block_cache_mutex);
+				msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+				msblk->unused_cache_blks ++;
+				smp_mb();
+				vfree(msblk->block_cache[i].data);
+				wake_up(&msblk->waitq);
+				mutex_unlock(&msblk->block_cache_mutex);
+				goto out;
+			}
+
+			mutex_lock(&msblk->block_cache_mutex);
+			msblk->block_cache[i].block = block;
+			msblk->block_cache[i].next_index = next_index;
+			msblk->unused_cache_blks ++;
+			smp_mb();
+			wake_up(&msblk->waitq);
+			TRACE("Read cache block [%llx:%x]\n", block, offset);
+		}
+
+		if (msblk->block_cache[i].block != block) {
+			mutex_unlock(&msblk->block_cache_mutex);
+			continue;
+		}
+
+		bytes = msblk->block_cache[i].length - offset;
+
+		if (bytes < 1) {
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto out;
+		} else if (bytes >= length) {
+			if (buffer)
+				memcpy(buffer, msblk->block_cache[i].data + offset, length);
+			if (msblk->block_cache[i].length - offset == length) {
+				*next_block = msblk->block_cache[i].next_index;
+				*next_offset = 0;
+			} else {
+				*next_block = block;
+				*next_offset = offset + length;
+			}
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto finish;
+		} else {
+			if (buffer) {
+				memcpy(buffer, msblk->block_cache[i].data + offset, bytes);
+				buffer = (char *) buffer + bytes;
+			}
+			block = msblk->block_cache[i].next_index;
+			mutex_unlock(&msblk->block_cache_mutex);
+			length -= bytes;
+			offset = 0;
+		}
+	}
+
+finish:
+	return return_length;
+out:
+	return 0;
+}
+
+
+static int get_fragment_location(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);
+	struct squashfs_fragment_entry fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, &sfragment_entry, start_block, offset,
+					 sizeof(sfragment_entry), &start_block, &offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, &fragment_entry, start_block, offset,
+					 sizeof(fragment_entry), &start_block, &offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+SQSH_EXTERN void release_cached_fragment(struct squashfs_sb_info *msblk,
+				struct squashfs_fragment_cache *fragment)
+{
+	mutex_lock(&msblk->fragment_mutex);
+	fragment->locked --;
+	if (fragment->locked == 0) {
+		msblk->unused_frag_blks ++;
+		smp_mb();
+		wake_up(&msblk->fragment_wait_queue);
+	}
+	mutex_unlock(&msblk->fragment_mutex);
+}
+
+
+SQSH_EXTERN
+struct squashfs_fragment_cache *get_cached_fragment(struct super_block *s,
+				long long start_block, int length)
+{
+	int i, n;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	while (1) {
+		mutex_lock(&msblk->fragment_mutex);
+
+		for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS &&
+				msblk->fragment[i].block != start_block; i++);
+
+		if (i == SQUASHFS_CACHED_FRAGMENTS) {
+			if (msblk->unused_frag_blks == 0) {
+				mutex_unlock(&msblk->fragment_mutex);
+				wait_event(msblk->fragment_wait_queue, msblk->unused_frag_blks);
+				continue;
+			}
+
+			i = msblk->next_fragment;
+			for (n = 0; n < SQUASHFS_CACHED_FRAGMENTS; n++) {
+				if (msblk->fragment[i].locked == 0)
+					break;
+				i = (i + 1) % SQUASHFS_CACHED_FRAGMENTS;
+			}
+
+			msblk->next_fragment = (msblk->next_fragment + 1) %
+				SQUASHFS_CACHED_FRAGMENTS;
+			
+			if (msblk->fragment[i].data == NULL) {
+				msblk->fragment[i].data = vmalloc(sblk->block_size);
+				if (msblk->fragment[i].data == NULL) {
+					ERROR("Failed to allocate fragment cache block\n");
+					mutex_unlock(&msblk->fragment_mutex);
+					goto out;
+				}
+			}
+
+			msblk->unused_frag_blks --;
+			msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+			msblk->fragment[i].locked = 1;
+			mutex_unlock(&msblk->fragment_mutex);
+
+			msblk->fragment[i].length = squashfs_read_data(s,
+				msblk->fragment[i].data, start_block, length, NULL,
+				sblk->block_size);
+
+			if (msblk->fragment[i].length == 0) {
+				ERROR("Unable to read fragment cache block [%llx]\n", start_block);
+				msblk->fragment[i].locked = 0;
+				msblk->unused_frag_blks ++;
+				smp_mb();
+				wake_up(&msblk->fragment_wait_queue);
+				goto out;
+			}
+
+			mutex_lock(&msblk->fragment_mutex);
+			msblk->fragment[i].block = start_block;
+			TRACE("New fragment %d, start block %lld, locked %d\n",
+				i, msblk->fragment[i].block, msblk->fragment[i].locked);
+			mutex_unlock(&msblk->fragment_mutex);
+			break;
+		}
+
+		if (msblk->fragment[i].locked == 0)
+			msblk->unused_frag_blks --;
+		msblk->fragment[i].locked++;
+		mutex_unlock(&msblk->fragment_mutex);
+		TRACE("Got fragment %d, start block %lld, locked %d\n", i,
+			msblk->fragment[i].block, msblk->fragment[i].locked);
+		break;
+	}
+
+	return &msblk->fragment[i];
+
+out:
+	return NULL;
+}
+
+
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+				struct squashfs_base_inode_header *inodeb)
+{
+	i->i_ino = inodeb->inode_number;
+	i->i_mtime.tv_sec = inodeb->mtime;
+	i->i_atime.tv_sec = inodeb->mtime;
+	i->i_ctime.tv_sec = inodeb->mtime;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_size = 0;
+
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
+
+
+static squashfs_inode_t squashfs_inode_lookup(struct super_block *s, int ino)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start = msblk->inode_lookup_table[SQUASHFS_LOOKUP_BLOCK(ino - 1)];
+	int offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino - 1);
+	squashfs_inode_t inode;
+
+	TRACE("Entered squashfs_inode_lookup, inode_number = %d\n", ino);
+
+	if (msblk->swap) {
+		squashfs_inode_t sinode;
+
+		if (!squashfs_get_cached_block(s, &sinode, start, offset,
+					sizeof(sinode), &start, &offset))
+			goto out;
+		SQUASHFS_SWAP_INODE_T((&inode), &sinode);
+	} else if (!squashfs_get_cached_block(s, &inode, start, offset,
+					sizeof(inode), &start, &offset))
+			goto out;
+
+	TRACE("squashfs_inode_lookup, inode = 0x%llx\n", inode);
+
+	return inode;
+
+out:
+	return SQUASHFS_INVALID_BLK;
+}
+
+
+
+static struct dentry *squashfs_export_iget(struct super_block *s,
+	unsigned int inode_number)
+{
+	squashfs_inode_t inode;
+	struct inode *i;
+	struct dentry *dentry;
+
+	TRACE("Entered squashfs_export_iget\n");
+
+	inode = squashfs_inode_lookup(s, inode_number);
+	if(inode == SQUASHFS_INVALID_BLK) {
+		dentry = ERR_PTR(-ENOENT);
+		goto failure;
+	}
+
+	i = squashfs_iget(s, inode, inode_number);
+	if(i == NULL) {
+		dentry = ERR_PTR(-EACCES);
+		goto failure;
+	}
+
+	dentry = d_alloc_anon(i);
+	if (dentry == NULL) {
+		iput(i);
+		dentry = ERR_PTR(-ENOMEM);
+	}
+
+failure:
+	return dentry;
+}
+
+
+static struct dentry *squashfs_fh_to_dentry(struct super_block *s,
+		struct fid *fid, int fh_len, int fh_type)
+{
+	if((fh_type != FILEID_INO32_GEN && fh_type != FILEID_INO32_GEN_PARENT) ||
+			fh_len < 2)
+		return NULL;
+
+	return squashfs_export_iget(s, fid->i32.ino);
+}
+
+
+static struct dentry *squashfs_fh_to_parent(struct super_block *s,
+		struct fid *fid, int fh_len, int fh_type)
+{
+	if(fh_type != FILEID_INO32_GEN_PARENT || fh_len < 4)
+		return NULL;
+
+	return squashfs_export_iget(s, fid->i32.parent_ino);
+}
+
+
+static struct dentry *squashfs_get_parent(struct dentry *child)
+{
+	struct inode *i = child->d_inode;
+
+	TRACE("Entered squashfs_get_parent\n");
+
+	return squashfs_export_iget(i->i_sb, SQUASHFS_I(i)->u.s2.parent_inode);
+}
+
+
+SQSH_EXTERN struct inode *squashfs_iget(struct super_block *s,
+				squashfs_inode_t inode, unsigned int inode_number)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct inode *i = iget_locked(s, inode_number);
+
+	TRACE("Entered squashfs_iget\n");
+
+	if(i && (i->i_state & I_NEW)) {
+		(msblk->read_inode)(i, inode);
+		unlock_new_inode(i);
+	}
+
+	return i;
+}
+
+
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode)
+{
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long block = SQUASHFS_INODE_BLK(inode) + sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header id, sid;
+	struct squashfs_base_inode_header *inodeb = &id.base, *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_read_inode\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, sinodeb, block, offset,
+					sizeof(*sinodeb), &next_block, &next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER(inodeb, sinodeb, sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, inodeb, block, offset,
+					sizeof(*inodeb), &next_block, &next_offset))
+			goto failed_read;
+
+	squashfs_new_inode(msblk, i, inodeb);
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_reg_inode_header *inodep = &id.reg;
+			struct squashfs_reg_inode_header *sinodep = &sid.reg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG)
+					if(!get_fragment_location(s, inodep->fragment, &frag_blk,
+												&frag_size))
+						goto failed_read;
+				
+			i->i_nlink = 1;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_lreg_inode_header *inodep = &id.lreg;
+			struct squashfs_lreg_inode_header *sinodep = &sid.lreg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LREG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG)
+				if (!get_fragment_location(s, inodep->fragment, &frag_blk,
+												 &frag_size))
+					goto failed_read;
+				
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header *inodep = &id.dir;
+			struct squashfs_dir_inode_header *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset = next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Long directory inode %x:%x, start_block %x, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header *inodep = &id.symlink;
+			struct squashfs_symlink_inode_header *sinodep = &sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header *inodep = &id.dev;
+			struct squashfs_dev_inode_header *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_CHRDEV_TYPE) ?
+					S_IFCHR : S_IFBLK;
+			init_special_inode(i, i->i_mode, old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset, inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			struct squashfs_ipc_inode_header *inodep = &id.ipc;
+			struct squashfs_ipc_inode_header *sinodep = &sid.ipc;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_IPC_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	return 1;
+
+failed_read:
+	ERROR("Unable to read inode [%llx:%x]\n", block, offset);
+
+failed_read1:
+	make_bad_inode(i);
+	return 0;
+}
+
+
+static int read_inode_lookup_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(sblk->inodes);
+
+	TRACE("In read_inode_lookup_table, length %d\n", length);
+
+	/* Allocate inode lookup table */
+	msblk->inode_lookup_table = kmalloc(length, GFP_KERNEL);
+	if (msblk->inode_lookup_table == NULL) {
+		ERROR("Failed to allocate inode lookup table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->inode_lookup_table,
+			sblk->lookup_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read inode lookup table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long block;
+
+		for (i = 0; i < SQUASHFS_LOOKUP_BLOCKS(sblk->inodes); i++) {
+			/* XXX */
+			SQUASHFS_SWAP_LOOKUP_BLOCKS((&block),
+						&msblk->inode_lookup_table[i], 1);
+			msblk->inode_lookup_table[i] = block;
+		}
+	}
+
+	return 1;
+}
+
+
+static int read_fragment_index_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_FRAGMENT_INDEX_BYTES(sblk->fragments);
+
+	if(length == 0)
+		return 1;
+
+	/* Allocate fragment index table */
+	msblk->fragment_index = kmalloc(length, GFP_KERNEL);
+	if (msblk->fragment_index == NULL) {
+		ERROR("Failed to allocate fragment index table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->fragment_index,
+			sblk->fragment_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sblk->fragments); i++) {
+			/* XXX */
+			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment),
+						&msblk->fragment_index[i], 1);
+			msblk->fragment_index[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int readahead_metadata(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int i;
+
+	squashfs_cached_blks = SQUASHFS_CACHED_BLKS;
+
+	/* Init inode_table block pointer array */
+	msblk->block_cache = kmalloc(sizeof(struct squashfs_cache) *
+					squashfs_cached_blks, GFP_KERNEL);
+	if (msblk->block_cache == NULL) {
+		ERROR("Failed to allocate block cache\n");
+		goto failed;
+	}
+
+	for (i = 0; i < squashfs_cached_blks; i++)
+		msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+
+	msblk->next_cache = 0;
+	msblk->unused_cache_blks = squashfs_cached_blks;
+
+	return 1;
+
+failed:
+	return 0;
+}
+
+
+static int supported_squashfs_filesystem(struct squashfs_sb_info *msblk, int silent)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode;
+	msblk->read_blocklist = read_blocklist;
+	msblk->read_fragment_index_table = read_fragment_index_table;
+
+	if (sblk->s_major == 1) {
+		if (!squashfs_1_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 1.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with Squashfs 1.0 support enabled\n");
+			return 0;
+		}
+	} else if (sblk->s_major == 2) {
+		if (!squashfs_2_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 2.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with Squashfs 2.0 support enabled\n");
+			return 0;
+		}
+	} else if(sblk->s_major != SQUASHFS_MAJOR || sblk->s_minor >
+			SQUASHFS_MINOR) {
+		SERROR("Major/Minor mismatch, trying to mount newer %d.%d "
+				"filesystem\n", sblk->s_major, sblk->s_minor);
+		SERROR("Please update your kernel\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static int squashfs_fill_super(struct super_block *s, void *data, int silent)
+{
+	struct squashfs_sb_info *msblk;
+	struct squashfs_super_block *sblk;
+	int i, err;
+	char b[BDEVNAME_SIZE];
+	struct inode *root;
+
+	TRACE("Entered squashfs_fill_superblock\n");
+
+	err = -ENOMEM;
+	s->s_fs_info = kzalloc(sizeof(struct squashfs_sb_info), GFP_KERNEL);
+	if (s->s_fs_info == NULL) {
+		ERROR("Failed to allocate superblock\n");
+		goto failure;
+	}
+	msblk = s->s_fs_info;
+
+	sblk = &msblk->sblk;
+	
+	msblk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
+	msblk->devblksize_log2 = ffz(~msblk->devblksize);
+
+	/* mutex_init(&msblk->read_data_mutex); */
+	mutex_init(&msblk->read_page_mutex);
+	mutex_init(&msblk->block_cache_mutex);
+	mutex_init(&msblk->fragment_mutex);
+	mutex_init(&msblk->meta_index_mutex);
+	
+	init_waitqueue_head(&msblk->waitq);
+	init_waitqueue_head(&msblk->fragment_wait_queue);
+
+	/* sblk->bytes_used is checked in squashfs_read_data to ensure reads are not
+ 	 * beyond filesystem end.  As we're using squashfs_read_data to read sblk here,
+ 	 * first set sblk->bytes_used to a useful value */
+	err = -EINVAL;
+	sblk->bytes_used = sizeof(struct squashfs_super_block);
+	if (!squashfs_read_data(s, (char *) sblk, SQUASHFS_START,
+					sizeof(struct squashfs_super_block) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, sizeof(struct squashfs_super_block))) {
+		SERROR("unable to read superblock\n");
+		goto failed_mount;
+	}
+
+	/* Check it is a SQUASHFS superblock */
+	s->s_magic = sblk->s_magic;
+	msblk->swap = 0;
+	dpri("magic 0x%x\n", sblk->s_magic);
+	switch (sblk->s_magic) {
+		struct squashfs_super_block ssblk;
+
+	case SQUASHFS_MAGIC_SWAP:
+		/*FALLTHROUGH*/
+	case SQUASHFS_MAGIC_LZMA_SWAP:
+		WARNING("Mounting a different endian SQUASHFS "
+			"filesystem on %s\n", bdevname(s->s_bdev, b));
+
+		SQUASHFS_SWAP_SUPER_BLOCK(&ssblk, sblk);
+		memcpy(sblk, &ssblk, sizeof(struct squashfs_super_block));
+		msblk->swap = 1;
+		/*FALLTHROUGH*/
+	case SQUASHFS_MAGIC:
+	case SQUASHFS_MAGIC_LZMA:
+		break;
+	default:
+		SERROR("Can't find a SQUASHFS superblock on %s\n",
+		       bdevname(s->s_bdev, b));
+		goto failed_mount;
+	}
+
+	{
+		struct sqlzma *p;
+		dpri("block_size %d, devblksize %d\n",
+		     sblk->block_size, msblk->devblksize);
+		BUG_ON(sblk->block_size > sizeof(p->read_data));
+	}
+
+	/* Check the MAJOR & MINOR versions */
+	if(!supported_squashfs_filesystem(msblk, silent))
+		goto failed_mount;
+
+	/* Check the filesystem does not extend beyond the end of the
+	   block device */
+	if(sblk->bytes_used < 0 || sblk->bytes_used > i_size_read(s->s_bdev->bd_inode))
+		goto failed_mount;
+
+	/* Check the root inode for sanity */
+	if (SQUASHFS_INODE_OFFSET(sblk->root_inode) > SQUASHFS_METADATA_SIZE)
+		goto failed_mount;
+
+	TRACE("Found valid superblock on %s\n", bdevname(s->s_bdev, b));
+	TRACE("Inodes are %scompressed\n", SQUASHFS_UNCOMPRESSED_INODES(sblk->flags)
+					? "un" : "");
+	TRACE("Data is %scompressed\n", SQUASHFS_UNCOMPRESSED_DATA(sblk->flags)
+					? "un" : "");
+	TRACE("Check data is %spresent in the filesystem\n",
+					SQUASHFS_CHECK_DATA(sblk->flags) ?  "" : "not ");
+	TRACE("Filesystem size %lld bytes\n", sblk->bytes_used);
+	TRACE("Block size %d\n", sblk->block_size);
+	TRACE("Number of inodes %d\n", sblk->inodes);
+	if (sblk->s_major > 1)
+		TRACE("Number of fragments %d\n", sblk->fragments);
+	TRACE("Number of uids %d\n", sblk->no_uids);
+	TRACE("Number of gids %d\n", sblk->no_guids);
+	TRACE("sblk->inode_table_start %llx\n", sblk->inode_table_start);
+	TRACE("sblk->directory_table_start %llx\n", sblk->directory_table_start);
+	if (sblk->s_major > 1)
+		TRACE("sblk->fragment_table_start %llx\n", sblk->fragment_table_start);
+	TRACE("sblk->uid_start %llx\n", sblk->uid_start);
+
+	s->s_maxbytes = MAX_LFS_FILESIZE;
+	s->s_flags |= MS_RDONLY;
+	s->s_op = &squashfs_super_ops;
+
+	if (readahead_metadata(s) == 0)
+		goto failed_mount;
+
+	/* Allocate read_page block */
+	err = -ENOMEM;
+	msblk->read_page = vmalloc(sblk->block_size);
+	if (msblk->read_page == NULL) {
+		ERROR("Failed to allocate read_page block\n");
+		goto failed_mount;
+	}
+
+	/* Allocate uid and gid tables */
+	msblk->uid = kmalloc((sblk->no_uids + sblk->no_guids) *
+					sizeof(unsigned int), GFP_KERNEL);
+	if (msblk->uid == NULL) {
+		ERROR("Failed to allocate uid/gid table\n");
+		goto failed_mount;
+	}
+	msblk->guid = msblk->uid + sblk->no_uids;
+   
+	dpri("swap %d\n", msblk->swap);
+	err = -EINVAL;
+	if (msblk->swap) {
+		unsigned int *suid;
+
+		err = -ENOMEM;
+		suid = kmalloc(sizeof(*suid) * (sblk->no_uids + sblk->no_guids),
+			       GFP_KERNEL);
+		if (unlikely(!suid))
+			goto failed_mount;
+
+		err = -EINVAL;
+		if (!squashfs_read_data(s, (char *) &suid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			kfree(suid);
+			goto failed_mount;
+		}
+
+		SQUASHFS_SWAP_DATA(msblk->uid, suid, (sblk->no_uids +
+			sblk->no_guids), (sizeof(unsigned int) * 8));
+		kfree(suid);
+	} else
+		if (!squashfs_read_data(s, (char *) msblk->uid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
+		}
+
+
+	if (sblk->s_major == 1 && squashfs_1_0_supported(msblk))
+		goto allocate_root;
+
+	err = -ENOMEM;
+	msblk->fragment = kzalloc(sizeof(struct squashfs_fragment_cache) *
+				SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL);
+	if (msblk->fragment == NULL) {
+		ERROR("Failed to allocate fragment block cache\n");
+		goto failed_mount;
+	}
+
+	for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
+		msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+	}
+
+	msblk->next_fragment = 0;
+	msblk->unused_frag_blks = SQUASHFS_CACHED_FRAGMENTS;
+
+	/* Allocate and read fragment index table */
+	if (msblk->read_fragment_index_table(s) == 0)
+		goto failed_mount;
+
+	if(sblk->s_major < 3 || sblk->lookup_table_start == SQUASHFS_INVALID_BLK)
+		goto allocate_root;
+
+	/* Allocate and read inode lookup table */
+	if (read_inode_lookup_table(s) == 0)
+		goto failed_mount;
+
+	s->s_export_op = &squashfs_export_ops;
+
+allocate_root:
+	dpri("alloate_root\n");
+	root = new_inode(s);
+	if ((msblk->read_inode)(root, sblk->root_inode) == 0) {
+		iput(root);
+		goto failed_mount;
+	}
+	insert_inode_hash(root);
+
+	s->s_root = d_alloc_root(root);
+	if (s->s_root == NULL) {
+		ERROR("Root inode create failed\n");
+		iput(root);
+		goto failed_mount;
+	}
+
+	TRACE("Leaving squashfs_fill_super\n");
+	return 0;
+
+failed_mount:
+	kfree(msblk->inode_lookup_table);
+	kfree(msblk->fragment_index);
+	kfree(msblk->fragment);
+	kfree(msblk->uid);
+	vfree(msblk->read_page);
+	kfree(msblk->block_cache);
+	kfree(msblk->fragment_index_2);
+	kfree(s->s_fs_info);
+	s->s_fs_info = NULL;
+ failure:
+	return err;
+}
+
+
+static int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct squashfs_sb_info *msblk = dentry->d_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	TRACE("Entered squashfs_statfs\n");
+
+	buf->f_type = sblk->s_magic;
+	buf->f_bsize = sblk->block_size;
+	buf->f_blocks = ((sblk->bytes_used - 1) >> sblk->block_log) + 1;
+	buf->f_bfree = buf->f_bavail = 0;
+	buf->f_files = sblk->inodes;
+	buf->f_ffree = 0;
+	buf->f_namelen = SQUASHFS_NAME_LEN;
+
+	return 0;
+}
+
+
+static int squashfs_symlink_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	int index = page->index << PAGE_CACHE_SHIFT, length, bytes, avail_bytes;
+	long long block = SQUASHFS_I(inode)->start_block;
+	int offset = SQUASHFS_I(inode)->offset;
+	void *pageaddr = kmap(page);
+
+	TRACE("Entered squashfs_symlink_readpage, page index %ld, start block "
+				"%llx, offset %x\n", page->index,
+				SQUASHFS_I(inode)->start_block,
+				SQUASHFS_I(inode)->offset);
+
+	for (length = 0; length < index; length += bytes) {
+		bytes = squashfs_get_cached_block(inode->i_sb, NULL, block,
+				offset, PAGE_CACHE_SIZE, &block, &offset);
+		if (bytes == 0) {
+			ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
+			goto skip_read;
+		}
+	}
+
+	if (length != index) {
+		ERROR("(squashfs_symlink_readpage) length != index\n");
+		bytes = 0;
+		goto skip_read;
+	}
+
+	avail_bytes = min_t(int, i_size_read(inode) - length, PAGE_CACHE_SIZE);
+
+	bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block, offset,
+		avail_bytes, &block, &offset);
+	if (bytes == 0)
+		ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+struct meta_index *locate_meta_index(struct inode *inode, int index, int offset)
+{
+	struct meta_index *meta = NULL;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int i;
+
+	mutex_lock(&msblk->meta_index_mutex);
+
+	TRACE("locate_meta_index: index %d, offset %d\n", index, offset);
+
+	if (msblk->meta_index == NULL)
+		goto not_allocated;
+
+	for (i = 0; i < SQUASHFS_META_NUMBER; i ++) {
+		if (msblk->meta_index[i].inode_number == inode->i_ino &&
+				msblk->meta_index[i].offset >= offset &&
+				msblk->meta_index[i].offset <= index &&
+				msblk->meta_index[i].locked == 0) {
+			TRACE("locate_meta_index: entry %d, offset %d\n", i,
+					msblk->meta_index[i].offset);
+			meta = &msblk->meta_index[i];
+			offset = meta->offset;
+		}
+	}
+
+	if (meta)
+		meta->locked = 1;
+
+not_allocated:
+	mutex_unlock(&msblk->meta_index_mutex);
+
+	return meta;
+}
+
+
+struct meta_index *empty_meta_index(struct inode *inode, int offset, int skip)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct meta_index *meta = NULL;
+	int i;
+
+	mutex_lock(&msblk->meta_index_mutex);
+
+	TRACE("empty_meta_index: offset %d, skip %d\n", offset, skip);
+
+	if (msblk->meta_index == NULL) {
+		msblk->meta_index = kmalloc(sizeof(struct meta_index) *
+					SQUASHFS_META_NUMBER, GFP_KERNEL);
+		if (msblk->meta_index == NULL) {
+			ERROR("Failed to allocate meta_index\n");
+			goto failed;
+		}
+		for (i = 0; i < SQUASHFS_META_NUMBER; i++) {
+			msblk->meta_index[i].inode_number = 0;
+			msblk->meta_index[i].locked = 0;
+		}
+		msblk->next_meta_index = 0;
+	}
+
+	for (i = SQUASHFS_META_NUMBER; i &&
+			msblk->meta_index[msblk->next_meta_index].locked; i --)
+		msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	if (i == 0) {
+		TRACE("empty_meta_index: failed!\n");
+		goto failed;
+	}
+
+	TRACE("empty_meta_index: returned meta entry %d, %p\n",
+			msblk->next_meta_index,
+			&msblk->meta_index[msblk->next_meta_index]);
+
+	meta = &msblk->meta_index[msblk->next_meta_index];
+	msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	meta->inode_number = inode->i_ino;
+	meta->offset = offset;
+	meta->skip = skip;
+	meta->entries = 0;
+	meta->locked = 1;
+
+failed:
+	mutex_unlock(&msblk->meta_index_mutex);
+	return meta;
+}
+
+
+void release_meta_index(struct inode *inode, struct meta_index *meta)
+{
+	meta->locked = 0;
+	smp_mb();
+}
+
+
+static int read_block_index(struct super_block *s, int blocks, char *block_list,
+				long long *start_block, int *offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned int *block_listp;
+	int block = 0;
+	
+	if (msblk->swap) {
+		char *sblock_list;
+
+		sblock_list = kmalloc(blocks << 2, GFP_KERNEL);
+		if (unlikely(!sblock_list))
+			goto failure;
+
+		if (!squashfs_get_cached_block(s, sblock_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Fail reading block list [%llx:%x]\n", *start_block, *offset);
+			kfree(sblock_list);
+			goto failure;
+		}
+		SQUASHFS_SWAP_INTS(((unsigned int *)block_list),
+				((unsigned int *)sblock_list), blocks);
+		kfree(sblock_list);
+	} else {
+		if (!squashfs_get_cached_block(s, block_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Fail reading block list [%llx:%x]\n", *start_block, *offset);
+			goto failure;
+		}
+	}
+
+	for (block_listp = (unsigned int *) block_list; blocks;
+				block_listp++, blocks --)
+		block += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);
+
+	return block;
+
+failure:
+	return -1;
+}
+
+
+#define SIZE 256
+
+static inline int calculate_skip(int blocks) {
+	int skip = (blocks - 1) / ((SQUASHFS_SLOTS * SQUASHFS_META_ENTRIES + 1) * SQUASHFS_META_INDEXES);
+	return skip >= 7 ? 7 : skip + 1;
+}
+
+
+static int get_meta_index(struct inode *inode, int index,
+		long long *index_block, int *index_offset,
+		long long *data_block, char *block_list)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int skip = calculate_skip(i_size_read(inode) >> sblk->block_log);
+	int offset = 0;
+	struct meta_index *meta;
+	struct meta_entry *meta_entry;
+	long long cur_index_block = SQUASHFS_I(inode)->u.s1.block_list_start;
+	int cur_offset = SQUASHFS_I(inode)->offset;
+	long long cur_data_block = SQUASHFS_I(inode)->start_block;
+	int i;
+ 
+	index /= SQUASHFS_META_INDEXES * skip;
+
+	while (offset < index) {
+		meta = locate_meta_index(inode, index, offset + 1);
+
+		if (meta == NULL) {
+			meta = empty_meta_index(inode, offset + 1, skip);
+			if (meta == NULL)
+				goto all_done;
+		} else {
+			if(meta->entries == 0)
+				goto failed;
+			/* XXX */
+			offset = index < meta->offset + meta->entries ? index :
+				meta->offset + meta->entries - 1;
+			/* XXX */
+			meta_entry = &meta->meta_entry[offset - meta->offset];
+			cur_index_block = meta_entry->index_block + sblk->inode_table_start;
+			cur_offset = meta_entry->offset;
+			cur_data_block = meta_entry->data_block;
+			TRACE("get_meta_index: offset %d, meta->offset %d, "
+				"meta->entries %d\n", offset, meta->offset, meta->entries);
+			TRACE("get_meta_index: index_block 0x%llx, offset 0x%x"
+				" data_block 0x%llx\n", cur_index_block,
+				cur_offset, cur_data_block);
+		}
+
+		for (i = meta->offset + meta->entries; i <= index &&
+				i < meta->offset + SQUASHFS_META_ENTRIES; i++) {
+			int blocks = skip * SQUASHFS_META_INDEXES;
+
+			while (blocks) {
+				int block = blocks > (SIZE >> 2) ? (SIZE >> 2) : blocks;
+				int res = read_block_index(inode->i_sb, block, block_list,
+					&cur_index_block, &cur_offset);
+
+				if (res == -1)
+					goto failed;
+
+				cur_data_block += res;
+				blocks -= block;
+			}
+
+			meta_entry = &meta->meta_entry[i - meta->offset];
+			meta_entry->index_block = cur_index_block - sblk->inode_table_start;
+			meta_entry->offset = cur_offset;
+			meta_entry->data_block = cur_data_block;
+			meta->entries ++;
+			offset ++;
+		}
+
+		TRACE("get_meta_index: meta->offset %d, meta->entries %d\n",
+				meta->offset, meta->entries);
+
+		release_meta_index(inode, meta);
+	}
+
+all_done:
+	*index_block = cur_index_block;
+	*index_offset = cur_offset;
+	*data_block = cur_data_block;
+
+	return offset * SQUASHFS_META_INDEXES * skip;
+
+failed:
+	release_meta_index(inode, meta);
+	return -1;
+}
+
+
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize)
+{
+	long long block_ptr;
+	int offset;
+	long long block;
+	int res = get_meta_index(inode, index, &block_ptr, &offset, &block,
+		block_list);
+
+	TRACE("read_blocklist: res %d, index %d, block_ptr 0x%llx, offset"
+		       " 0x%x, block 0x%llx\n", res, index, block_ptr, offset, block);
+
+	if(res == -1)
+		goto failure;
+
+	index -= res;
+
+	while (index) {
+		int blocks = index > (SIZE >> 2) ? (SIZE >> 2) : index;
+		int res = read_block_index(inode->i_sb, blocks, block_list,
+			&block_ptr, &offset);
+		if (res == -1)
+			goto failure;
+		block += res;
+		index -= blocks;
+	}
+
+	if (read_block_index(inode->i_sb, 1, block_list, &block_ptr, &offset) == -1)
+		goto failure;
+	*bsize = *((unsigned int *) block_list);
+
+	return block;
+
+failure:
+	return 0;
+}
+
+
+static int squashfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char *block_list = NULL;
+	long long block;
+	unsigned int bsize, i;
+	int bytes;
+	int index = page->index >> (sblk->block_log - PAGE_CACHE_SHIFT);
+ 	void *pageaddr;
+	struct squashfs_fragment_cache *fragment = NULL;
+	char *data_ptr = msblk->read_page;
+	
+	int mask = (1 << (sblk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask;
+	int end_index = start_index | mask;
+	int file_end = i_size_read(inode) >> sblk->block_log;
+	int sparse = 0;
+
+	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
+					page->index, SQUASHFS_I(inode)->start_block);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT))
+		goto out;
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < file_end) {
+		block_list = kmalloc(SIZE, GFP_KERNEL);
+		if (block_list == NULL) {
+			ERROR("Failed to allocate block_list\n");
+			goto error_out;
+		}
+
+		block = (msblk->read_blocklist)(inode, index, 1, block_list, NULL, &bsize);
+		if (block == 0)
+			goto error_out;
+
+		if (bsize == 0) { /* hole */
+			bytes = index == file_end ?
+				(i_size_read(inode) & (sblk->block_size - 1)) : sblk->block_size;
+			sparse = 1;
+		} else {
+			mutex_lock(&msblk->read_page_mutex);
+		
+			bytes = squashfs_read_data(inode->i_sb, msblk->read_page, block,
+				bsize, NULL, sblk->block_size);
+
+			if (bytes == 0) {
+				ERROR("Unable to read page, block %llx, size %x\n", block, bsize);
+				mutex_unlock(&msblk->read_page_mutex);
+				goto error_out;
+			}
+		}
+	} else {
+		fragment = get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)-> u.s1.fragment_start_block,
+					SQUASHFS_I(inode)->u.s1.fragment_size);
+
+		if (fragment == NULL) {
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->u.s1.fragment_start_block,
+					(int) SQUASHFS_I(inode)->u.s1.fragment_size);
+			goto error_out;
+		}
+		bytes = i_size_read(inode) & (sblk->block_size - 1);
+		data_ptr = fragment->data + SQUASHFS_I(inode)->u.s1.fragment_offset;
+	}
+
+	for (i = start_index; i <= end_index && bytes > 0; i++,
+						bytes -= PAGE_CACHE_SIZE, data_ptr += PAGE_CACHE_SIZE) {
+		struct page *push_page;
+		int avail = sparse ? 0 : min_t(unsigned int, bytes, PAGE_CACHE_SIZE);
+
+		TRACE("bytes %d, i %d, available_bytes %d\n", bytes, i, avail);
+
+		push_page = (i == page->index) ? page :
+			grab_cache_page_nowait(page->mapping, i);
+
+		if (!push_page)
+			continue;
+
+		if (PageUptodate(push_page))
+			goto skip_page;
+
+ 		pageaddr = kmap_atomic(push_page, KM_USER0);
+		memcpy(pageaddr, data_ptr, avail);
+		memset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);
+		kunmap_atomic(pageaddr, KM_USER0);
+		flush_dcache_page(push_page);
+		SetPageUptodate(push_page);
+skip_page:
+		unlock_page(push_page);
+		if(i != page->index)
+			page_cache_release(push_page);
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < file_end) {
+		if (!sparse)
+			mutex_unlock(&msblk->read_page_mutex);
+		kfree(block_list);
+	} else
+		release_cached_fragment(msblk, fragment);
+
+	return 0;
+
+error_out:
+	SetPageError(page);
+out:
+	pageaddr = kmap_atomic(page, KM_USER0);
+	memset(pageaddr, 0, PAGE_CACHE_SIZE);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	if (!PageError(page))
+		SetPageUptodate(page);
+	unlock_page(page);
+
+	kfree(block_list);
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s,
+				long long *next_block, unsigned int *next_offset,
+				long long index_start, unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	f_pos =- 3;
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, &sindex, index_start, index_offset,
+					sizeof(sindex), &index_start, &index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, &index, index_start, index_offset,
+					sizeof(index), &index_start, &index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start, &index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length + 3;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s,
+				long long *next_block, unsigned int *next_offset,
+				long long index_start, unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL);
+	if (str == NULL) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, &sindex, index_start, index_offset,
+				sizeof(sindex), &index_start, &index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, index, index_start, index_offset,
+				sizeof(struct squashfs_dir_index), &index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start, index_offset,
+					index->size + 1, &index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+
+failure:
+	return length + 3;
+}
+
+		
+static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_readdir [%llx:%x]\n", next_block, next_offset);
+
+	dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL);
+	if (dire == NULL) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	while(file->f_pos < 3) {
+		char *name;
+		int size, i_ino;
+
+		if(file->f_pos == 0) {
+			name = ".";
+			size = 1;
+			i_ino = i->i_ino;
+		} else {
+			name = "..";
+			size = 2;
+			i_ino = SQUASHFS_I(i)->u.s2.parent_inode;
+		}
+		TRACE("Calling filldir(%x, %s, %d, %d, %d, %d)\n",
+				(unsigned int) dirent, name, size, (int)
+				file->f_pos, i_ino, squashfs_filetype_table[1]);
+
+		if (filldir(dirent, name, size, file->f_pos, i_ino,
+				squashfs_filetype_table[1]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+			goto finish;
+		}
+		file->f_pos += size;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,
+					 next_offset, sizeof(sdirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,
+					next_offset, sizeof(dirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,
+						next_offset, sizeof(sdire), &next_block, &next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, dire, next_block,
+						next_offset, sizeof(*dire), &next_block, &next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
+						next_offset, dire->size + 1, &next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d, %d)\n",
+					(unsigned int) dirent, dire->name, dire->size + 1,
+					(int) file->f_pos, dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1, file->f_pos,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_lookup [%llx:%x]\n", next_block, next_offset);
+
+	dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL);
+	if (dire == NULL) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_lookup;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_lookup;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name, len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,
+					 next_offset, sizeof(sdirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,
+					next_offset, sizeof(dirh), &next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,
+						next_offset, sizeof(sdire), &next_block, &next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, dire, next_block,
+						next_offset, sizeof(*dire), &next_block, &next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
+					next_offset, dire->size + 1, &next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (name[0] < dire->name[0])
+				goto exit_lookup;
+
+			if ((len == dire->size + 1) && !strncmp(name, dire->name, len)) {
+				squashfs_inode_t ino = SQUASHFS_MKINODE(dirh.start_block,
+								dire->offset);
+
+				TRACE("calling squashfs_iget for directory entry %s, inode"
+					"  %x:%x, %d\n", name, dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number);
+
+				inode = squashfs_iget(i->i_sb, ino, dirh.inode_number + dire->inode_number);
+
+				goto exit_lookup;
+			}
+		}
+	}
+
+exit_lookup:
+	kfree(dire);
+	if (inode)
+		return d_splice_alias(inode, dentry);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_lookup;
+}
+
+
+static int squashfs_remount(struct super_block *s, int *flags, char *data)
+{
+	*flags |= MS_RDONLY;
+	return 0;
+}
+
+
+static void squashfs_put_super(struct super_block *s)
+{
+	int i;
+
+	if (s->s_fs_info) {
+		struct squashfs_sb_info *sbi = s->s_fs_info;
+		if (sbi->block_cache)
+			for (i = 0; i < squashfs_cached_blks; i++)
+				if (sbi->block_cache[i].block != SQUASHFS_INVALID_BLK)
+					vfree(sbi->block_cache[i].data);
+		if (sbi->fragment)
+			for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) 
+				vfree(sbi->fragment[i].data);
+		kfree(sbi->fragment);
+		kfree(sbi->block_cache);
+		vfree(sbi->read_page);
+		kfree(sbi->uid);
+		kfree(sbi->fragment_index);
+		kfree(sbi->fragment_index_2);
+		kfree(sbi->meta_index);
+		kfree(s->s_fs_info);
+		s->s_fs_info = NULL;
+	}
+}
+
+
+static int squashfs_get_sb(struct file_system_type *fs_type, int flags,
+				const char *dev_name, void *data, struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super,
+				mnt);
+}
+
+static void free_sqlzma(void)
+{
+	int cpu;
+	struct sqlzma *p;
+
+	for_each_online_cpu(cpu) {
+		p = per_cpu(sqlzma, cpu);
+		if (p) {
+#ifdef KeepPreemptive
+			mutex_destroy(&p->mtx);
+#endif
+			sqlzma_fin(&p->un);
+			kfree(p);
+		}
+	}
+}
+
+static int __init init_squashfs_fs(void)
+{
+ 	struct sqlzma *p;
+ 	int cpu;
+	int err = init_inodecache();
+	if (err)
+		goto out;
+
+	for_each_online_cpu(cpu) {
+		dpri("%d: %p\n", cpu, per_cpu(sqlzma, cpu));
+		err = -ENOMEM;
+		p = kmalloc(sizeof(struct sqlzma), GFP_KERNEL);
+		if (p) {
+#ifdef KeepPreemptive
+			mutex_init(&p->mtx);
+#endif
+			err = sqlzma_init(&p->un, 1, 0);
+			if (unlikely(err)) {
+				ERROR("Failed to intialize uncompress workspace\n");
+				break;
+			}
+			per_cpu(sqlzma, cpu) = p;
+			err = 0;
+		} else
+			break;
+	}
+	if (unlikely(err)) {
+		free_sqlzma();
+		goto out;
+	}
+ 
+
+	printk(KERN_INFO "squashfs: version 3.3-CVS (2008/04/04) "
+		"Phillip Lougher\n"
+		"squashfs: LZMA suppport for slax.org by jro\n");
+
+	err = register_filesystem(&squashfs_fs_type);
+	if (err)
+ 	if (err) {
+ 		free_sqlzma();
+		destroy_inodecache();
+ 	}
+
+out:
+	return err;
+}
+
+
+static void __exit exit_squashfs_fs(void)
+{
+	unregister_filesystem(&squashfs_fs_type);
+	free_sqlzma();
+	destroy_inodecache();
+}
+
+
+static struct kmem_cache * squashfs_inode_cachep;
+
+
+static struct inode *squashfs_alloc_inode(struct super_block *sb)
+{
+	struct squashfs_inode_info *ei;
+	ei = kmem_cache_alloc(squashfs_inode_cachep, GFP_KERNEL);
+	return ei ? &ei->vfs_inode : NULL;
+}
+
+
+static void squashfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(squashfs_inode_cachep, SQUASHFS_I(inode));
+}
+
+
+static void init_once(struct kmem_cache *cachep, void *foo)
+{
+	struct squashfs_inode_info *ei = foo;
+
+	inode_init_once(&ei->vfs_inode);
+}
+ 
+
+static int __init init_inodecache(void)
+{
+	squashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",
+	    sizeof(struct squashfs_inode_info), 0,
+		SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once);
+	if (squashfs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+
+static void destroy_inodecache(void)
+{
+	kmem_cache_destroy(squashfs_inode_cachep);
+}
+
+
+module_init(init_squashfs_fs);
+module_exit(exit_squashfs_fs);
+MODULE_DESCRIPTION("squashfs 3.3, a compressed read-only filesystem, and LZMA suppport for slax.org");
+MODULE_AUTHOR("Phillip Lougher <phillip@lougher.demon.co.uk>, and LZMA suppport for slax.org by jro");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.25.8/fs/squashfs/module.c linux-2.6.25.8-clean/fs/squashfs/module.c
--- linux-2.6.25.8/fs/squashfs/module.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/module.c	2008-07-23 15:43:37.000000000 -0400
@@ -0,0 +1,36 @@
+
+/*
+ * Copyright (C) 2006-2007 Junjiro Okajima
+ * Copyright (C) 2006-2007 Tomas Matejicek, slax.org
+ *
+ * LICENSE follows the described one in lzma.txt.
+ */
+
+/* $Id: module.c,v 1.1 2007-11-05 05:43:36 jro Exp $ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include "LzmaDecode.c"
+
+EXPORT_SYMBOL(LzmaDecodeProperties);
+EXPORT_SYMBOL(LzmaDecode);
+
+#if 0
+static int __init unlzma_init(void)
+{
+	return 0;
+}
+
+static void __exit unlzma_exit(void)
+{
+}
+
+module_init(unlzma_init);
+module_exit(unlzma_exit);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("$Id: module.c,v 1.1 2007-11-05 05:43:36 jro Exp $");
+MODULE_DESCRIPTION("LZMA uncompress. "
+		   "A tiny wrapper for LzmaDecode.c in LZMA SDK from www.7-zip.org.");
diff -Naur linux-2.6.25.8/fs/squashfs/sqlzma.h linux-2.6.25.8-clean/fs/squashfs/sqlzma.h
--- linux-2.6.25.8/fs/squashfs/sqlzma.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/sqlzma.h	2008-07-23 15:44:18.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2006-2008 Junjiro Okajima
+ * Copyright (C) 2006-2008 Tomas Matejicek, slax.org
+ *
+ * LICENSE follows the described one in lzma.
+ */
+
+/* $Id: sqlzma.h,v 1.20 2008-03-12 16:58:34 jro Exp $ */
+
+#ifndef __sqlzma_h__
+#define __sqlzma_h__
+
+#ifndef __KERNEL__
+#include <stdlib.h>
+#include <string.h>
+#include <zlib.h>
+#ifdef _REENTRANT
+#include <pthread.h>
+#endif
+#else
+#include <linux/zlib.h>
+#endif
+#define _7ZIP_BYTE_DEFINED
+
+/*
+ * detect the compression method automatically by the first byte of compressed
+ * data.
+ * according to rfc1950, the first byte of zlib compression must be 0x?8.
+ */
+#define is_lzma(c)	(c == 0x5d)
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __KERNEL__
+/* for mksquashfs only */
+struct sqlzma_opts {
+	unsigned int	try_lzma;
+	unsigned int 	dicsize;
+};
+int sqlzma_cm(struct sqlzma_opts *opts, z_stream *stream, Bytef *next_in,
+	      uInt avail_in, Bytef *next_out, uInt avail_out);
+#endif
+
+/* ---------------------------------------------------------------------- */
+/*
+ * Three patterns for sqlzma uncompression. very dirty code.
+ * - kernel space (squashfs kernel module)
+ * - user space with pthread (mksquashfs)
+ * - user space without pthread (unsquashfs)
+ */
+
+struct sized_buf {
+	unsigned int	sz;
+	unsigned char	*buf;
+};
+
+enum {SQUN_PROB, SQUN_RESULT, SQUN_LAST};
+struct sqlzma_un {
+	int			un_lzma;
+	struct sized_buf	un_a[SQUN_LAST];
+	unsigned char           un_prob[31960]; /* unlzma 64KB - 1MB */
+	z_stream		un_stream;
+#define un_cmbuf	un_stream.next_in
+#define un_cmlen	un_stream.avail_in
+#define un_resbuf	un_stream.next_out
+#define un_resroom	un_stream.avail_out
+#define un_reslen	un_stream.total_out
+};
+
+int sqlzma_init(struct sqlzma_un *un, int do_lzma, unsigned int res_sz);
+int sqlzma_un(struct sqlzma_un *un, struct sized_buf *src,
+	      struct sized_buf *dst);
+void sqlzma_fin(struct sqlzma_un *un);
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+};
+#endif
+#endif
diff -Naur linux-2.6.25.8/fs/squashfs/sqmagic.h linux-2.6.25.8-clean/fs/squashfs/sqmagic.h
--- linux-2.6.25.8/fs/squashfs/sqmagic.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/sqmagic.h	2008-07-23 15:44:20.000000000 -0400
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2006 Junjiro Okajima
+ * Copyright (C) 2006 Tomas Matejicek, slax.org
+ *
+ * LICENSE must follow the one in squashfs.
+ */
+
+/* $Id: sqmagic.h,v 1.2 2006-11-27 03:54:58 jro Exp $ */
+
+#ifndef __sqmagic_h__
+#define __sqmagic_h__
+
+/* see SQUASHFS_MAGIC in squashfs_fs.h */
+#define SQUASHFS_MAGIC_LZMA		0x71736873
+#define SQUASHFS_MAGIC_LZMA_SWAP	0x73687371
+
+#endif
diff -Naur linux-2.6.25.8/fs/squashfs/squashfs.h linux-2.6.25.8-clean/fs/squashfs/squashfs.h
--- linux-2.6.25.8/fs/squashfs/squashfs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/squashfs.h	2008-07-10 14:48:20.000000000 -0400
@@ -0,0 +1,86 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs.h
+ */
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#undef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#endif
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)	printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+#else
+#define TRACE(s, args...)	{}
+#endif
+
+#define ERROR(s, args...)	printk(KERN_ERR "SQUASHFS error: "s, ## args)
+
+#define SERROR(s, args...)	do { \
+				if (!silent) \
+				printk(KERN_ERR "SQUASHFS error: "s, ## args);\
+				} while(0)
+
+#define WARNING(s, args...)	printk(KERN_WARNING "SQUASHFS: "s, ## args)
+
+static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
+{
+	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
+}
+
+#if defined(CONFIG_SQUASHFS_1_0_COMPATIBILITY ) || defined(CONFIG_SQUASHFS_2_0_COMPATIBILITY)
+#define SQSH_EXTERN
+extern unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+				long long index, unsigned int length,
+				long long *next_index, int srclength);
+extern int squashfs_get_cached_block(struct super_block *s, void *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset);
+extern void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment);
+extern struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length);
+extern struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode, unsigned int inode_number);
+extern const struct address_space_operations squashfs_symlink_aops;
+extern const struct address_space_operations squashfs_aops;
+extern struct inode_operations squashfs_dir_inode_ops;
+#else
+#define SQSH_EXTERN static
+#endif
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+extern int squashfs_1_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_1_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+extern int squashfs_2_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
diff -Naur linux-2.6.25.8/fs/squashfs/squashfs2_0.c linux-2.6.25.8-clean/fs/squashfs/squashfs2_0.c
--- linux-2.6.25.8/fs/squashfs/squashfs2_0.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/squashfs2_0.c	2008-07-10 14:48:20.000000000 -0400
@@ -0,0 +1,740 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs2_0.c
+ */
+
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+
+#include "squashfs.h"
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir);
+static struct dentry *squashfs_lookup_2(struct inode *, struct dentry *,
+				struct nameidata *);
+
+static struct file_operations squashfs_dir_ops_2 = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir_2
+};
+
+static struct inode_operations squashfs_dir_inode_ops_2 = {
+	.lookup = squashfs_lookup_2
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static int read_fragment_index_table_2(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	if (!(msblk->fragment_index_2 = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+   
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index_2,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments))) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		unsigned int fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES_2(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES_2((&fragment),
+						&msblk->fragment_index_2[i], 1);
+			msblk->fragment_index_2[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int get_fragment_location_2(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index_2[SQUASHFS_FRAGMENT_INDEX_2(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET_2(fragment);
+	struct squashfs_fragment_entry_2 fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry_2 sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY_2(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+		struct squashfs_base_inode_header_2 *inodeb, unsigned int ino)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	i->i_ino = ino;
+	i->i_mtime.tv_sec = sblk->mkfs_time;
+	i->i_atime.tv_sec = sblk->mkfs_time;
+	i->i_ctime.tv_sec = sblk->mkfs_time;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_nlink = 1;
+	i->i_size = 0;
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
+
+
+static int squashfs_read_inode_2(struct inode *i, squashfs_inode_t inode)
+{
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int ino = SQUASHFS_MK_VFS_INODE(block -
+		sblk->inode_table_start, offset);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header_2 id, sid;
+	struct squashfs_base_inode_header_2 *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_read_inode_2\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER_2(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	squashfs_new_inode(msblk, i, inodeb, ino);
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header_2 *inodep = &id.reg;
+			struct squashfs_reg_inode_header_2 *sinodep = &sid.reg;
+			long long frag_blk;
+			unsigned int frag_size = 0;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location_2(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %x, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header_2 *inodep = &id.dir;
+			struct squashfs_dir_inode_header_2 *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header_2 *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header_2 *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER_2(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header_2 *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header_2 *sinodep =
+								&sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header_2 *inodep = &id.dev;
+			struct squashfs_dev_inode_header_2 *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	return 1;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long 
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	if (!(str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index_2 *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index_2),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+failure:
+	return length;
+}
+
+		
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+		dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+
+	TRACE("Entered squashfs_readdir_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos, SQUASHFS_MK_VFS_INODE(
+					dirh.start_block, dire->offset),
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup_2(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+	int sorted = sblk->s_major == 2 && sblk->s_minor >= 1;
+
+	TRACE("Entered squashfs_lookup_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_loop;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (sorted && name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+				unsigned int inode_number = SQUASHFS_MK_VFS_INODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %lld\n", name,
+					dirh.start_block, dire->offset, ino);
+
+				inode = squashfs_iget(i->i_sb, ino, inode_number);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	kfree(dire);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode_2;
+	msblk->read_fragment_index_table = read_fragment_index_table_2;
+
+	sblk->bytes_used = sblk->bytes_used_2;
+	sblk->uid_start = sblk->uid_start_2;
+	sblk->guid_start = sblk->guid_start_2;
+	sblk->inode_table_start = sblk->inode_table_start_2;
+	sblk->directory_table_start = sblk->directory_table_start_2;
+	sblk->fragment_table_start = sblk->fragment_table_start_2;
+
+	return 1;
+}
diff -Naur linux-2.6.25.8/fs/squashfs/uncomp.c linux-2.6.25.8-clean/fs/squashfs/uncomp.c
--- linux-2.6.25.8/fs/squashfs/uncomp.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/fs/squashfs/uncomp.c	2008-07-23 15:43:08.000000000 -0400
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2006-2008 Junjiro Okajima
+ * Copyright (C) 2006-2008 Tomas Matejicek, slax.org
+ *
+ * LICENSE follows the described one in lzma.txt.
+ */
+
+/* $Id: uncomp.c,v 1.7 2008-03-12 16:58:34 jro Exp $ */
+
+/* extract some parts from lzma443/C/7zip/Compress/LZMA_C/LzmaTest.c */
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <assert.h>
+#include <pthread.h>
+#define unlikely(x)		__builtin_expect(!!(x), 0)
+#define BUG_ON(x)		assert(!(x))
+/* sqlzma buffers are always larger than a page. true? */
+#define kmalloc(sz,gfp)		malloc(sz)
+#define kfree(p)		free(p)
+#define zlib_inflate(s, f)	inflate(s, f)
+#define zlib_inflateInit(s)	inflateInit(s)
+#define zlib_inflateReset(s)	inflateReset(s)
+#define zlib_inflateEnd(s)	inflateEnd(s)
+#else
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#ifndef WARN_ON_ONCE
+#define WARN_ON_ONCE(b)	WARN_ON(b)
+#endif
+#endif /* __KERNEL__ */
+
+#include "sqlzma.h"
+#include "LzmaDecode.h"
+
+static int LzmaUncompress(struct sqlzma_un *un)
+{
+	int err, i, ret;
+	SizeT outSize, inProcessed, outProcessed, srclen;
+	/* it's about 24-80 bytes structure, if int is 32-bit */
+	CLzmaDecoderState state;
+	unsigned char *dst, *src, a[8];
+	struct sized_buf *sbuf;
+
+	/* Decode LZMA properties and allocate memory */
+	err = -EINVAL;
+	src = (void *)un->un_cmbuf;
+	ret = LzmaDecodeProperties(&state.Properties, src,
+				   LZMA_PROPERTIES_SIZE);
+	src += LZMA_PROPERTIES_SIZE;
+	if (unlikely(ret != LZMA_RESULT_OK))
+		goto out;
+	i = LzmaGetNumProbs(&state.Properties);
+	if (unlikely(i <= 0))
+		i = 1;
+	i *= sizeof(CProb);
+	sbuf = un->un_a + SQUN_PROB;
+	if (unlikely(sbuf->sz < i)) {
+		if (sbuf->buf && sbuf->buf != un->un_prob)
+			kfree(sbuf->buf);
+#ifdef __KERNEL__
+		printk("%s:%d: %d --> %d\n", __func__, __LINE__, sbuf->sz, i);
+#else
+		printf("%d --> %d\n", sbuf->sz, i);
+#endif
+		err = -ENOMEM;
+		sbuf->sz = 0;
+		sbuf->buf = kmalloc(i, GFP_ATOMIC);
+		if (unlikely(!sbuf->buf))
+			goto out;
+		sbuf->sz = i;
+	}
+	state.Probs = (void *)sbuf->buf;
+
+	/* Read uncompressed size */
+	memcpy(a, src, sizeof(a));
+	src += sizeof(a);
+	outSize = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24);
+
+	err = -EINVAL;
+	dst = un->un_resbuf;
+	if (unlikely(!dst || outSize > un->un_reslen))
+		goto out;
+	un->un_reslen = outSize;
+	srclen = un->un_cmlen - (src - un->un_cmbuf);
+
+	/* Decompress */
+	err = LzmaDecode(&state, src, srclen, &inProcessed, dst, outSize,
+			 &outProcessed);
+	if (unlikely(err))
+		err = -EINVAL;
+
+ out:
+#ifndef __KERNEL__
+	if (err)
+		fprintf(stderr, "err %d\n", err);
+#endif
+	return err;
+}
+
+int sqlzma_un(struct sqlzma_un *un, struct sized_buf *src,
+	      struct sized_buf *dst)
+{
+	int err, by_lzma = 1;
+	if (un->un_lzma && is_lzma(*src->buf)) {
+		un->un_cmbuf = src->buf;
+		un->un_cmlen = src->sz;
+		un->un_resbuf = dst->buf;
+		un->un_reslen = dst->sz;
+
+		/* this library is thread-safe */
+		err = LzmaUncompress(un);
+		goto out;
+	}
+
+	by_lzma = 0;
+	err = zlib_inflateReset(&un->un_stream);
+	if (unlikely(err != Z_OK))
+		goto out;
+	un->un_stream.next_in = src->buf;
+	un->un_stream.avail_in = src->sz;
+	un->un_stream.next_out = dst->buf;
+	un->un_stream.avail_out = dst->sz;
+	err = zlib_inflate(&un->un_stream, Z_FINISH);
+	if (err == Z_STREAM_END)
+		err = 0;
+
+ out:
+	if (unlikely(err)) {
+#ifdef __KERNEL__
+		WARN_ON_ONCE(1);
+#else
+		char a[64] = "ZLIB ";
+		if (by_lzma) {
+			strcpy(a, "LZMA ");
+#ifdef _REENTRANT
+			strerror_r(err, a + 5, sizeof(a) - 5);
+#else
+			strncat(a, strerror(err), sizeof(a) - 5);
+#endif
+		} else
+			strncat(a, zError(err), sizeof(a) - 5);
+		fprintf(stderr, "%s: %.*s\n", __func__, sizeof(a), a);
+#endif
+	}
+	return err;
+}
+
+int sqlzma_init(struct sqlzma_un *un, int do_lzma, unsigned int res_sz)
+{
+	int err;
+
+	err = -ENOMEM;
+	un->un_lzma = do_lzma;
+	memset(un->un_a, 0, sizeof(un->un_a));
+	un->un_a[SQUN_PROB].buf = un->un_prob;
+	un->un_a[SQUN_PROB].sz = sizeof(un->un_prob);
+	if (res_sz) {
+		un->un_a[SQUN_RESULT].buf = kmalloc(res_sz, GFP_KERNEL);
+		if (unlikely(!un->un_a[SQUN_RESULT].buf))
+			return err;
+		un->un_a[SQUN_RESULT].sz = res_sz;
+	}
+
+	un->un_stream.next_in = NULL;
+	un->un_stream.avail_in = 0;
+#ifdef __KERNEL__
+	un->un_stream.workspace = kmalloc(zlib_inflate_workspacesize(),
+					  GFP_KERNEL);
+	if (unlikely(!un->un_stream.workspace))
+		return err;
+#else
+	un->un_stream.opaque = NULL;
+	un->un_stream.zalloc = Z_NULL;
+	un->un_stream.zfree = Z_NULL;
+#endif
+	err = zlib_inflateInit(&un->un_stream);
+	if (unlikely(err == Z_MEM_ERROR))
+		return -ENOMEM;
+	BUG_ON(err);
+	return err;
+}
+
+void sqlzma_fin(struct sqlzma_un *un)
+{
+	int i;
+	for (i = 0; i < SQUN_LAST; i++)
+		if (un->un_a[i].buf && un->un_a[i].buf != un->un_prob)
+			kfree(un->un_a[i].buf);
+	BUG_ON(zlib_inflateEnd(&un->un_stream) != Z_OK);
+}
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(sqlzma_un);
+EXPORT_SYMBOL(sqlzma_init);
+EXPORT_SYMBOL(sqlzma_fin);
+
+#if 0
+static int __init sqlzma_init(void)
+{
+	return 0;
+}
+
+static void __exit sqlzma_exit(void)
+{
+}
+
+module_init(sqlzma_init);
+module_exit(sqlzma_exit);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Junjiro Okajima <sfjro at users dot sf dot net>");
+MODULE_VERSION("$Id: uncomp.c,v 1.7 2008-03-12 16:58:34 jro Exp $");
+MODULE_DESCRIPTION("LZMA uncompress for squashfs. "
+		   "Some functions for squashfs to support LZMA and "
+		   "a tiny wrapper for LzmaDecode.c in LZMA SDK from www.7-zip.org.");
+#endif
diff -Naur linux-2.6.25.8/include/asm-mips/bootinfo.h linux-2.6.25.8-clean/include/asm-mips/bootinfo.h
--- linux-2.6.25.8/include/asm-mips/bootinfo.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/bootinfo.h	2008-06-26 14:59:44.000000000 -0400
@@ -94,6 +94,12 @@
 #define MACH_MSP7120_FPGA       5	/* PMC-Sierra MSP7120 Emulation */
 #define MACH_MSP_OTHER        255	/* PMC-Sierra unknown board type */
 
+/*
+ * Valid machtype for group SIGMADESIGNS
+ */
+#define MACH_GROUP_SIGMADESIGNS	23	/* For SigmaDesigns Tango2/Tango3 board */
+#define  MACH_TANGOX		 1	/* Tango2/Tango3 */
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 extern char *system_type;
diff -Naur linux-2.6.25.8/include/asm-mips/checksum.h linux-2.6.25.8-clean/include/asm-mips/checksum.h
--- linux-2.6.25.8/include/asm-mips/checksum.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/checksum.h	2008-12-11 13:16:31.000000000 -0500
@@ -36,10 +36,14 @@
  * this is a new version of the above that records errors it finds in *errp,
  * but continues and zeros the rest of the buffer.
  */
+
+extern long long em86_stats[20];
+
 static inline
 __wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
 				   __wsum sum, int *err_ptr)
 {
+	em86_stats[17]+=len;
 	might_sleep();
 	return __csum_partial_copy_user((__force void *)src, dst,
 					len, sum, err_ptr);
diff -Naur linux-2.6.25.8/include/asm-mips/delay.h linux-2.6.25.8-clean/include/asm-mips/delay.h
--- linux-2.6.25.8/include/asm-mips/delay.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/delay.h	2008-06-26 14:59:44.000000000 -0400
@@ -98,7 +98,12 @@
 
 #define __udelay_val cpu_data[raw_smp_processor_id()].udelay_val
 
+#if defined(CONFIG_TANGOX) && !defined(CONFIG_TANGOX_USE_CPU_CLOCK)
+void tangox_udelay(unsigned usec);
+#define udelay(usecs) tangox_udelay(usecs)
+#else
 #define udelay(usecs) __udelay((usecs), __udelay_val)
+#endif
 
 /* make sure "usecs *= ..." in udelay do not overflow. */
 #if HZ >= 1000
diff -Naur linux-2.6.25.8/include/asm-mips/dma.h linux-2.6.25.8-clean/include/asm-mips/dma.h
--- linux-2.6.25.8/include/asm-mips/dma.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/dma.h	2008-06-26 14:59:44.000000000 -0400
@@ -87,6 +87,8 @@
 #if defined(CONFIG_SGI_IP22) || defined(CONFIG_SGI_IP28)
 /* don't care; ISA bus master won't work, ISA slave DMA supports 32bit addr */
 #define MAX_DMA_ADDRESS		PAGE_OFFSET
+#elif defined(CONFIG_TANGOX)
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x20000000)
 #else
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)
 #endif
diff -Naur linux-2.6.25.8/include/asm-mips/io.h linux-2.6.25.8-clean/include/asm-mips/io.h
--- linux-2.6.25.8/include/asm-mips/io.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/io.h	2008-06-26 14:59:44.000000000 -0400
@@ -336,6 +336,7 @@
 			local_irq_restore(__flags);			\
 	} else								\
 		BUG();							\
+	__sync();                                                       \
 }									\
 									\
 static inline type pfx##read##bwlq(const volatile void __iomem *mem)	\
@@ -385,6 +386,7 @@
 	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
 									\
 	*__addr = __val;						\
+	__sync();                                                       \
 	slow;								\
 }									\
 									\
@@ -527,6 +529,16 @@
 	memcpy((void __force *) dst, src, count);
 }
 
+/* Create a virtual mapping cookie for an IO port range */
+extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
+extern void ioport_unmap(void __iomem *);
+
+/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
+struct pci_dev;
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long
+			       max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
 /*
  * ISA space is 'always mapped' on currently supported MIPS systems, no need
  * to explicitly ioremap() it. The fact that the ISA IO space is mapped
diff -Naur linux-2.6.25.8/include/asm-mips/mach-mips/irq.h linux-2.6.25.8-clean/include/asm-mips/mach-mips/irq.h
--- linux-2.6.25.8/include/asm-mips/mach-mips/irq.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/mach-mips/irq.h	2008-06-26 14:59:44.000000000 -0400
@@ -2,6 +2,7 @@
 #define __ASM_MACH_MIPS_IRQ_H
 
 
+#define MIPS_CPU_IRQ_BASE 0
 #define NR_IRQS	256
 
 #include_next <irq.h>
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango2/dma-coherence.h linux-2.6.25.8-clean/include/asm-mips/mach-tango2/dma-coherence.h
--- linux-2.6.25.8/include/asm-mips/mach-tango2/dma-coherence.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango2/dma-coherence.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,98 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2006  Ralf Baechle <ralf@linux-mips.org>
+ *
+ */
+#ifndef __ASM_MACH_TANGO2_DMA_COHERENCE_H
+#define __ASM_MACH_TANGO2_DMA_COHERENCE_H
+
+struct device;
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#endif
+
+extern unsigned long g_pcimem_busaddr;
+extern unsigned long g_pcimem_physaddr;
+extern unsigned long g_pcimem_physaddr_end;
+
+#ifdef CONFIG_PCI
+#define IS_PCIDEV(x)	((x)->bus == &pci_bus_type)
+#else
+#define IS_PCIDEV(x)	0
+#endif
+
+
+#ifdef CONFIG_PCI
+static inline unsigned long __pci_virt_to_bus(unsigned long addr)
+{
+	if ((CPHYSADDR(addr) < g_pcimem_physaddr) ||
+	    (CPHYSADDR(addr) >= g_pcimem_physaddr_end))
+		printk("virt2bus: Not a dma-able address: 0x%08lx\n", addr);
+	return((unsigned long)(CPHYSADDR(addr) - g_pcimem_physaddr +
+			       g_pcimem_busaddr));
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long addr)
+{
+	if ((addr < g_pcimem_busaddr) ||
+	    (addr >= (g_pcimem_busaddr +
+		      (g_pcimem_physaddr_end - g_pcimem_physaddr))))
+		printk("bus2virt: Not a valid bus address: 0x%08lx\n",
+		       addr);
+	return((unsigned long)(addr - g_pcimem_busaddr +
+			       g_pcimem_physaddr + UNCAC_BASE));
+}
+#else
+static inline unsigned long __pci_virt_to_bus(unsigned long addr)
+{
+	return(addr);
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long addr)
+{
+	return(addr);
+}
+#endif
+
+static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr,
+	size_t size)
+{
+		if (IS_PCIDEV(dev))
+			return __pci_virt_to_bus((unsigned long)addr);
+		else
+			return tangox_dma_address(CPHYSADDR(addr));
+}
+
+static dma_addr_t plat_map_dma_mem_page(struct device *dev, struct page *page)
+{
+	if (IS_PCIDEV(dev))
+		return __pci_virt_to_bus(page_to_phys(page));
+	return tangox_dma_address(page_to_phys(page));
+}
+
+/* This is almost certainly wrong but it's what dma-ip32.c used to use  */
+static unsigned long plat_dma_addr_to_phys(dma_addr_t dma_addr)
+{
+	if (IS_PCIDEV(dev)) {
+		return CAC_ADDR(__pci_bus_to_virt(dma_addr));
+	} else {
+		return tangox_inv_dma_address(dma_addr) + PAGE_OFFSET;
+	}
+}
+
+static inline void plat_unmap_dma_mem(dma_addr_t dma_addr)
+{
+}
+
+static inline int plat_device_is_coherent(struct device *dev)
+{
+	return 0;
+}
+
+#endif /* __ASM_MACH_TANGO2_DMA_COHERENCE_H */
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango2/irq.h linux-2.6.25.8-clean/include/asm-mips/mach-tango2/irq.h
--- linux-2.6.25.8/include/asm-mips/mach-tango2/irq.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango2/irq.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,13 @@
+
+#ifndef __ASM_MACH_TANGO2_IRQ_H
+#define __ASM_MACH_TANGO2_IRQ_H
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+# define NR_IRQS 256
+#else
+# define NR_IRQS 128
+#endif
+
+#endif
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango2/param.h linux-2.6.25.8-clean/include/asm-mips/mach-tango2/param.h
--- linux-2.6.25.8/include/asm-mips/mach-tango2/param.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango2/param.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,11 @@
+
+#ifndef __ASM_MACH_TANGO2_PARAM_H
+#define __ASM_MACH_TANGO2_PARAM_H
+
+#ifndef CONFIG_TANGOX_HZ_VALUE
+#define HZ		1000
+#else
+#define HZ		CONFIG_TANGOX_HZ_VALUE
+#endif
+
+#endif /* __ASM_MACH_TANGO2_PARAM_H */
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango2/spaces.h linux-2.6.25.8-clean/include/asm-mips/mach-tango2/spaces.h
--- linux-2.6.25.8/include/asm-mips/mach-tango2/spaces.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango2/spaces.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,33 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO2_SPACES_H
+#define _ASM_MACH_TANGO2_SPACES_H
+
+#define PHYS_OFFSET             0x00000000
+#define CAC_BASE		0x90000000
+#define IO_BASE			0xa0000000
+#define UNCAC_BASE		0xa0000000
+#define MAP_BASE		0xc0000000
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO2_SPACES_H */
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango2/war.h linux-2.6.25.8-clean/include/asm-mips/mach-tango2/war.h
--- linux-2.6.25.8/include/asm-mips/mach-tango2/war.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango2/war.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_TANGO2_WAR_H
+#define __ASM_MIPS_MACH_TANGO2_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_TANGO2_WAR_H */
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango3/irq.h linux-2.6.25.8-clean/include/asm-mips/mach-tango3/irq.h
--- linux-2.6.25.8/include/asm-mips/mach-tango3/irq.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango3/irq.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,9 @@
+
+#ifndef __ASM_MACH_TANGO3_IRQ_H
+#define __ASM_MACH_TANGO3_IRQ_H
+
+#include <linux/config.h>
+
+#define NR_IRQS 256
+
+#endif
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango3/param.h linux-2.6.25.8-clean/include/asm-mips/mach-tango3/param.h
--- linux-2.6.25.8/include/asm-mips/mach-tango3/param.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango3/param.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,11 @@
+
+#ifndef __ASM_MACH_TANGO3_PARAM_H
+#define __ASM_MACH_TANGO3_PARAM_H
+
+#ifndef CONFIG_TANGOX_HZ_VALUE
+#define HZ		1000
+#else
+#define HZ		CONFIG_TANGOX_HZ_VALUE
+#endif
+
+#endif /* __ASM_MACH_TANGO3_PARAM_H */
diff -Naur linux-2.6.25.8/include/asm-mips/mach-tango3/spaces.h linux-2.6.25.8-clean/include/asm-mips/mach-tango3/spaces.h
--- linux-2.6.25.8/include/asm-mips/mach-tango3/spaces.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/mach-tango3/spaces.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,34 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO3_SPACES_H
+#define _ASM_MACH_TANGO3_SPACES_H
+
+#include <linux/config.h>
+
+#define CAC_BASE		0x90000000
+#define IO_BASE			0xa0000000
+#define UNCAC_BASE		0xa0000000
+#define MAP_BASE		0xc0000000
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO3_SPACES_H */
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,65 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram.h
+  @brief  
+
+  fm stands for: first megabyte.
+
+  THE CODE USING THESE SYMBOLS ASSUMES THAT THE END BOUNDARY OF AN
+  ENTITY IS THE START BOUNDARY OF THE NEXT ENTITY
+  
+  htoinc.pl emhwlib_dram.h emhwlib_dram.inc
+  
+  @author Emmanuel Michon
+  @date   2004-07-26
+*/
+
+#ifndef __EMHWLIB_DRAM_H__
+#define __EMHWLIB_DRAM_H__
+
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+#include "emhwlib_dram_tango2.h"
+#else
+#include "emhwlib_dram_others.h"
+#endif
+
+#define MEMCFG_SIGNATURE	0x6766636d // `m' `c' `f' `g'
+
+#ifndef __ASSEMBLY__
+
+/* This is the memory map data structure, the size is 64 bytes */
+typedef struct {
+	unsigned int signature;                                                           // ...fc0
+	unsigned int dram0_size;            /* The size of DRAM0 */
+	unsigned int dram1_size;            /* The size of DRAM1 */
+	unsigned int dram2_size;            /* The size of DRAM2 */
+	unsigned int dram0_removable_topreserved;     /* The size of top reserved in DRAM0   ...fd0 */
+	unsigned int dram1_removable_topreserved;     /* The size of top reserved in DRAM1 */
+	unsigned int dram0_top_removable_area;    /* for special use such as splash screen */ 
+	                                          /* users can use set and get properties on the memory reserved by this variable */
+	unsigned int dram0_fixed_topreserved;     /* The size of top reserved in DRAM0 */
+	unsigned int dram1_fixed_topreserved;     /* The size of top reserved in DRAM1       ...fe0 */
+	unsigned int dram2_fixed_topreserved;     /* The size of top reserved in DRAM2 */
+	unsigned int kernel_end;            /* The end offset of kernel */
+	unsigned int checksum;		    /* The checksum */
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+	unsigned int dram1_kernel_end;	    /* The end offset of kernel used data in second dram */
+	unsigned int curtainA0;                                                      
+	unsigned int curtainB0;
+	unsigned int curtainC;
+#else
+	unsigned int reserved[4];           /* Reserved for extension */
+#endif
+} memcfg_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif // __EMHWLIB_DRAM_H__
+ 
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_others.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_others.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_others.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_others.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,37 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram_others.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed
+  that computing FM_IRQHANDLER_STACKTOP_USR-FM_IRQHANDLER_CODE
+  is a proper way to access the max usable size for
+  FM_IRQHANDLER_CODE.
+
+  @author Emmanuel Michon
+  @date   2005-04-11
+*/
+
+#ifndef __EMHWLIB_DRAM_OTHERS_H__
+#define __EMHWLIB_DRAM_OTHERS_H__
+
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_IRQHANDLER_CODE         0x00011000
+#define FM_IRQHANDLER_STACKTOP_USR 0x00040000 /* defined, but never used */
+#define FM_IRQHANDLER_STACKTOP_IRQ 0x00048000
+#define FM_IRQHANDLER_STACKTOP_FIQ 0x00050000
+#define FM_STACKTOP_SVC            0x00058000
+#define FM_DRM			   0x00058000
+#define FM_GNET			   0x00058000 /* incompatible with DRM */
+#define FM_BOOTLOADER_CODE         0x00060000
+#define FM_RESERVED                0x00080000 /* The size reserved */
+
+#endif // __EMHWLIB_DRAM_OTHERS_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_others.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_others.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_others.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_others.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,25 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_others.inc (generated from emhwlib/include/emhwlib_dram_others.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_IRQHANDLER_CODE=0x11000
+FM_IRQHANDLER_STACKTOP_USR=0x40000
+FM_IRQHANDLER_STACKTOP_IRQ=0x48000
+FM_IRQHANDLER_STACKTOP_FIQ=0x50000
+FM_STACKTOP_SVC=0x58000
+FM_DRM=0x58000
+FM_GNET=0x58000
+FM_BOOTLOADER_CODE=0x60000
+FM_RESERVED=0x80000
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_tango2.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_tango2.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_tango2.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_tango2.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,52 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram_tango2.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed that computing
+  FM_Y-FM_X is a proper way to access the max usable size for FM_X.
+
+  See SMP8630 software spec 3.3
+
+  @author Emmanuel Michon, YH Lin, Julien Soulier
+  @date   2005-04-06
+*/
+
+#ifndef __EMHWLIB_DRAM_TANGO2_H__
+#define __EMHWLIB_DRAM_TANGO2_H__
+
+/* Spec 3.3.5: stage (S4) [fully functional player memory map] */
+#define FM_GNET                    0x00000000
+#define FM_SCRATCH                 0x00000f08 /* 184 bytes */
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_XTASK_API               0x00009e00 /* 512 bytes */
+#define FM_XOSDBG                  0x0000a000
+#define FM_XTASK1DBG               0x0000c000
+#define FM_XTASK2DBG               0x0000d000
+#define FM_XTASK3DBG               0x0000e000
+#define FM_XTASK4DBG               0x0000f000
+#define FM_SCRATCH2                0x00010000
+#define FM_DRAMCALIBRATION         0x0001f000
+#define FM_RESERVED                0x00020000
+
+/*
+  Spec 3.3.5: stage (S0) [bootstrap memory map]
+
+  Because you will use zboot/yamon to download linux/CE
+  at start of DRAM, the former are away from beginning.
+*/
+#define FM_ZBOOT                   0x01000000
+#define FM_YAMON_text_ram          0x01000000
+#define FM_YAMON__ftext_init       0x01200000
+#define FM_yamon_appl__ftext       0x01210000
+#define FM_linuxmips__ftext        0x00020000
+
+#endif // __EMHWLIB_DRAM_TANGO2_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_tango2.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_tango2.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_dram_tango2.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_dram_tango2.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,32 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_tango2.inc (generated from emhwlib/include/emhwlib_dram_tango2.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_GNET=0x0
+FM_SCRATCH=0xf08
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_XTASK_API=0x9e00
+FM_XOSDBG=0xa000
+FM_XTASK1DBG=0xc000
+FM_XTASK2DBG=0xd000
+FM_XTASK3DBG=0xe000
+FM_XTASK4DBG=0xf000
+FM_SCRATCH2=0x10000
+FM_DRAMCALIBRATION=0x1f000
+FM_RESERVED=0x20000
+FM_ZBOOT=0x1000000
+FM_YAMON_text_ram=0x1000000
+FM_YAMON__ftext_init=0x1200000
+FM_yamon_appl__ftext=0x1210000
+FM_linuxmips__ftext=0x20000
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,46 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Emmanuel Michon
+  @date   2005-03-17
+*/
+
+#ifndef __EMHWLIB_LRAM_H__
+#define __EMHWLIB_LRAM_H__
+
+#if (EM86XX_CHIP<EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_others.h"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_tango3.h"
+#else
+#error EM86XX_CHIP is not set in RMCFLAGS: refer to rmdef/rmem86xxid.h. 
+#endif
+
+#endif // __EMHWLIB_LRAM_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,41 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram.inc (generated from emhwlib_hal/include/emhwlib_lram.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x1800
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_others.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_others.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_others.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_others.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,98 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_others.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_OTHERS_H__
+#define __EMHWLIB_LRAM_OTHERS_H__
+
+#define LR_CPU_IDLELOOP          0x00000000 /* CPU uses 0x80 bytes, up to 0x0080 */
+#define LR_UCLINUX_END           0x00000100
+
+#define LR_VSYNC_STRUCT          0x00000200 /* 2KB of data structures */
+#define LR_VSYNC_CODE            0x00000a00 /* 2KB of code */
+#define LR_VSYNC_END             0x00001200
+
+#define LR_STACKTOP              0x000017F4 /* in case a bootstrap routine needs a stack in local ram. Use this boundary */
+
+#define LR_PCI_INTERRUPT_ENABLE  0x000017F4
+#define LR_HOST_INTERRUPT_STATUS 0x000017F8
+#define LR_CPU_BRU_JUMP          0x000017FC /* `bootrom_ucos jump' (debug purpose) */
+
+#define LR_MU_PROFILE_STATUS     0x00001800
+
+#define LR_DRAM_DMA_SUSPEND               0x00001c8c
+#define LR_SUSPEND_ACK_MPEG0              0x00001c90
+#define LR_SUSPEND_ACK_MPEG1              0x00001c94
+#define LR_SUSPEND_ACK_AUDIO0             0x00001c98
+#define LR_SUSPEND_ACK_AUDIO1             0x00001c9c
+#define LR_SUSPEND_ACK_DEMUX              0x00001ca0
+#define LR_SUSPEND_ACK_IH                 0x00001ca4
+
+#define LR_HB_IH                 0x00001ca8
+
+#define LR_IH_LOG_FIFO           0x00001cac /* in some cases (splash screen) find the location of the log_fifo is not that easy. Read it here. */
+
+#define LR_HB_HOST               0x00001cb0
+#define LR_HB_CPU                0x00001cb4
+#define LR_HB_MPEG0              0x00001cb8
+#define LR_HB_MPEG1              0x00001cbc
+#define LR_HB_AUDIO0             0x00001cc0
+#define LR_HB_AUDIO1             0x00001cc4
+#define LR_HB_DEMUX              0x00001cc8
+#define LR_HB_XPU                0x00001ccc
+
+#define LR_IDMA                  0x00001cd0 /* 16bytes. Obsoletizes LR_HMMAD */
+
+#define LR_ETH_MAC_LO            0x00001ce0 /* Ethernet MAC addr low 4 bytes */
+#define LR_ETH_MAC_HI            0x00001ce4 /* Ethernet MAC addr high bytes */
+#define LR_HB_VSYNC              0x00001ce8
+ 
+#define LR_SW_VAL_VSYNC_COUNT    0x00001cec /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x00001cf0 /* this location is used to store a pixel address to write the frame count */
+
+#define LR_HMMAD                 0x00001cf4
+#define LR_KEY_ZONE              0x00001D00 /* 0x200 bytes, up to 0x1F00 */
+#define LR_YAMON_DIGITS          0x00001F00
+#define LR_XPU_DUMP              0x00001F00 /* 0x80 bytes, up to 0x1F80 */
+
+#define LR_VSYNC_PERIOD          0x00001FA0 /* 0x20 bytes, up to 0x1FC0 */
+
+#define LR_RANDOM_SEED           0x00001FC8 /* 0x08 bytes, up to 0x1FD0 */
+#define LR_LOCAL_DEBUG_PROBE     0x00001FD0 /* 0x20 bytes, up to 0x1FF0 */
+
+#define LR_XENV_LOCATION         0x00001FF0 /* Location of XENV, found by XOS */
+#define LR_GNET_MAC              0x00001FF4
+#define LR_ZBOOT_STAGE           0x00001FF8
+#define LR_XPU_STAGE             0x00001FFC
+
+#endif // __EMHWLIB_LRAM_OTHERS_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_others.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_others.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_others.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_others.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,58 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram_others.inc (generated from emhwlib_hal/include/emhwlib_lram_others.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_CPU_IDLELOOP=0x0
+LR_UCLINUX_END=0x100
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x17f4
+LR_PCI_INTERRUPT_ENABLE=0x17f4
+LR_HOST_INTERRUPT_STATUS=0x17f8
+LR_CPU_BRU_JUMP=0x17fc
+LR_MU_PROFILE_STATUS=0x1800
+LR_DRAM_DMA_SUSPEND=0x1c8c
+LR_SUSPEND_ACK_MPEG0=0x1c90
+LR_SUSPEND_ACK_MPEG1=0x1c94
+LR_SUSPEND_ACK_AUDIO0=0x1c98
+LR_SUSPEND_ACK_AUDIO1=0x1c9c
+LR_SUSPEND_ACK_DEMUX=0x1ca0
+LR_SUSPEND_ACK_IH=0x1ca4
+LR_HB_IH=0x1ca8
+LR_IH_LOG_FIFO=0x1cac
+LR_HB_HOST=0x1cb0
+LR_HB_CPU=0x1cb4
+LR_HB_MPEG0=0x1cb8
+LR_HB_MPEG1=0x1cbc
+LR_HB_AUDIO0=0x1cc0
+LR_HB_AUDIO1=0x1cc4
+LR_HB_DEMUX=0x1cc8
+LR_HB_XPU=0x1ccc
+LR_IDMA=0x1cd0
+LR_ETH_MAC_LO=0x1ce0
+LR_ETH_MAC_HI=0x1ce4
+LR_HB_VSYNC=0x1ce8
+LR_SW_VAL_VSYNC_COUNT=0x1cec
+LR_SW_VAL_PIXEL_ADDR=0x1cf0
+LR_HMMAD=0x1cf4
+LR_KEY_ZONE=0x1d00
+LR_YAMON_DIGITS=0x1f00
+LR_XPU_DUMP=0x1f00
+LR_VSYNC_PERIOD=0x1fa0
+LR_RANDOM_SEED=0x1fc8
+LR_LOCAL_DEBUG_PROBE=0x1fd0
+LR_XENV_LOCATION=0x1ff0
+LR_GNET_MAC=0x1ff4
+LR_ZBOOT_STAGE=0x1ff8
+LR_XPU_STAGE=0x1ffc
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_tango3.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_tango3.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_tango3.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_tango3.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,76 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_tango3.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_TANGO3_H__
+#define __EMHWLIB_LRAM_TANGO3_H__
+
+/* Julien to clarify --- em07may31 */
+#define LR_VSYNC_STRUCT          0x00000200 /* 2KB of data structures */
+#define LR_VSYNC_CODE            0x00000a00 /* 2KB of code */
+#define LR_VSYNC_END             0x00001200
+
+/* as long as the value of this symbol moves only up with time, backward compatibility is ok */
+#define LR_STACKTOP              0x00001800
+
+/*
+  range from LR_STACKTOP to the first of the below block is 
+  reserved for future use (~100 slots)
+ */
+#define LR_PCI_INTERRUPT_ENABLE  0x000019ac
+#define LR_HOST_INTERRUPT_STATUS 0x000019b0
+#define LR_DRAM_DMA_SUSPEND      0x000019b4
+#define LR_SUSPEND_ACK_MPEG0     0x000019b8
+#define LR_SUSPEND_ACK_MPEG1     0x000019bc
+#define LR_SUSPEND_ACK_AUDIO0    0x000019c0
+#define LR_SUSPEND_ACK_AUDIO1    0x000019c4
+#define LR_SUSPEND_ACK_DEMUX     0x000019c8
+#define LR_SUSPEND_ACK_IH        0x000019cc
+#define LR_HB_IH                 0x000019d0
+#define LR_HB_HOST               0x000019d4
+#define LR_HB_CPU                0x000019d8
+#define LR_HB_MPEG0              0x000019dc
+#define LR_HB_MPEG1              0x000019e0
+#define LR_HB_AUDIO0             0x000019e4
+#define LR_HB_AUDIO1             0x000019e8
+#define LR_HB_DEMUX              0x000019ec
+#define LR_HB_XPU                0x000019f0
+#define LR_HB_VSYNC              0x000019f4
+#define LR_SW_VAL_VSYNC_COUNT    0x000019f8 /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x000019fc /* this location is used to store a pixel address to write the frame count */
+
+#define LR_XENV2_RW              0x00001a00 /* up to 768 bytes */
+
+#define LR_XENV2_RO              0x00001d00 /* up to the end, 768 bytes. This area is written by xpu, r.o. for others */
+
+#endif // __EMHWLIB_LRAM_TANGO3_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_tango3.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_tango3.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_lram_tango3.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_lram_tango3.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,41 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram_tango3.inc (generated from emhwlib_hal/include/emhwlib_lram_tango3.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x1800
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_registers_tango2.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_registers_tango2.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_registers_tango2.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_registers_tango2.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,675 @@
+/******************************************************/
+/* This file is generated automatically, DO NOT EDIT! */
+/******************************************************/
+/*
+ * ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h
+ *
+ * Copyright (C) 2001-2007 Sigma Designs, Inc. 
+ * All Rights Reserved. 
+ *
+ */
+ 
+/**
+  @file ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h
+  @brief emhwlib generated file
+   
+  @author Jacques Mahe, Christian Wolff, Julien Soulier, Emmanuel Michon
+  @ingroup hwlproperties
+*/
+
+#ifndef __EMHWLIB_REGISTERS_TANGO2_H__
+#define __EMHWLIB_REGISTERS_TANGO2_H__
+
+/* SystemBlock registers */
+#define REG_BASE_system_block 0x00010000 /* width RMuint32 */
+#define SYS_clkgen0_pll 0x0000 /* width RMuint32 */
+#define SYS_clkgen0_div 0x0004 /* width RMuint32 */
+#define SYS_clkgen1_pll 0x0008 /* width RMuint32 */
+#define SYS_clkgen1_div 0x000C /* width RMuint32 */
+#define SYS_clkgen2_pll 0x0010 /* width RMuint32 */
+#define SYS_clkgen2_div 0x0014 /* width RMuint32 */
+#define SYS_clkgen3_pll 0x0018 /* width RMuint32 */
+#define SYS_clkgen3_div 0x001C /* width RMuint32 */
+#define SYS_avclk_mux 0x0038 /* width RMuint32 */
+#define SYS_sysclk_mux 0x003C /* width RMuint32 */
+#define SYS_clk_cnt 0x0040 /* width RMuint32 */
+#define SYS_xtal_in_cnt 0x0048 /* width RMuint32 */
+#define DRAM_vbus_w0_cfg 0x0300 /* width RMuint32 */
+#define DRAM_vbus_w1_cfg 0x0304 /* width RMuint32 */
+#define DRAM_vbus_w2_cfg 0x0308 /* width RMuint32 */
+#define DRAM_vbus_w3_cfg 0x030c /* width RMuint32 */
+#define DRAM_vbus_r0_cfg 0x0340 /* width RMuint32 */
+#define DRAM_vbus_r1_cfg 0x0344 /* width RMuint32 */
+#define DRAM_vbus_r2_cfg 0x0348 /* width RMuint32 */
+#define DRAM_vbus_r3_cfg 0x034c /* width RMuint32 */
+#define DRAM_vbus_r4_cfg 0x0350 /* width RMuint32 */
+#define DRAM_vbus_r5_cfg 0x0354 /* width RMuint32 */
+#define DRAM_vbus_r6_cfg 0x0358 /* width RMuint32 */
+#define DRAM_vbus_r7_cfg 0x035c /* width RMuint32 */
+#define DRAM_vbus_r8_cfg 0x0360 /* width RMuint32 */
+#define DRAM_vbus_r9_cfg 0x0364 /* width RMuint32 */
+#define DRAM_vbus_r10_cfg 0x0368 /* width RMuint32 */
+#define DRAM_vbus_r11_cfg 0x036c /* width RMuint32 */
+#define DRAM_mbus_w0_cfg 0x0200 /* width RMuint32 */
+#define DRAM_mbus_w1_cfg 0x0204 /* width RMuint32 */
+#define DRAM_mbus_w2_cfg 0x0208 /* width RMuint32 */
+#define DRAM_mbus_w3_cfg 0x020c /* width RMuint32 */
+#define DRAM_mbus_w4_cfg 0x0210 /* width RMuint32 */
+#define DRAM_mbus_w5_cfg 0x0214 /* width RMuint32 */
+#define DRAM_mbus_w6_cfg 0x0218 /* width RMuint32 */
+#define DRAM_mbus_w7_cfg 0x021c /* width RMuint32 */
+#define DRAM_mbus_w8_cfg 0x0220 /* width RMuint32 */
+#define DRAM_mbus_w9_cfg 0x0224 /* width RMuint32 */
+#define DRAM_mbus_w10_cfg 0x0228 /* width RMuint32 */
+#define DRAM_mbus_r0_cfg 0x0240 /* width RMuint32 */
+#define DRAM_mbus_r1_cfg 0x0244 /* width RMuint32 */
+#define DRAM_mbus_r2_cfg 0x0248 /* width RMuint32 */
+#define DRAM_mbus_r3_cfg 0x024c /* width RMuint32 */
+#define DRAM_mbus_r4_cfg 0x0250 /* width RMuint32 */
+#define DRAM_mbus_r5_cfg 0x0254 /* width RMuint32 */
+#define DRAM_mbus_r6_cfg 0x0258 /* width RMuint32 */
+#define DRAM_mbus_r7_cfg 0x025c /* width RMuint32 */
+#define DRAM_mbus_r8_cfg 0x0260 /* width RMuint32 */
+#define DRAM_mbus_r9_cfg 0x0264 /* width RMuint32 */
+#define DRAM_mbus_r10_cfg 0x0268 /* width RMuint32 */
+#define SYS_hostclk_mux 0x0030 /* width RMuint32 */
+#define SYS_sysclk_premux 0x0034 /* width RMuint32 */
+#define SYS_rnd_cnt 0x0044 /* width RMuint32 */
+#define SYS_cnt_cfg 0x004c /* width RMuint32 */
+#define SYS_cfg_cnt0 0x0050 /* width RMuint32 */
+#define SYS_cfg_cnt1 0x0054 /* width RMuint32 */
+#define SYS_cfg_cnt2 0x0058 /* width RMuint32 */
+#define SYS_cfg_cnt3 0x005c /* width RMuint32 */
+#define SYS_cfg_cnt4 0x0060 /* width RMuint32 */
+#define SYS_cleandiv0_div 0x0080 /* width RMuint32 */
+#define SYS_cleandiv1_div 0x0088 /* width RMuint32 */
+#define SYS_cleandiv2_div 0x0090 /* width RMuint32 */
+#define SYS_cleandiv3_div 0x0098 /* width RMuint32 */
+#define SYS_cleandiv4_div 0x00a0 /* width RMuint32 */
+#define SYS_cleandiv5_div 0x00a8 /* width RMuint32 */
+#define SYS_cleandiv6_div 0x00b0 /* width RMuint32 */
+#define SYS_cleandiv7_div 0x00b8 /* width RMuint32 */
+#define SYS_cleandiv8_div 0x00c0 /* width RMuint32 */
+#define SYS_cleandiv9_div 0x00c8 /* width RMuint32 */
+#define SYS_cleandiv10_div 0x00d0 /* width RMuint32 */
+#define MARB_mid01_cfg 0x0200 /* width RMuint32 */
+#define MARB_mid21_cfg 0x0204 /* width RMuint32 */
+#define MARB_mid02_cfg 0x0208 /* width RMuint32 */
+#define MARB_mid22_cfg 0x020c /* width RMuint32 */
+#define MARB_mid04_cfg 0x0210 /* width RMuint32 */
+#define MARB_mid24_cfg 0x0214 /* width RMuint32 */
+#define MARB_mid25_cfg 0x0218 /* width RMuint32 */
+#define MARB_mid08_cfg 0x021c /* width RMuint32 */
+#define MARB_mid28_cfg 0x0220 /* width RMuint32 */
+#define MARB_mid29_cfg 0x0224 /* width RMuint32 */
+#define MARB_mid0C_cfg 0x0228 /* width RMuint32 */
+#define MARB_mid2C_cfg 0x022c /* width RMuint32 */
+#define MARB_mid10_cfg 0x0230 /* width RMuint32 */
+#define MARB_mid30_cfg 0x0234 /* width RMuint32 */
+#define MARB_mid31_cfg 0x0238 /* width RMuint32 */
+#define MARB_mid12_cfg 0x023c /* width RMuint32 */
+#define MARB_mid32_cfg 0x0240 /* width RMuint32 */
+#define VARB_mid01_cfg 0x0300 /* width RMuint32 */
+#define VARB_mid02_cfg 0x0304 /* width RMuint32 */
+#define VARB_mid21_cfg 0x0308 /* width RMuint32 */
+#define VARB_mid22_cfg 0x030c /* width RMuint32 */
+#define VARB_mid23_cfg 0x0310 /* width RMuint32 */
+#define VARB_mid24_cfg 0x0314 /* width RMuint32 */
+#define VARB_mid25_cfg 0x0318 /* width RMuint32 */
+#define VARB_mid26_cfg 0x031c /* width RMuint32 */
+#define VARB_mid27_cfg 0x0320 /* width RMuint32 */
+#define VARB_mid28_cfg 0x0324 /* width RMuint32 */
+#define VARB_mid29_cfg 0x0328 /* width RMuint32 */
+#define VARB_mid2A_cfg 0x032c /* width RMuint32 */
+#define VARB_mid10_cfg 0x0330 /* width RMuint32 */
+#define VARB_mid30_cfg 0x0334 /* width RMuint32 */
+#define VARB_mid31_cfg 0x0338 /* width RMuint32 */
+#define VARB_mid03_cfg 0x033c /* width RMuint32 */
+#define IARB_mid01_cfg 0x0400 /* width RMuint32 */
+#define IARB_mid02_cfg 0x0404 /* width RMuint32 */
+#define SYS_gpio_dir 0x0500 /* width RMuint32 */
+#define SYS_gpio_data 0x0504 /* width RMuint32 */
+#define SYS_gpio_int 0x0508 /* width RMuint32 */
+#define SYS_gpio15_pwm 0x0510 /* width RMuint32 */
+#define SYS_gpio14_pwm 0x0514 /* width RMuint32 */
+#define REG_BASE_dram_controller_0 0x00030000 /* width RMuint32 */
+#define REG_BASE_dram_controller_1 0x00040000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0_alias 0x10000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0 0x10000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1_alias 0x20000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1 0x20000000 /* width RMuint32 */
+#define DRAM_dunit_cfg 0x0000 /* width RMuint32 */
+#define DRAM_dunit_delay0_ctrl 0x0004 /* width RMuint32 */
+#define DRAM_dunit_delay1_ctrl 0x0008 /* width RMuint32 */
+#define DRAM_dunit_auto_delay 0x000c /* width RMuint32 */
+#define DRAM_dunit_fall_delay0 0x0010 /* width RMuint32 */
+#define DRAM_dunit_fall_delay1 0x0014 /* width RMuint32 */
+#define DRAM_dunit_bw_lobound 0x0018 /* width RMuint32 */
+#define DRAM_dunit_bw_hibound 0x001c /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cfg 0x0020 /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cnt 0x0024 /* width RMuint32 */
+#define DRAM_dunit_bw_cntall 0x0028 /* width RMuint32 */
+#define DRAM_dunit_calibration_delay 0x0030 /* width RMuint32 */
+#define DRAM_dunit_calibration_rise_err 0x0034 /* width RMuint32 */
+#define DRAM_dunit_calibration_fall_err 0x0038 /* width RMuint32 */
+#define DRAM_dunit_calibration_page 0x0088 /* width RMuint32 */
+#define DRAM_dunit_flush_buffer 0x0104 /* width RMuint32 */
+#define REG_BASE_host_interface 0x00020000 /* width RMuint32 */
+#define MEM_BASE_host_interface 0x40000000 /* width RMuint32 */
+#define IDE_data 0x0000 /* width RMuint32 */
+#define IDE_error 0x0004 /* width RMuint32 */
+#define IDE_count 0x0008 /* width RMuint32 */
+#define IDE_start_sector 0x000c /* width RMuint32 */
+#define IDE_cylinder_lo 0x0010 /* width RMuint32 */
+#define IDE_cylinder_hi 0x0014 /* width RMuint32 */
+#define IDE_head_device 0x0018 /* width RMuint32 */
+#define IDE_cmd_stat 0x001c /* width RMuint32 */
+#define IDE_irq_stat 0x0218 /* width RMuint32 */
+#define IDE_cmd_stat__ 0x021c /* width RMuint32 */
+#define PB_timing0 0x0800 /* width RMuint32 */
+#define PB_timing1 0x0804 /* width RMuint32 */
+#define PB_timing2 0x0808 /* width RMuint32 */
+#define PB_timing3 0x080c /* width RMuint32 */
+#define PB_timing4 0x0810 /* width RMuint32 */
+#define PB_timing5 0x0814 /* width RMuint32 */
+#define PB_default_timing 0x0818 /* width RMuint32 */
+#define PB_use_timing0 0x081c /* width RMuint32 */
+#define PB_use_timing1 0x0820 /* width RMuint32 */
+#define PB_use_timing2 0x0824 /* width RMuint32 */
+#define PB_use_timing3 0x0828 /* width RMuint32 */
+#define PB_use_timing4 0x082c /* width RMuint32 */
+#define PB_use_timing5 0x0830 /* width RMuint32 */
+#define PB_CS_config 0x0834 /* width RMuint32 */
+#define PB_automode_start_address 0x0840 /* width RMuint32 */
+#define PB_automode_control 0x0844 /* width RMuint32 */
+#define EMHWLIB_IS_HOST 0xe000 /* width RMuint32 */
+#define HOST_REG1 0xfed0 /* width RMuint32 */
+#define HOST_REG2 0xfed4 /* width RMuint32 */
+#define READ_ADDRESS 0xfec0 /* width RMuint32 */
+#define READ_COUNTER 0xfec4 /* width RMuint32 */
+#define READ_ENABLE 0xfec8 /* width RMuint32 */
+#define REV_ORDER 0xfecc /* width RMuint32 */
+#define WRITE_ADDRESS 0xfed8 /* width RMuint32 */
+#define WRITE_COUNTER 0xfedc /* width RMuint32 */
+#define WRITE_ENABLE 0xfee0 /* width RMuint32 */
+#define BURST 0xfee4 /* width RMuint32 */
+#define PCI_TIMEOUT 0x8000 /* width RMuint32 */
+#define PCI_TIMEOUT_STATUS 0x8004 /* width RMuint32 */
+#define PCI_TIMER 0x8008 /* width RMuint32 */
+#define PCI_TIMER_TEST 0x800c /* width RMuint32 */
+#define PCI_WAKEUP 0x8010 /* width RMuint32 */
+#define PCI_REGION_0_BASE 0x9000 /* width RMuint32 */
+#define PCI_REGION_1_BASE 0x9004 /* width RMuint32 */
+#define PCI_REGION_2_BASE 0x9008 /* width RMuint32 */
+#define PCI_REGION_3_BASE 0x900c /* width RMuint32 */
+#define PCI_REGION_4_BASE 0x9010 /* width RMuint32 */
+#define PCI_REGION_5_BASE 0x9014 /* width RMuint32 */
+#define PCI_REGION_6_BASE 0x9018 /* width RMuint32 */
+#define PCI_REGION_7_BASE 0x901c /* width RMuint32 */
+#define PCI_irq_status 0x9020 /* width RMuint32 */
+#define PCI_irq_set 0x9024 /* width RMuint32 */
+#define PCI_irq_clear 0x9028 /* width RMuint32 */
+#define SBOX_FIFO_RESET 0x90a0 /* width RMuint32 */
+#define SBOX_ROUTE 0x90a8 /* width RMuint32 */
+#define output_SBOX_MBUS_W0 0x9080 /* width RMuint32 */
+#define output_SBOX_MBUS_W1 0x9084 /* width RMuint32 */
+#define output_SBOX_PCI_MASTER 0x9088 /* width RMuint32 */
+#define output_SBOX_PCI_SLAVE 0x908c /* width RMuint32 */
+#define output_SBOX_CIPHER 0x9090 /* width RMuint32 */
+#define output_SBOX_IDE_ISA 0x9094 /* width RMuint32 */
+#define output_SBOX_IDE_DVD 0x9098 /* width RMuint32 */
+#define input_keep_SBOX 0 /* width RMuint32 */
+#define input_MBUS_R0_SBOX 1 /* width RMuint32 */
+#define input_MBUS_R1_SBOX 2 /* width RMuint32 */
+#define input_PCI_MASTER_SBOX 3 /* width RMuint32 */
+#define input_PCI_SLAVE_SBOX 4 /* width RMuint32 */
+#define input_CIPHER_SBOX 5 /* width RMuint32 */
+#define input_IDE_DVD_SBOX 6 /* width RMuint32 */
+#define input_IDE_ISA_SBOX 7 /* width RMuint32 */
+#define input_SFLA_SBOX 8 /* width RMuint32 */
+#define input_unconnected_SBOX 0xf /* width RMuint32 */
+#define host_mutex0 0x9040 /* width RMuint32 */
+#define host_mutex1 0x9044 /* width RMuint32 */
+#define host_mutex2 0x9048 /* width RMuint32 */
+#define host_mutex3 0x904c /* width RMuint32 */
+#define host_mutex4 0x9050 /* width RMuint32 */
+#define host_mutex5 0x9054 /* width RMuint32 */
+#define host_mutex6 0x9058 /* width RMuint32 */
+#define host_mutex7 0x905c /* width RMuint32 */
+#define host_mutex8 0x9060 /* width RMuint32 */
+#define host_mutex9 0x9064 /* width RMuint32 */
+#define host_mutex10 0x9068 /* width RMuint32 */
+#define host_mutex11 0x906c /* width RMuint32 */
+#define host_mutex12 0x9070 /* width RMuint32 */
+#define host_mutex13 0x9074 /* width RMuint32 */
+#define host_mutex14 0x9078 /* width RMuint32 */
+#define host_mutex15 0x907c /* width RMuint32 */
+#define PCI_host_reg5 0xfe94 /* width RMuint32 */
+#define PCI_chip_is_host 0xfe90 /* width RMuint32 */
+#define IDECTRL_idesrc 0x20d0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim1 0x20e0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim2 0x20f0 /* width RMuint32 */
+#define IDECTRL_pri_idectl 0x2100 /* width RMuint32 */
+#define IDECTRL_pri_drv0tim 0x2110 /* width RMuint32 */
+#define IDECTRL_pri_drv1tim 0x2120 /* width RMuint32 */
+#define IDECTRL_idemisc 0x2130 /* width RMuint32 */
+#define IDECTRL_idestatus 0x2140 /* width RMuint32 */
+#define IDECTRL_udmactl 0x2150 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim1 0x2160 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim2 0x2170 /* width RMuint32 */
+#define IDECTRL_pref_st 0x2310 /* width RMuint32 */
+#define IDECTRL_pri_ctrlblock 0x2398 /* width RMuint32 */
+#define IDECTRL_pri_cmdblock 0x23c0 /* width RMuint32 */
+#define IDECTRL_bmic 0x2400 /* width RMuint32 */
+#define IDECTRL_bmis 0x2410 /* width RMuint32 */
+#define IDECTRL_bmidtp 0x2420 /* width RMuint32 */
+#define IDECTRL_ide_dmaptr 0x2780 /* width RMuint32 */
+#define IDECTRL_ide_dmalen 0x2790 /* width RMuint32 */
+#define IDECTRL_pio_prefetch_data 0x27c0 /* width RMuint32 */
+#define MEM_BASE_pfla 0x40000000 /* width RMuint32 */
+#define PB_CS0_OFFSET 0x00000000 /* width RMuint32 */
+#define PB_CS1_OFFSET 0x04000000 /* width RMuint32 */
+#define PB_CS2_OFFSET 0x08000000 /* width RMuint32 */
+#define PB_CS3_OFFSET 0x0c000000 /* width RMuint32 */
+#define ETH_gpio_dir1 0x7100 /* width RMuint32 */
+#define ETH_gpio_data1 0x7104 /* width RMuint32 */
+#define ETH_gpio_mask1 0x7108 /* width RMuint32 */
+#define ETH_gpio_dir2 0x710c /* width RMuint32 */
+#define ETH_gpio_data2 0x7110 /* width RMuint32 */
+#define PCI_host_reg1 0xfed0 /* width RMuint32 */
+#define PCI_host_reg2 0xfed4 /* width RMuint32 */
+#define PCI_host_reg3 0xfe80 /* width RMuint32 */
+#define PCI_host_reg4 0xfe84 /* width RMuint32 */
+#define PCI_pcictrl_reg1 0xfe88 /* width RMuint32 */
+#define PCI_pcictrl_reg2 0xfe8c /* width RMuint32 */
+#define PCI_pcictrl_reg3 0xfefc /* width RMuint32 */
+#define PCI_REG0 0xfee8 /* width RMuint32 */
+#define PCI_REG1 0xfeec /* width RMuint32 */
+#define PCI_REG2 0xfef0 /* width RMuint32 */
+#define PCI_REG3 0xfef4 /* width RMuint32 */
+#define PCI_CONFIG 0xfef8 /* width RMuint32 */
+#define MIF_W0_ADD 0xb000 /* width RMuint32 */
+#define MIF_W0_CNT 0xb004 /* width RMuint32 */
+#define MIF_W0_SKIP 0xb008 /* width RMuint32 */
+#define MIF_W0_CMD 0xb00c /* width RMuint32 */
+#define MIF_W1_ADD 0xb040 /* width RMuint32 */
+#define MIF_W1_CNT 0xb044 /* width RMuint32 */
+#define MIF_W1_SKIP 0xb048 /* width RMuint32 */
+#define MIF_W1_CMD 0xb04c /* width RMuint32 */
+#define MIF_R0_ADD 0xb080 /* width RMuint32 */
+#define MIF_R0_CNT 0xb084 /* width RMuint32 */
+#define MIF_R0_SKIP 0xb088 /* width RMuint32 */
+#define MIF_R0_CMD 0xb08c /* width RMuint32 */
+#define MIF_R1_ADD 0xb0c0 /* width RMuint32 */
+#define MIF_R1_CNT 0xb0c4 /* width RMuint32 */
+#define MIF_R1_SKIP 0xb0c8 /* width RMuint32 */
+#define MIF_R1_CMD 0xb0cc /* width RMuint32 */
+#define MBUS_IDLE 0 /* width RMuint32 */
+#define MBUS_LINEAR 1 /* width RMuint32 */
+#define MBUS_DOUBLE 2 /* width RMuint32 */
+#define MBUS_RECTANGLE 3 /* width RMuint32 */
+#define MBUS_VOID 4 /* width RMuint32 */
+#define MBUS_LINEAR_VOID 5 /* width RMuint32 */
+#define MBUS_DOUBLE_VOID 6 /* width RMuint32 */
+#define MBUS_RECTANGLE_VOID 7 /* width RMuint32 */
+#define MBUS_TILED 8 /* width RMuint32 */
+#define GBUS_MUTEX_XPU 0x14 /* width RMuint32 */
+#define GBUS_MUTEX_PT110 0x16 /* width RMuint32 */
+#define GBUS_MUTEX_TDMX 0x19 /* width RMuint32 */
+#define GBUS_MUTEX_AUDIO_0 0x1b /* width RMuint32 */
+#define GBUS_MUTEX_AUDIO_1 0x1c /* width RMuint32 */
+#define GBUS_MUTEX_MPEG_0 0x1d /* width RMuint32 */
+#define GBUS_MUTEX_MPEG_1 0x1e /* width RMuint32 */
+#define GBUS_MUTEX_HOST 0x1f /* width RMuint32 */
+#define GBUS_MUTEX_LOCAL 0x10 /* width RMuint32 */
+/* SystemBlock registers done */
+
+/* CPUBlock registers */
+#define REG_BASE_cpu_block 0x00060000 /* width RMuint32 */
+#define CPU_time0_load 0xc500 /* width RMuint32 */
+#define CPU_time0_value 0xc504 /* width RMuint32 */
+#define CPU_time0_ctrl 0xc508 /* width RMuint32 */
+#define CPU_time0_clr 0xc50c /* width RMuint32 */
+#define CPU_time1_load 0xc600 /* width RMuint32 */
+#define CPU_time1_value 0xc604 /* width RMuint32 */
+#define CPU_time1_ctrl 0xc608 /* width RMuint32 */
+#define CPU_time1_clr 0xc60c /* width RMuint32 */
+#define CPU_rtc_data 0xc800 /* width RMuint32 */
+#define CPU_rtc_match 0xc804 /* width RMuint32 */
+#define CPU_rtc_stat 0xc808 /* width RMuint32 */
+#define CPU_rtc_load 0xc80c /* width RMuint32 */
+#define CPU_rtc_ctrl 0xc810 /* width RMuint32 */
+#define CPU_irq_status 0xe000 /* width RMuint32 */
+#define CPU_irq_rawstat 0xe004 /* width RMuint32 */
+#define CPU_irq_enableset 0xe008 /* width RMuint32 */
+#define CPU_irq_enableclr 0xe00c /* width RMuint32 */
+#define CPU_irq_softset 0xe010 /* width RMuint32 */
+#define CPU_irq_softclr 0xe014 /* width RMuint32 */
+#define CPU_fiq_status 0xe100 /* width RMuint32 */
+#define CPU_fiq_rawstat 0xe104 /* width RMuint32 */
+#define CPU_fiq_enableset 0xe108 /* width RMuint32 */
+#define CPU_fiq_enableclr 0xe10c /* width RMuint32 */
+#define CPU_fiq_softset 0xe110 /* width RMuint32 */
+#define CPU_fiq_softclr 0xe114 /* width RMuint32 */
+#define CPU_edge_status 0xe200 /* width RMuint32 */
+#define CPU_edge_rawstat 0xe204 /* width RMuint32 */
+#define CPU_edge_config_rise 0xe208 /* width RMuint32 */
+#define CPU_edge_config_fall 0xe20c /* width RMuint32 */
+#define CPU_SOFT_INT 0x00000001 /* width RMuint32 */
+#define CPU_UART0_INT 0x00000002 /* width RMuint32 */
+#define CPU_UART1_INT 0x00000004 /* width RMuint32 */
+#define CPU_TIMER0_INT 0x00000020 /* width RMuint32 */
+#define CPU_TIMER1_INT 0x00000040 /* width RMuint32 */
+#define CPU_HOST_MBUS_W0_INT 0x00000200 /* width RMuint32 */
+#define CPU_HOST_MBUS_W1_INT 0x00000400 /* width RMuint32 */
+#define CPU_HOST_MBUS_R0_INT 0x00000800 /* width RMuint32 */
+#define CPU_HOST_MBUS_R1_INT 0x00001000 /* width RMuint32 */
+#define CPU_PCI_INTA 0x00002000 /* width RMuint32 */
+#define CPU_PCI_INTB 0x00004000 /* width RMuint32 */
+#define CPU_PCI_INTC 0x00008000 /* width RMuint32 */
+#define CPU_PCI_INTD 0x00010000 /* width RMuint32 */
+#define CPU_PCI_FAULT_INT 0x00100000 /* width RMuint32 */
+#define CPU_INFRARED_INT 0x00200000 /* width RMuint32 */
+#define CPU_SFLA_INT 0x00000010 /* width RMuint32 */
+#define CPU_DVD_INT 0x00000080 /* width RMuint32 */
+#define CPU_ETH_INT 0x00000100 /* width RMuint32 */
+#define CPU_DMAIDE_INT 0x00020000 /* width RMuint32 */
+#define CPU_IDE_INT 0x00040000 /* width RMuint32 */
+#define CPU_FRONTPANEL_INT 0x00080000 /* width RMuint32 */
+#define CPU_I2C_INT 0x00400000 /* width RMuint32 */
+#define CPU_GFX_ACCEL_INT 0x00800000 /* width RMuint32 */
+#define CPU_VSYNC0_INT 0x01000000 /* width RMuint32 */
+#define CPU_VSYNC1_INT 0x02000000 /* width RMuint32 */
+#define CPU_VSYNC2_INT 0x04000000 /* width RMuint32 */
+#define CPU_VSYNC3_INT 0x08000000 /* width RMuint32 */
+#define CPU_VSYNC4_INT 0x10000000 /* width RMuint32 */
+#define CPU_VSYNC4BKEND_INT 0x20000000 /* width RMuint32 */
+#define CPU_VSYNC5_INT 0x40000000 /* width RMuint32 */
+#define CPU_VSYNC5BKEND_INT 0x80000000 /* width RMuint32 */
+#define CPU_SMARTCARD_HI_INT 0x00000001 /* width RMuint32 */
+#define CPU_HDMI_HI_INT 0x00000002 /* width RMuint32 */
+#define CPU_HDMI_I2C_HI_INT 0x00000004 /* width RMuint32 */
+#define CPU_VBUS_W0_HI_INT 0x00000008 /* width RMuint32 */
+#define CPU_VBUS_W3_HI_INT 0x00000010 /* width RMuint32 */
+#define CPU_ETH_PHY_HI_INT 0x00000020 /* width RMuint32 */
+#define CPU_ETH_MAC_HI_INT 0x00000040 /* width RMuint32 */
+#define CPU_USB_OHCI_MAC_HI_INT 0x00000080 /* width RMuint32 */
+#define CPU_USB_EHCI_MAC_HI_INT 0x00000100 /* width RMuint32 */
+#define LOG2_CPU_SOFT_INT 0 /* width RMuint32 */
+#define LOG2_CPU_UART0_INT 1 /* width RMuint32 */
+#define LOG2_CPU_UART1_INT 2 /* width RMuint32 */
+#define LOG2_CPU_TIMER0_INT 5 /* width RMuint32 */
+#define LOG2_CPU_TIMER1_INT 6 /* width RMuint32 */
+#define LOG2_CPU_DVD_INT 7 /* width RMuint32 */
+#define LOG2_CPU_RTC_INT 8 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W0_INT 9 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W1_INT 10 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R0_INT 11 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R1_INT 12 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTA 13 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTB 14 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTC 15 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTD 16 /* width RMuint32 */
+#define LOG2_CPU_DMAIDE_INT 17 /* width RMuint32 */
+#define LOG2_CPU_IDE_INT 18 /* width RMuint32 */
+#define LOG2_CPU_FRONTPANEL_INT 19 /* width RMuint32 */
+#define LOG2_CPU_PCI_FAULT_INT 20 /* width RMuint32 */
+#define LOG2_CPU_INFRARED_INT 21 /* width RMuint32 */
+#define LOG2_CPU_I2C_INT 22 /* width RMuint32 */
+#define LOG2_CPU_GFX_ACCEL_INT 23 /* width RMuint32 */
+#define LOG2_CPU_VSYNC0_INT 24 /* width RMuint32 */
+#define LOG2_CPU_VSYNC1_INT 25 /* width RMuint32 */
+#define LOG2_CPU_VSYNC2_INT 26 /* width RMuint32 */
+#define LOG2_CPU_VSYNC3_INT 27 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4_INT 28 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4BKEND_INT 29 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5_INT 30 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5BKEND_INT 31 /* width RMuint32 */
+#define LOG2_CPU_SMARTCARD_INT 32 /* width RMuint32 */
+#define LOG2_CPU_HDMI_INT 33 /* width RMuint32 */
+#define LOG2_CPU_HDMI_I2C_INT 34 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W0_INT 35 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W3_INT 36 /* width RMuint32 */
+#define LOG2_CPU_ETH_PHY_INT 37 /* width RMuint32 */
+#define LOG2_CPU_ETH_MAC_INT 38 /* width RMuint32 */
+#define LOG2_CPU_USB_OHCI_INT 39 /* width RMuint32 */
+#define LOG2_CPU_USB_EHCI_INT 40 /* width RMuint32 */
+#define CPU_edge_status_hi 0xe220 /* width RMuint32 */
+#define CPU_edge_rawstat_hi 0xe224 /* width RMuint32 */
+#define CPU_edge_config_rise_hi 0xe228 /* width RMuint32 */
+#define CPU_edge_config_fall_hi 0xe22c /* width RMuint32 */
+#define CPU_irq_status_hi 0xe018 /* width RMuint32 */
+#define CPU_irq_rawstat_hi 0xe01c /* width RMuint32 */
+#define CPU_irq_enableset_hi 0xe020 /* width RMuint32 */
+#define CPU_irq_enableclr_hi 0xe024 /* width RMuint32 */
+#define CPU_fiq_status_hi 0xe118 /* width RMuint32 */
+#define CPU_fiq_rawstat_hi 0xe11c /* width RMuint32 */
+#define CPU_fiq_enableset_hi 0xe120 /* width RMuint32 */
+#define CPU_fiq_enableclr_hi 0xe124 /* width RMuint32 */
+#define CPU_iiq_status 0xe300 /* width RMuint32 */
+#define CPU_iiq_rawstat 0xe304 /* width RMuint32 */
+#define CPU_iiq_enableset 0xe308 /* width RMuint32 */
+#define CPU_iiq_enableclr 0xe30c /* width RMuint32 */
+#define CPU_iiq_softset 0xe310 /* width RMuint32 */
+#define CPU_iiq_softclr 0xe314 /* width RMuint32 */
+#define CPU_iiq_status_hi 0xe318 /* width RMuint32 */
+#define CPU_iiq_rawstat_hi 0xe31c /* width RMuint32 */
+#define CPU_iiq_enableset_hi 0xe320 /* width RMuint32 */
+#define CPU_iiq_enableclr_hi 0xe324 /* width RMuint32 */
+#define CPU_UART_GPIOMODE 0x38 /* width RMuint32 */
+#define CPU_UART_GPIODIR 0x30 /* width RMuint32 */
+#define CPU_UART_GPIODATA 0x34 /* width RMuint32 */
+#define CPU_edge_config_rise_set 0xe210 /* width RMuint32 */
+#define CPU_edge_config_rise_clr 0xe214 /* width RMuint32 */
+#define CPU_edge_config_fall_set 0xe218 /* width RMuint32 */
+#define CPU_edge_config_fall_clr 0xe21c /* width RMuint32 */
+#define CPU_edge_config_rise_set_hi 0xe230 /* width RMuint32 */
+#define CPU_edge_config_rise_clr_hi 0xe234 /* width RMuint32 */
+#define CPU_edge_config_fall_set_hi 0xe238 /* width RMuint32 */
+#define CPU_edge_config_fall_clr_hi 0xe23c /* width RMuint32 */
+#define CPU_pm_select_0 0xc900 /* width RMuint32 */
+#define CPU_pm_counter_0 0xc904 /* width RMuint32 */
+#define CPU_pm_select_1 0xc908 /* width RMuint32 */
+#define CPU_pm_counter_1 0xc90c /* width RMuint32 */
+#define CPU_remap 0xf000 /* width RMuint32 */
+#define CPU_remap1 0xf004 /* width RMuint32 */
+#define CPU_remap2 0xf008 /* width RMuint32 */
+#define CPU_remap3 0xf00c /* width RMuint32 */
+#define CPU_remap4 0xf010 /* width RMuint32 */
+#define CPU_remap_address 0x1fc00000 /* width RMuint32 */
+#define CPU_remap1_address 0 /* width RMuint32 */
+#define CPU_remap2_address 0x04000000 /* width RMuint32 */
+#define CPU_remap3_address 0x08000000 /* width RMuint32 */
+#define CPU_remap4_address 0x0c000000 /* width RMuint32 */
+#define REG_BASE_irq_handler_block 0xe0000 /* width RMuint32 */
+#define G2L_BIST_BUSY 0xffe0 /* width RMuint32 */
+#define G2L_BIST_PASS 0xffe4 /* width RMuint32 */
+#define G2L_BIST_MASK 0xffe8 /* width RMuint32 */
+#define G2L_RESET_CONTROL 0xfffc /* width RMuint32 */
+#define CPU_UART0_base 0xc100 /* width RMuint32 */
+#define CPU_UART1_base 0xc200 /* width RMuint32 */
+#define CPU_UART_RBR 0x00 /* width RMuint32 */
+#define CPU_UART_THR 0x04 /* width RMuint32 */
+#define CPU_UART_IER 0x08 /* width RMuint32 */
+#define CPU_UART_IIR 0x0c /* width RMuint32 */
+#define CPU_UART_FCR 0x10 /* width RMuint32 */
+#define CPU_UART_LCR 0x14 /* width RMuint32 */
+#define CPU_UART_MCR 0x18 /* width RMuint32 */
+#define CPU_UART_LSR 0x1c /* width RMuint32 */
+#define CPU_UART_MSR 0x20 /* width RMuint32 */
+#define CPU_UART_SCR 0x24 /* width RMuint32 */
+#define CPU_UART_CLKDIV 0x28 /* width RMuint32 */
+#define CPU_UART_CLKSEL 0x2c /* width RMuint32 */
+/* CPUBlock registers done */
+
+/* XPUBlock registers */
+#define REG_BASE_xpu_block 0x000e0000 /* width RMuint32 */
+/* XPUBlock registers done */
+
+/* IPUBlock registers */
+#define REG_BASE_ipu_block 0x000f0000 /* width RMuint32 */
+/* IPUBlock registers done */
+
+/* DisplayBlock registers */
+#define REG_BASE_display_block 0x00070000 /* width RMuint32 */
+#define PMEM_BASE_display_block 0x00300000 /* width RMuint32 */
+#define VBUS_IDLE 0x0 /* width RMuint32 */
+#define VBUS_LINEAR 0x1 /* width RMuint32 */
+#define VBUS_DOUBLE 0x2 /* width RMuint32 */
+#define VBUS_RECTANGLE 0x3 /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD 0x4 /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE 0x5 /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN 0x6 /* width RMuint32 */
+#define VBUS_VOID 0x8 /* width RMuint32 */
+#define VBUS_LINEAR_VOID 0x9 /* width RMuint32 */
+#define VBUS_DOUBLE_VOID 0xa /* width RMuint32 */
+#define VBUS_RECTANGLE_VOID 0xb /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD_VOID 0xc /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE_VOID 0xd /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN_VOID 0xe /* width RMuint32 */
+/* DisplayBlock registers done */
+
+/* DemuxEngine registers */
+#define REG_BASE_demux_engine 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_0 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_0 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_1 0x000b0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_1 0x00170000 /* width RMuint32 */
+#define TDMX_gpio_data 0x2e0c /* width RMuint32 */
+#define TDMX_gpio_dir 0x2e0d /* width RMuint32 */
+/* DemuxEngine registers done */
+
+/* MpegEngine registers */
+#define REG_BASE_mpeg_engine_0 0x00080000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_0 0x00110000 /* width RMuint32 */
+#define REG_BASE_mpeg_engine_1 0x00090000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_1 0x00130000 /* width RMuint32 */
+#define RBUS_offset 0x4000 /* width RMuint32 */
+/* MpegEngine registers done */
+
+/* AudioEngine registers */
+#define REG_BASE_audio_engine_0 0x000c0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_0 0x00190000 /* width RMuint32 */
+#define REG_BASE_audio_engine_1 0x000d0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_1 0x001b0000 /* width RMuint32 */
+#define audio_mutex0 0x3e90 /* width RMuint32 */
+#define audio_mutex1 0x3e91 /* width RMuint32 */
+#define audio_mutex2 0x3e92 /* width RMuint32 */
+#define audio_mutex3 0x3e93 /* width RMuint32 */
+#define audio_mutex4 0x3e94 /* width RMuint32 */
+#define audio_mutex5 0x3e95 /* width RMuint32 */
+#define audio_mutex6 0x3e96 /* width RMuint32 */
+#define audio_mutex7 0x3e97 /* width RMuint32 */
+/* AudioEngine registers done */
+
+/* AudioDecoder registers */
+/* AudioDecoder registers done */
+
+/* AudioCapture registers */
+/* AudioCapture registers done */
+
+/* VoipCodec registers */
+/* VoipCodec registers done */
+
+/* CRCDecoder registers */
+/* CRCDecoder registers done */
+
+/* XCRCDecoder registers */
+/* XCRCDecoder registers done */
+
+/* StreamCapture registers */
+/* StreamCapture registers done */
+
+/* RawDataTransfer registers */
+/* RawDataTransfer registers done */
+
+/* I2C registers */
+#define I2C_MASTER_CONFIG 0x80 /* width RMuint32 */
+#define I2C_MASTER_CLK_DIV 0x84 /* width RMuint32 */
+#define I2C_MASTER_DEV_ADDR 0x88 /* width RMuint32 */
+#define I2C_MASTER_ADDR 0x8c /* width RMuint32 */
+#define I2C_MASTER_DATA_OUT 0x90 /* width RMuint32 */
+#define I2C_MASTER_DATA_IN 0x94 /* width RMuint32 */
+#define I2C_MASTER_STATUS 0x98 /* width RMuint32 */
+#define I2C_MASTER_STARTXFER 0x9c /* width RMuint32 */
+#define I2C_MASTER_BYTE_CNT 0xa0 /* width RMuint32 */
+#define I2C_MASTER_INTEN 0xa4 /* width RMuint32 */
+#define I2C_MASTER_INT 0xa8 /* width RMuint32 */
+#define I2C_SLAVE_ADDR_REG 0xC0 /* width RMuint32 */
+#define I2C_SLAVE_DATAOUT 0xC4 /* width RMuint32 */
+#define I2C_SLAVE_DATAIN 0xC8 /* width RMuint32 */
+#define I2C_SLAVE_STATUS 0xCC /* width RMuint32 */
+#define I2C_SLAVE_INTEN 0xD0 /* width RMuint32 */
+#define I2C_SLAVE_INT 0xD4 /* width RMuint32 */
+#define I2C_SLAVE_BUS_HOLD 0xD8 /* width RMuint32 */
+/* I2C registers done */
+
+/* MM registers */
+/* MM registers done */
+
+/* SpuDecoder registers */
+/* SpuDecoder registers done */
+
+/* PictureTransform registers */
+/* PictureTransform registers done */
+
+/* ClosedCaptionDecoder registers */
+/* ClosedCaptionDecoder registers done */
+
+/* RTC registers */
+/* RTC registers done */
+
+/* Cipher registers */
+/* Cipher registers done */
+
+/* STC registers */
+/* STC registers done */
+
+/* PLL registers */
+/* PLL registers done */
+
+/* DemuxCipher registers */
+/* DemuxCipher registers done */
+
+/* DemuxTask registers */
+/* DemuxTask registers done */
+
+/* DemuxOutput registers */
+/* DemuxOutput registers done */
+
+/* CCFifo registers */
+/* CCFifo registers done */
+
+/* Sha1Sum registers */
+/* Sha1Sum registers done */
+
+/* XTask registers */
+/* XTask registers done */
+
+/* TTXFifo registers */
+/* TTXFifo registers done */
+
+/* VCXO registers */
+/* VCXO registers done */
+
+/* PPF registers */
+/* PPF registers done */
+
+#endif /* __EMHWLIB_REGISTERS_TANGO2_H__ */
+
+/* End of generated file ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h */
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_registers_tango2.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_registers_tango2.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_registers_tango2.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_registers_tango2.inc	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,565 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/tango2/emhwlib_registers_tango2.inc (generated from emhwlib_hal/include/tango2/emhwlib_registers_tango2.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+REG_BASE_system_block=0x10000
+SYS_clkgen0_pll=0x0
+SYS_clkgen0_div=0x4
+SYS_clkgen1_pll=0x8
+SYS_clkgen1_div=0xc
+SYS_clkgen2_pll=0x10
+SYS_clkgen2_div=0x14
+SYS_clkgen3_pll=0x18
+SYS_clkgen3_div=0x1c
+SYS_avclk_mux=0x38
+SYS_sysclk_mux=0x3c
+SYS_clk_cnt=0x40
+SYS_xtal_in_cnt=0x48
+DRAM_vbus_w0_cfg=0x300
+DRAM_vbus_w1_cfg=0x304
+DRAM_vbus_w2_cfg=0x308
+DRAM_vbus_w3_cfg=0x30c
+DRAM_vbus_r0_cfg=0x340
+DRAM_vbus_r1_cfg=0x344
+DRAM_vbus_r2_cfg=0x348
+DRAM_vbus_r3_cfg=0x34c
+DRAM_vbus_r4_cfg=0x350
+DRAM_vbus_r5_cfg=0x354
+DRAM_vbus_r6_cfg=0x358
+DRAM_vbus_r7_cfg=0x35c
+DRAM_vbus_r8_cfg=0x360
+DRAM_vbus_r9_cfg=0x364
+DRAM_vbus_r10_cfg=0x368
+DRAM_vbus_r11_cfg=0x36c
+DRAM_mbus_w0_cfg=0x200
+DRAM_mbus_w1_cfg=0x204
+DRAM_mbus_w2_cfg=0x208
+DRAM_mbus_w3_cfg=0x20c
+DRAM_mbus_w4_cfg=0x210
+DRAM_mbus_w5_cfg=0x214
+DRAM_mbus_w6_cfg=0x218
+DRAM_mbus_w7_cfg=0x21c
+DRAM_mbus_w8_cfg=0x220
+DRAM_mbus_w9_cfg=0x224
+DRAM_mbus_w10_cfg=0x228
+DRAM_mbus_r0_cfg=0x240
+DRAM_mbus_r1_cfg=0x244
+DRAM_mbus_r2_cfg=0x248
+DRAM_mbus_r3_cfg=0x24c
+DRAM_mbus_r4_cfg=0x250
+DRAM_mbus_r5_cfg=0x254
+DRAM_mbus_r6_cfg=0x258
+DRAM_mbus_r7_cfg=0x25c
+DRAM_mbus_r8_cfg=0x260
+DRAM_mbus_r9_cfg=0x264
+DRAM_mbus_r10_cfg=0x268
+SYS_hostclk_mux=0x30
+SYS_sysclk_premux=0x34
+SYS_rnd_cnt=0x44
+SYS_cnt_cfg=0x4c
+SYS_cfg_cnt0=0x50
+SYS_cfg_cnt1=0x54
+SYS_cfg_cnt2=0x58
+SYS_cfg_cnt3=0x5c
+SYS_cfg_cnt4=0x60
+SYS_cleandiv0_div=0x80
+SYS_cleandiv1_div=0x88
+SYS_cleandiv2_div=0x90
+SYS_cleandiv3_div=0x98
+SYS_cleandiv4_div=0xa0
+SYS_cleandiv5_div=0xa8
+SYS_cleandiv6_div=0xb0
+SYS_cleandiv7_div=0xb8
+SYS_cleandiv8_div=0xc0
+SYS_cleandiv9_div=0xc8
+SYS_cleandiv10_div=0xd0
+MARB_mid01_cfg=0x200
+MARB_mid21_cfg=0x204
+MARB_mid02_cfg=0x208
+MARB_mid22_cfg=0x20c
+MARB_mid04_cfg=0x210
+MARB_mid24_cfg=0x214
+MARB_mid25_cfg=0x218
+MARB_mid08_cfg=0x21c
+MARB_mid28_cfg=0x220
+MARB_mid29_cfg=0x224
+MARB_mid0C_cfg=0x228
+MARB_mid2C_cfg=0x22c
+MARB_mid10_cfg=0x230
+MARB_mid30_cfg=0x234
+MARB_mid31_cfg=0x238
+MARB_mid12_cfg=0x23c
+MARB_mid32_cfg=0x240
+VARB_mid01_cfg=0x300
+VARB_mid02_cfg=0x304
+VARB_mid21_cfg=0x308
+VARB_mid22_cfg=0x30c
+VARB_mid23_cfg=0x310
+VARB_mid24_cfg=0x314
+VARB_mid25_cfg=0x318
+VARB_mid26_cfg=0x31c
+VARB_mid27_cfg=0x320
+VARB_mid28_cfg=0x324
+VARB_mid29_cfg=0x328
+VARB_mid2A_cfg=0x32c
+VARB_mid10_cfg=0x330
+VARB_mid30_cfg=0x334
+VARB_mid31_cfg=0x338
+VARB_mid03_cfg=0x33c
+IARB_mid01_cfg=0x400
+IARB_mid02_cfg=0x404
+SYS_gpio_dir=0x500
+SYS_gpio_data=0x504
+SYS_gpio_int=0x508
+SYS_gpio15_pwm=0x510
+SYS_gpio14_pwm=0x514
+REG_BASE_dram_controller_0=0x30000
+REG_BASE_dram_controller_1=0x40000
+MEM_BASE_dram_controller_0_alias=0x10000000
+MEM_BASE_dram_controller_0=0x10000000
+MEM_BASE_dram_controller_1_alias=0x20000000
+MEM_BASE_dram_controller_1=0x20000000
+DRAM_dunit_cfg=0x0
+DRAM_dunit_delay0_ctrl=0x4
+DRAM_dunit_delay1_ctrl=0x8
+DRAM_dunit_auto_delay=0xc
+DRAM_dunit_fall_delay0=0x10
+DRAM_dunit_fall_delay1=0x14
+DRAM_dunit_bw_lobound=0x18
+DRAM_dunit_bw_hibound=0x1c
+DRAM_dunit_bw_probe_cfg=0x20
+DRAM_dunit_bw_probe_cnt=0x24
+DRAM_dunit_bw_cntall=0x28
+DRAM_dunit_calibration_delay=0x30
+DRAM_dunit_calibration_rise_err=0x34
+DRAM_dunit_calibration_fall_err=0x38
+DRAM_dunit_calibration_page=0x88
+DRAM_dunit_flush_buffer=0x104
+REG_BASE_host_interface=0x20000
+MEM_BASE_host_interface=0x40000000
+IDE_data=0x0
+IDE_error=0x4
+IDE_count=0x8
+IDE_start_sector=0xc
+IDE_cylinder_lo=0x10
+IDE_cylinder_hi=0x14
+IDE_head_device=0x18
+IDE_cmd_stat=0x1c
+IDE_irq_stat=0x218
+IDE_cmd_stat__=0x21c
+PB_timing0=0x800
+PB_timing1=0x804
+PB_timing2=0x808
+PB_timing3=0x80c
+PB_timing4=0x810
+PB_timing5=0x814
+PB_default_timing=0x818
+PB_use_timing0=0x81c
+PB_use_timing1=0x820
+PB_use_timing2=0x824
+PB_use_timing3=0x828
+PB_use_timing4=0x82c
+PB_use_timing5=0x830
+PB_CS_config=0x834
+PB_automode_start_address=0x840
+PB_automode_control=0x844
+EMHWLIB_IS_HOST=0xe000
+HOST_REG1=0xfed0
+HOST_REG2=0xfed4
+READ_ADDRESS=0xfec0
+READ_COUNTER=0xfec4
+READ_ENABLE=0xfec8
+REV_ORDER=0xfecc
+WRITE_ADDRESS=0xfed8
+WRITE_COUNTER=0xfedc
+WRITE_ENABLE=0xfee0
+BURST=0xfee4
+PCI_TIMEOUT=0x8000
+PCI_TIMEOUT_STATUS=0x8004
+PCI_TIMER=0x8008
+PCI_TIMER_TEST=0x800c
+PCI_WAKEUP=0x8010
+PCI_REGION_0_BASE=0x9000
+PCI_REGION_1_BASE=0x9004
+PCI_REGION_2_BASE=0x9008
+PCI_REGION_3_BASE=0x900c
+PCI_REGION_4_BASE=0x9010
+PCI_REGION_5_BASE=0x9014
+PCI_REGION_6_BASE=0x9018
+PCI_REGION_7_BASE=0x901c
+PCI_irq_status=0x9020
+PCI_irq_set=0x9024
+PCI_irq_clear=0x9028
+SBOX_FIFO_RESET=0x90a0
+SBOX_ROUTE=0x90a8
+output_SBOX_MBUS_W0=0x9080
+output_SBOX_MBUS_W1=0x9084
+output_SBOX_PCI_MASTER=0x9088
+output_SBOX_PCI_SLAVE=0x908c
+output_SBOX_CIPHER=0x9090
+output_SBOX_IDE_ISA=0x9094
+output_SBOX_IDE_DVD=0x9098
+input_keep_SBOX=0x0
+input_MBUS_R0_SBOX=0x1
+input_MBUS_R1_SBOX=0x2
+input_PCI_MASTER_SBOX=0x3
+input_PCI_SLAVE_SBOX=0x4
+input_CIPHER_SBOX=0x5
+input_IDE_DVD_SBOX=0x6
+input_IDE_ISA_SBOX=0x7
+input_SFLA_SBOX=0x8
+input_unconnected_SBOX=0xf
+host_mutex0=0x9040
+host_mutex1=0x9044
+host_mutex2=0x9048
+host_mutex3=0x904c
+host_mutex4=0x9050
+host_mutex5=0x9054
+host_mutex6=0x9058
+host_mutex7=0x905c
+host_mutex8=0x9060
+host_mutex9=0x9064
+host_mutex10=0x9068
+host_mutex11=0x906c
+host_mutex12=0x9070
+host_mutex13=0x9074
+host_mutex14=0x9078
+host_mutex15=0x907c
+PCI_host_reg5=0xfe94
+PCI_chip_is_host=0xfe90
+IDECTRL_idesrc=0x20d0
+IDECTRL_pri_drv1udmatim1=0x20e0
+IDECTRL_pri_drv1udmatim2=0x20f0
+IDECTRL_pri_idectl=0x2100
+IDECTRL_pri_drv0tim=0x2110
+IDECTRL_pri_drv1tim=0x2120
+IDECTRL_idemisc=0x2130
+IDECTRL_idestatus=0x2140
+IDECTRL_udmactl=0x2150
+IDECTRL_pri_drv0udmatim1=0x2160
+IDECTRL_pri_drv0udmatim2=0x2170
+IDECTRL_pref_st=0x2310
+IDECTRL_pri_ctrlblock=0x2398
+IDECTRL_pri_cmdblock=0x23c0
+IDECTRL_bmic=0x2400
+IDECTRL_bmis=0x2410
+IDECTRL_bmidtp=0x2420
+IDECTRL_ide_dmaptr=0x2780
+IDECTRL_ide_dmalen=0x2790
+IDECTRL_pio_prefetch_data=0x27c0
+MEM_BASE_pfla=0x40000000
+PB_CS0_OFFSET=0x0
+PB_CS1_OFFSET=0x4000000
+PB_CS2_OFFSET=0x8000000
+PB_CS3_OFFSET=0xc000000
+ETH_gpio_dir1=0x7100
+ETH_gpio_data1=0x7104
+ETH_gpio_mask1=0x7108
+ETH_gpio_dir2=0x710c
+ETH_gpio_data2=0x7110
+PCI_host_reg1=0xfed0
+PCI_host_reg2=0xfed4
+PCI_host_reg3=0xfe80
+PCI_host_reg4=0xfe84
+PCI_pcictrl_reg1=0xfe88
+PCI_pcictrl_reg2=0xfe8c
+PCI_pcictrl_reg3=0xfefc
+PCI_REG0=0xfee8
+PCI_REG1=0xfeec
+PCI_REG2=0xfef0
+PCI_REG3=0xfef4
+PCI_CONFIG=0xfef8
+MIF_W0_ADD=0xb000
+MIF_W0_CNT=0xb004
+MIF_W0_SKIP=0xb008
+MIF_W0_CMD=0xb00c
+MIF_W1_ADD=0xb040
+MIF_W1_CNT=0xb044
+MIF_W1_SKIP=0xb048
+MIF_W1_CMD=0xb04c
+MIF_R0_ADD=0xb080
+MIF_R0_CNT=0xb084
+MIF_R0_SKIP=0xb088
+MIF_R0_CMD=0xb08c
+MIF_R1_ADD=0xb0c0
+MIF_R1_CNT=0xb0c4
+MIF_R1_SKIP=0xb0c8
+MIF_R1_CMD=0xb0cc
+MBUS_IDLE=0x0
+MBUS_LINEAR=0x1
+MBUS_DOUBLE=0x2
+MBUS_RECTANGLE=0x3
+MBUS_VOID=0x4
+MBUS_LINEAR_VOID=0x5
+MBUS_DOUBLE_VOID=0x6
+MBUS_RECTANGLE_VOID=0x7
+MBUS_TILED=0x8
+GBUS_MUTEX_XPU=0x14
+GBUS_MUTEX_PT110=0x16
+GBUS_MUTEX_TDMX=0x19
+GBUS_MUTEX_AUDIO_0=0x1b
+GBUS_MUTEX_AUDIO_1=0x1c
+GBUS_MUTEX_MPEG_0=0x1d
+GBUS_MUTEX_MPEG_1=0x1e
+GBUS_MUTEX_HOST=0x1f
+GBUS_MUTEX_LOCAL=0x10
+REG_BASE_cpu_block=0x60000
+CPU_time0_load=0xc500
+CPU_time0_value=0xc504
+CPU_time0_ctrl=0xc508
+CPU_time0_clr=0xc50c
+CPU_time1_load=0xc600
+CPU_time1_value=0xc604
+CPU_time1_ctrl=0xc608
+CPU_time1_clr=0xc60c
+CPU_rtc_data=0xc800
+CPU_rtc_match=0xc804
+CPU_rtc_stat=0xc808
+CPU_rtc_load=0xc80c
+CPU_rtc_ctrl=0xc810
+CPU_irq_status=0xe000
+CPU_irq_rawstat=0xe004
+CPU_irq_enableset=0xe008
+CPU_irq_enableclr=0xe00c
+CPU_irq_softset=0xe010
+CPU_irq_softclr=0xe014
+CPU_fiq_status=0xe100
+CPU_fiq_rawstat=0xe104
+CPU_fiq_enableset=0xe108
+CPU_fiq_enableclr=0xe10c
+CPU_fiq_softset=0xe110
+CPU_fiq_softclr=0xe114
+CPU_edge_status=0xe200
+CPU_edge_rawstat=0xe204
+CPU_edge_config_rise=0xe208
+CPU_edge_config_fall=0xe20c
+CPU_SOFT_INT=0x1
+CPU_UART0_INT=0x2
+CPU_UART1_INT=0x4
+CPU_TIMER0_INT=0x20
+CPU_TIMER1_INT=0x40
+CPU_HOST_MBUS_W0_INT=0x200
+CPU_HOST_MBUS_W1_INT=0x400
+CPU_HOST_MBUS_R0_INT=0x800
+CPU_HOST_MBUS_R1_INT=0x1000
+CPU_PCI_INTA=0x2000
+CPU_PCI_INTB=0x4000
+CPU_PCI_INTC=0x8000
+CPU_PCI_INTD=0x10000
+CPU_PCI_FAULT_INT=0x100000
+CPU_INFRARED_INT=0x200000
+CPU_SFLA_INT=0x10
+CPU_DVD_INT=0x80
+CPU_ETH_INT=0x100
+CPU_DMAIDE_INT=0x20000
+CPU_IDE_INT=0x40000
+CPU_FRONTPANEL_INT=0x80000
+CPU_I2C_INT=0x400000
+CPU_GFX_ACCEL_INT=0x800000
+CPU_VSYNC0_INT=0x1000000
+CPU_VSYNC1_INT=0x2000000
+CPU_VSYNC2_INT=0x4000000
+CPU_VSYNC3_INT=0x8000000
+CPU_VSYNC4_INT=0x10000000
+CPU_VSYNC4BKEND_INT=0x20000000
+CPU_VSYNC5_INT=0x40000000
+CPU_VSYNC5BKEND_INT=0x80000000
+CPU_SMARTCARD_HI_INT=0x1
+CPU_HDMI_HI_INT=0x2
+CPU_HDMI_I2C_HI_INT=0x4
+CPU_VBUS_W0_HI_INT=0x8
+CPU_VBUS_W3_HI_INT=0x10
+CPU_ETH_PHY_HI_INT=0x20
+CPU_ETH_MAC_HI_INT=0x40
+CPU_USB_OHCI_MAC_HI_INT=0x80
+CPU_USB_EHCI_MAC_HI_INT=0x100
+LOG2_CPU_SOFT_INT=0x0
+LOG2_CPU_UART0_INT=0x1
+LOG2_CPU_UART1_INT=0x2
+LOG2_CPU_TIMER0_INT=0x5
+LOG2_CPU_TIMER1_INT=0x6
+LOG2_CPU_DVD_INT=0x7
+LOG2_CPU_RTC_INT=0x8
+LOG2_CPU_HOST_MBUS_W0_INT=0x9
+LOG2_CPU_HOST_MBUS_W1_INT=0xa
+LOG2_CPU_HOST_MBUS_R0_INT=0xb
+LOG2_CPU_HOST_MBUS_R1_INT=0xc
+LOG2_CPU_PCI_INTA=0xd
+LOG2_CPU_PCI_INTB=0xe
+LOG2_CPU_PCI_INTC=0xf
+LOG2_CPU_PCI_INTD=0x10
+LOG2_CPU_DMAIDE_INT=0x11
+LOG2_CPU_IDE_INT=0x12
+LOG2_CPU_FRONTPANEL_INT=0x13
+LOG2_CPU_PCI_FAULT_INT=0x14
+LOG2_CPU_INFRARED_INT=0x15
+LOG2_CPU_I2C_INT=0x16
+LOG2_CPU_GFX_ACCEL_INT=0x17
+LOG2_CPU_VSYNC0_INT=0x18
+LOG2_CPU_VSYNC1_INT=0x19
+LOG2_CPU_VSYNC2_INT=0x1a
+LOG2_CPU_VSYNC3_INT=0x1b
+LOG2_CPU_VSYNC4_INT=0x1c
+LOG2_CPU_VSYNC4BKEND_INT=0x1d
+LOG2_CPU_VSYNC5_INT=0x1e
+LOG2_CPU_VSYNC5BKEND_INT=0x1f
+LOG2_CPU_SMARTCARD_INT=0x20
+LOG2_CPU_HDMI_INT=0x21
+LOG2_CPU_HDMI_I2C_INT=0x22
+LOG2_CPU_VBUS_W0_INT=0x23
+LOG2_CPU_VBUS_W3_INT=0x24
+LOG2_CPU_ETH_PHY_INT=0x25
+LOG2_CPU_ETH_MAC_INT=0x26
+LOG2_CPU_USB_OHCI_INT=0x27
+LOG2_CPU_USB_EHCI_INT=0x28
+CPU_edge_status_hi=0xe220
+CPU_edge_rawstat_hi=0xe224
+CPU_edge_config_rise_hi=0xe228
+CPU_edge_config_fall_hi=0xe22c
+CPU_irq_status_hi=0xe018
+CPU_irq_rawstat_hi=0xe01c
+CPU_irq_enableset_hi=0xe020
+CPU_irq_enableclr_hi=0xe024
+CPU_fiq_status_hi=0xe118
+CPU_fiq_rawstat_hi=0xe11c
+CPU_fiq_enableset_hi=0xe120
+CPU_fiq_enableclr_hi=0xe124
+CPU_iiq_status=0xe300
+CPU_iiq_rawstat=0xe304
+CPU_iiq_enableset=0xe308
+CPU_iiq_enableclr=0xe30c
+CPU_iiq_softset=0xe310
+CPU_iiq_softclr=0xe314
+CPU_iiq_status_hi=0xe318
+CPU_iiq_rawstat_hi=0xe31c
+CPU_iiq_enableset_hi=0xe320
+CPU_iiq_enableclr_hi=0xe324
+CPU_UART_GPIOMODE=0x38
+CPU_UART_GPIODIR=0x30
+CPU_UART_GPIODATA=0x34
+CPU_edge_config_rise_set=0xe210
+CPU_edge_config_rise_clr=0xe214
+CPU_edge_config_fall_set=0xe218
+CPU_edge_config_fall_clr=0xe21c
+CPU_edge_config_rise_set_hi=0xe230
+CPU_edge_config_rise_clr_hi=0xe234
+CPU_edge_config_fall_set_hi=0xe238
+CPU_edge_config_fall_clr_hi=0xe23c
+CPU_pm_select_0=0xc900
+CPU_pm_counter_0=0xc904
+CPU_pm_select_1=0xc908
+CPU_pm_counter_1=0xc90c
+CPU_remap=0xf000
+CPU_remap1=0xf004
+CPU_remap2=0xf008
+CPU_remap3=0xf00c
+CPU_remap4=0xf010
+CPU_remap_address=0x1fc00000
+CPU_remap1_address=0x0
+CPU_remap2_address=0x4000000
+CPU_remap3_address=0x8000000
+CPU_remap4_address=0xc000000
+REG_BASE_irq_handler_block=0xe0000
+G2L_BIST_BUSY=0xffe0
+G2L_BIST_PASS=0xffe4
+G2L_BIST_MASK=0xffe8
+G2L_RESET_CONTROL=0xfffc
+CPU_UART0_base=0xc100
+CPU_UART1_base=0xc200
+CPU_UART_RBR=0x0
+CPU_UART_THR=0x4
+CPU_UART_IER=0x8
+CPU_UART_IIR=0xc
+CPU_UART_FCR=0x10
+CPU_UART_LCR=0x14
+CPU_UART_MCR=0x18
+CPU_UART_LSR=0x1c
+CPU_UART_MSR=0x20
+CPU_UART_SCR=0x24
+CPU_UART_CLKDIV=0x28
+CPU_UART_CLKSEL=0x2c
+REG_BASE_xpu_block=0xe0000
+REG_BASE_ipu_block=0xf0000
+REG_BASE_display_block=0x70000
+PMEM_BASE_display_block=0x300000
+VBUS_IDLE=0x0
+VBUS_LINEAR=0x1
+VBUS_DOUBLE=0x2
+VBUS_RECTANGLE=0x3
+VBUS_DOUBLE_FIELD=0x4
+VBUS_DOUBLE_RECTANGLE=0x5
+VBUS_8BYTE_COLUMN=0x6
+VBUS_VOID=0x8
+VBUS_LINEAR_VOID=0x9
+VBUS_DOUBLE_VOID=0xa
+VBUS_RECTANGLE_VOID=0xb
+VBUS_DOUBLE_FIELD_VOID=0xc
+VBUS_DOUBLE_RECTANGLE_VOID=0xd
+VBUS_8BYTE_COLUMN_VOID=0xe
+REG_BASE_demux_engine=0xa0000
+MEM_BASE_demux_engine=0x140000
+PMEM_BASE_demux_engine=0x140000
+DMEM_BASE_demux_engine=0x150000
+REG_BASE_demux_engine_0=0xa0000
+MEM_BASE_demux_engine_0=0x140000
+PMEM_BASE_demux_engine_0=0x140000
+DMEM_BASE_demux_engine_0=0x150000
+REG_BASE_demux_engine_1=0xb0000
+MEM_BASE_demux_engine_1=0x160000
+PMEM_BASE_demux_engine_1=0x160000
+DMEM_BASE_demux_engine_1=0x170000
+TDMX_gpio_data=0x2e0c
+TDMX_gpio_dir=0x2e0d
+REG_BASE_mpeg_engine_0=0x80000
+MEM_BASE_mpeg_engine_0=0x100000
+PMEM_BASE_mpeg_engine_0=0x100000
+DMEM_BASE_mpeg_engine_0=0x110000
+REG_BASE_mpeg_engine_1=0x90000
+MEM_BASE_mpeg_engine_1=0x120000
+PMEM_BASE_mpeg_engine_1=0x120000
+DMEM_BASE_mpeg_engine_1=0x130000
+RBUS_offset=0x4000
+REG_BASE_audio_engine_0=0xc0000
+MEM_BASE_audio_engine_0=0x180000
+PMEM_BASE_audio_engine_0=0x180000
+DMEM_BASE_audio_engine_0=0x190000
+REG_BASE_audio_engine_1=0xd0000
+MEM_BASE_audio_engine_1=0x1a0000
+PMEM_BASE_audio_engine_1=0x1a0000
+DMEM_BASE_audio_engine_1=0x1b0000
+audio_mutex0=0x3e90
+audio_mutex1=0x3e91
+audio_mutex2=0x3e92
+audio_mutex3=0x3e93
+audio_mutex4=0x3e94
+audio_mutex5=0x3e95
+audio_mutex6=0x3e96
+audio_mutex7=0x3e97
+I2C_MASTER_CONFIG=0x80
+I2C_MASTER_CLK_DIV=0x84
+I2C_MASTER_DEV_ADDR=0x88
+I2C_MASTER_ADDR=0x8c
+I2C_MASTER_DATA_OUT=0x90
+I2C_MASTER_DATA_IN=0x94
+I2C_MASTER_STATUS=0x98
+I2C_MASTER_STARTXFER=0x9c
+I2C_MASTER_BYTE_CNT=0xa0
+I2C_MASTER_INTEN=0xa4
+I2C_MASTER_INT=0xa8
+I2C_SLAVE_ADDR_REG=0xc0
+I2C_SLAVE_DATAOUT=0xc4
+I2C_SLAVE_DATAIN=0xc8
+I2C_SLAVE_STATUS=0xcc
+I2C_SLAVE_INTEN=0xd0
+I2C_SLAVE_INT=0xd4
+I2C_SLAVE_BUS_HOLD=0xd8
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_shared.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_shared.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_shared.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_shared.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,114 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_shared.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2005-03-22
+*/
+
+#ifndef __EMHWLIB_RESOURCES_SHARED_H__
+#define __EMHWLIB_RESOURCES_SHARED_H__
+
+#define VIDEO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex1))
+#define VIDEO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex1))
+#define AUDIO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex1))
+#define DEMUX_RPC_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex3))
+
+// pt110 local ram map
+#define UCLINUX_CURRENT_PROCESS (REG_BASE_cpu_block + 0x0000)
+
+#define RESET_VECTOR   (REG_BASE_cpu_block + 0x0000)
+#define UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0004)
+#define SWI_VECTOR     (REG_BASE_cpu_block + 0x0008)
+#define I_ABORT_VECTOR (REG_BASE_cpu_block + 0x000c)
+#define D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0010)
+#define RSV_VECTOR     (REG_BASE_cpu_block + 0x0014)
+#define IRQ_VECTOR     (REG_BASE_cpu_block + 0x0018)
+#define FIQ_VECTOR     (REG_BASE_cpu_block + 0x001c)
+
+#define RESET_JUMP     (REG_BASE_cpu_block + 0x0020)
+#define UNDEF_JUMP     (REG_BASE_cpu_block + 0x0024)
+#define SWI_JUMP       (REG_BASE_cpu_block + 0x0028)
+#define I_ABORT_JUMP   (REG_BASE_cpu_block + 0x002c)
+#define D_ABORT_JUMP   (REG_BASE_cpu_block + 0x0030)
+#define RSV_JUMP       (REG_BASE_cpu_block + 0x0034)
+#define IRQ_JUMP       (REG_BASE_cpu_block + 0x0038)
+#define FIQ_JUMP       (REG_BASE_cpu_block + 0x003c)
+
+#define INFINITE_LOOP  (REG_BASE_cpu_block + 0x0040)
+
+/* where to store uclinux interrupt handler */
+#define UCLINUX_RESET_VECTOR   (REG_BASE_cpu_block + 0x0044)
+#define UCLINUX_UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0048)
+#define UCLINUX_SWI_VECTOR     (REG_BASE_cpu_block + 0x004c)
+#define UCLINUX_I_ABORT_VECTOR (REG_BASE_cpu_block + 0x0050)
+#define UCLINUX_D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0054)
+#define UCLINUX_RSV_VECTOR     (REG_BASE_cpu_block + 0x0058)
+#define UCLINUX_IRQ_VECTOR     (REG_BASE_cpu_block + 0x005c)
+#define UCLINUX_FIQ_VECTOR     (REG_BASE_cpu_block + 0x0060)
+
+/* where to store fiq/irq enable values */
+#define UCLINUX_IRQ_ENABLE      (REG_BASE_cpu_block + 0x0064)
+#define UCLINUX_FIQ_ENABLE      (REG_BASE_cpu_block + 0x0068)
+
+/* we use this in uClinux to handshake llad with the hardware library. llad will 
+   initialize the value to 0. As long as this value is 0, llad will mask the
+   triggered interrupt. When the CPUBlock is done loading the IRQ handler, it
+   will set this value to all the IRQ that are now being handled by itself. Next
+   time llad receives an IRQ, it will read this value and if set to the proper
+   interrupt value, it will return without masking the interrupt.
+   This value is a mask of all the IRQs handled by the IRQ handler (see em8xxx
+   hardware IRQ register).
+
+   *** IMPORTANT *** This value must be update in llad.c if changed.
+*/
+#define UCLINUX_LLAD_IRQHANDLER_HANDSHAKE    (REG_BASE_cpu_block + 0x006C)
+
+/* these symbols are used to store the entry point of the irqhandler
+   loaded by the bootloader.  when uclinux boots it overwrites the
+   interrupt vector, and when we load emhwlib we must restore the RUA
+   entry point in the vector. Since the current version of the emhwlib
+   loaded may not match the irqhandler loaded by bootloader, the entry
+   points should not be determined at compilation time, but rather at
+   runtime.
+*/
+#define IRQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0070) 
+#define FIQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0074) 
+#define UNDEFHANDLER_ENTRY (REG_BASE_cpu_block + 0x0078) 
+#define JUMPTABLE_ADDRESS  (REG_BASE_cpu_block + 0x007c)
+
+/* address of linux General exeption handler */
+#define LINUX_GE (REG_BASE_cpu_block + 0x0080)
+
+// random seeds (refer to gbuslib/include/gbus_random.h)
+#define RANDOM0              (REG_BASE_cpu_block + LR_RANDOM_SEED + 0)
+#define RANDOM1              (REG_BASE_cpu_block + LR_RANDOM_SEED + 4)
+
+#define PCI_INTERRUPT_ENABLE    (REG_BASE_cpu_block + LR_PCI_INTERRUPT_ENABLE)
+#define HOST_INTERRUPT_STATUS   (REG_BASE_cpu_block + LR_HOST_INTERRUPT_STATUS)
+
+// next 8 dword locations are for local debug, they are reset to 0 at vsync_init time.
+// Please do not affect them in cvs source.
+#define DEBUG_PROBE0                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x00)
+#define DEBUG_PROBE1                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x04)
+#define DEBUG_PROBE2                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x08)
+#define DEBUG_PROBE3                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x0c)
+#define DEBUG_PROBE4                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x10)
+#define DEBUG_PROBE5                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x14)
+#define DEBUG_PROBE6                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x18)
+#define DEBUG_PROBE7                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x1c)
+
+// uses 8 entries, up to 0x1EF0
+#define PARAM_VSYNC_PERIOD_DEC0        (REG_BASE_cpu_block + LR_VSYNC_PERIOD)  // video decoder 0
+
+#endif // __EMHWLIB_RESOURCES_SHARED_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_shared.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_shared.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_shared.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_shared.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_resources_shared.inc (generated from emhwlib/include/emhwlib_resources_shared.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_tango2.h linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_tango2.h
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_tango2.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_tango2.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,47 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_tango2.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-01-28y
+*/
+
+#ifndef __EMHWLIB_RESOURCES_TANGO2_H__
+#define __EMHWLIB_RESOURCES_TANGO2_H__
+
+#define VSYNC_PARAM_MUTEX   ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex2))
+#define PCI_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex3))
+#define GFX_MUTEX           ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex4))
+#define HOST_MBUS_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex5))
+#define SOFT_IRQ_MUTEX_TASK ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex6))
+#define SOFT_IRQ_MUTEX_IRQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex7))
+#define SOFT_IRQ_MUTEX_FIQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex8))
+#define RTC_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex9))
+#define XRPC_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex10))
+#define XTASK_MUTEX         ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex11))
+#define IDMA_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex12)) /* keep same as tango15 */
+#define TIMER_IRQ_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex13)) 
+
+#define AUDIO_0_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex0))
+#define AUDIO_1_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex0))
+#define VIDEO_0_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex0))
+#define VIDEO_1_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex0))
+#define DEMUX_IRQ_MUTEX     ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex0))
+#define DEMUX_EMHWLIB_MUTEX ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex4))
+#define TIMER_UPDATE_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex5))
+
+#define AUDIO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex1))
+#define AUDIO_1_ENET_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex2))
+#define AUDIO_1_INTSTATUS_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex3))
+
+#endif // __EMHWLIB_RESOURCES_TANGO2_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_tango2.inc linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_tango2.inc
--- linux-2.6.25.8/include/asm-mips/tango2/emhwlib_resources_tango2.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/emhwlib_resources_tango2.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/tango2/emhwlib_resources_tango2.inc (generated from emhwlib/include/tango2/emhwlib_resources_tango2.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/fip.h linux-2.6.25.8-clean/include/asm-mips/tango2/fip.h
--- linux-2.6.25.8/include/asm-mips/tango2/fip.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/fip.h	2008-11-12 13:14:38.000000000 -0500
@@ -0,0 +1,117 @@
+/*****************************************
+ *  Copyright  2001-2007
+ *  Sigma Designs, Inc. All Rights Reserved
+ *  Proprietary and Confidential
+ ******************************************/
+
+/*
+ * FIP related definitions, and function prototypes.
+ */
+#ifndef _FIP_H_
+#define _FIP_H_
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#endif /* __KERNEL__ */
+
+/* Valid symbols */
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define DVD_FIP_ON			0
+#define PLAY_FIP_ON			1
+#define DTS_FIP_ON			2
+#define MP3_FIP_ON			3
+#define DOLBYDIGITAL_FIP_ON		4
+#define MPEG4_FIP_ON			5
+#define PAUSE_FIP_ON			6
+#define DVI_FIP_ON              	7
+#define TWIRL_1_FIP_ON			8
+#define TWIRL_2_FIP_ON			9
+#define TWIRL_3_FIP_ON			10
+#define TWIRL_4_FIP_ON			11
+#define TWIRL_5_FIP_ON			12
+#define TWIRL_6_FIP_ON			13
+#define ALL_FIP_ON			14
+#define REPEAT_FIP_ON			15
+#define COLON_MIN_SEC_FIP_ON		16
+#define R1080_FIP_ON			17
+#define R720_FIP_ON			18
+#define COLON_HOUR_MIN_FIP_ON		19
+#define R480_FIP_ON			20
+#define PAL_FIP_ON			21
+#define NTSC_FIP_ON			22
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define DVD_FIP				201
+#define VCD_FIP				202
+#define MP3_FIP				203
+#define CD_FIP				204
+#define TITLE_FIP			205
+#define TRACK_CHAPTER_FIP		206
+#else
+#error Unsupport front panel.
+#endif
+
+/* Alignment */
+#define FIP_LEFT		0x0000	/* flags for fip_write_text() */
+#define FIP_CENTER		0x0001
+#define FIP_RIGHT		0x0002
+
+/* FIP Keys */
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define FIP_KEY_EJECT		0x00000004
+#define FIP_KEY_PREV		0x00000800
+#define FIP_KEY_NEXT		0x00008000
+#define FIP_KEY_FBWD		0x00000008
+#define FIP_KEY_FFWD		0x00000080
+#define FIP_KEY_PLAYPAUSE	0x00000040
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define FIP_KEY_EJECT		0x00000001
+#define FIP_KEY_PLAYPAUSE	0x00000002
+#define FIP_KEY_STOP		0x00000004
+#define FIP_KEY_PREV		0x00000008
+#define FIP_KEY_NEXT		0x00000010
+#define FIP_KEY_FBWD		0x00000020
+#define FIP_KEY_FFWD		0x00000040
+#define FIP_KEY_MENU		0x00000080
+#else
+#error Unsupport front panel.
+#endif
+
+#if defined(__KERNEL__) || !defined(BOOTLOADER)
+/* ioctl commands for user level applications*/
+#define FIP_IOC_MAGIC		'F'
+#define FIP_IOCSHOWSYMBOL	_IO(FIP_IOC_MAGIC, 0)
+#define FIP_IOCSHOWHMS		_IO(FIP_IOC_MAGIC, 1)
+#define FIP_IOCDISPCHAR		_IO(FIP_IOC_MAGIC, 2)
+#define FIP_IOCDISPRAW		_IO(FIP_IOC_MAGIC, 3)
+#define FIP_IOCDISPTEXT		_IO(FIP_IOC_MAGIC, 4)
+#define FIP_IOCCLEAR		_IO(FIP_IOC_MAGIC, 5)
+#define FIP_IOCGETFPTYPE	_IO(FIP_IOC_MAGIC, 6)
+#endif /* __KERNEL__ || !BOOTLOADER */
+
+#ifdef __KERNEL__
+static void fip_write_text(const int position, const char *text, const int flags);
+static int fip_show_hms(int hour, int minute, int second);
+static void fip_display_symbol(const int symbol, const int on);
+static int fip_display_character(const int position, const char character);
+static void fip_display_raw(const int byte, const int bit, const int on); 
+static int is_fip_busy(void);
+static void fip_wait_ready(void);
+static void fip_clear(void);
+#elif defined(BOOTLOADER)
+void fip_write_text(const int position, const char *text, const int flags);
+int fip_show_hms(int hour, int minute, int second);
+void fip_display_symbol(const int symbol, const int on);
+int fip_display_character(const int position, const char character);
+void fip_display_raw(const int byte, const int bit, const int on); 
+int is_fip_busy(void);
+void fip_wait_ready(void);
+void fip_clear(void);
+int fip_init(void);
+int fip_exit(void);
+unsigned long fip_readkey(void);
+#endif /* __KERNEL__ */
+
+#endif
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/hardware.h linux-2.6.25.8-clean/include/asm-mips/tango2/hardware.h
--- linux-2.6.25.8/include/asm-mips/tango2/hardware.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/hardware.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,127 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+
+// UART0
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+// UART0
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#if defined(CONFIG_TANGO2_SMP863X) && (EM86XX_REVISION <= 3)
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 40
+#define IIQ_CONTROLLER_IRQ_BASE 72 // bit31 of iiq is linux irq 103
+#define IRQ_COUNT               32 // 32 interrupt sources
+#elif defined(CONFIG_TANGO2_SMP863X) && (EM86XX_REVISION > 3)
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+#else
+#error "Unsupported Tango2 chip."
+#endif
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+// IDE interrupts
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+// MBUS interface
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+// GPIO
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+// UART GPIO
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	7   	/* 2^7 = 128MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<MAX_LOG2_PCIMEM_MAP)*7)>>3)	/* Max ~112MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x10000000UL)   /* base address of EM86xx PCI slave */
+
+// Peripheral bus Registers
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+// Bus Master IDE
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+#ifndef __ASSEMBLY__
+// Physical address mapping
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if (physaddr >= MEM_BASE_dram_controller_0_alias)
+		return(physaddr); /* for Tango2, it's the same */
+	else if (physaddr >= CPU_remap4_address) 
+		return(gbus_readl(REG_BASE_cpu_block + CPU_remap4) + (physaddr - CPU_remap4_address));
+	else if (physaddr >= CPU_remap3_address) 
+		return(gbus_readl(REG_BASE_cpu_block + CPU_remap3) + (physaddr - CPU_remap3_address));
+	else if (physaddr >= CPU_remap2_address) 
+		return(gbus_readl(REG_BASE_cpu_block + CPU_remap2) + (physaddr - CPU_remap2_address));
+#endif
+	return(physaddr); 
+}
+
+// Inverted physical address mapping
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if ((mapaddr >= MEM_BASE_dram_controller_0_alias) && (mapaddr < MEM_BASE_dram_controller_1))
+		return(mapaddr); /* for Tango2, it's the same */
+	else {
+		unsigned long remap;
+		remap = gbus_readl(REG_BASE_cpu_block + CPU_remap4);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap4_address + (mapaddr - remap));
+		remap = gbus_readl(REG_BASE_cpu_block + CPU_remap3);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap3_address + (mapaddr - remap));
+		remap = gbus_readl(REG_BASE_cpu_block + CPU_remap2);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap2_address + (mapaddr - remap));
+	}
+#endif
+	return(mapaddr); /* for Tango2, it's the same */
+}
+#endif
+		
+#endif //__HARDWARE_H
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/ir.h linux-2.6.25.8-clean/include/asm-mips/tango2/ir.h
--- linux-2.6.25.8/include/asm-mips/tango2/ir.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/ir.h	2008-09-17 14:00:41.000000000 -0400
@@ -0,0 +1,36 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+                                                                                
+/*
+ * IR related definitions, and function prototypes.
+ */
+#ifndef _IR_H_
+#define _IR_H_
+                                                                                
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#elif !defined(BOOTLOADER)
+#include <sys/ioctl.h>
+#endif /* __KERNEL__ */
+
+#if defined(__KERNEL__) || !defined(BOOTLOADER)
+/* ioctl commands for user level applications*/
+#define IR_IOC_MAGIC           'I'
+#define IR_IOCSETREPEATKEYS	_IO(IR_IOC_MAGIC, 0)
+#define IR_IOCGETREPEATKEYS	_IO(IR_IOC_MAGIC, 1)
+#define IR_IOCSETWAITPERIOD	_IO(IR_IOC_MAGIC, 2)
+#define IR_IOCGETWAITPERIOD	_IO(IR_IOC_MAGIC, 3)
+#define FIP_IOC_MAGIC		'F'
+#define FIP_IOCSHOWLED	_IO(FIP_IOC_MAGIC, 7)
+#endif /* __KERNEL__ || !BOOTLOADER */
+                                                                                
+#endif /* _IR_H_ */
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/memcfg.h linux-2.6.25.8-clean/include/asm-mips/tango2/memcfg.h
--- linux-2.6.25.8/include/asm-mips/tango2/memcfg.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/memcfg.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,44 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* For more memcfg operations */
+
+#ifndef _MEMCFG_H_
+#define _MEMCFG_H_
+
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_dram.h>
+
+static inline int is_valid_memcfg(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	if ((memcfg_ptr->signature) != MEMCFG_SIGNATURE)
+		return(0);
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	return((sum == 0) ? 1 : 0);
+}
+
+static inline void gen_memcfg_checksum(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	memcfg_ptr->checksum = 0;
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	memcfg_ptr->checksum = ~sum + 1;
+}
+
+#endif /* _MEMCFG_H_ */
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/rmdefs.h linux-2.6.25.8-clean/include/asm-mips/tango2/rmdefs.h
--- linux-2.6.25.8/include/asm-mips/tango2/rmdefs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/rmdefs.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/rmem86xxid.h linux-2.6.25.8-clean/include/asm-mips/tango2/rmem86xxid.h
--- linux-2.6.25.8/include/asm-mips/tango2/rmem86xxid.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/rmem86xxid.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,203 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   rmem86xxid.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-09-22
+*/
+
+#ifndef __RMEM86XXID_H__
+#define __RMEM86XXID_H__
+
+/*
+  the main chip ids 
+  
+  tango3 is for asic development (should be tango\infty)
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#define EM86XX_CHIPID_MAMBO      1000
+#define EM86XX_CHIPID_MAMBOLIGHT 2000
+#define EM86XX_CHIPID_TANGO      3000
+#define EM86XX_CHIPID_TANGOLIGHT 4000
+#define EM86XX_CHIPID_TANGO15    4500
+#define EM86XX_CHIPID_TANGO2     5000
+#define EM86XX_CHIPID_TANGO3    10000
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_MAMBO)
+#define S_EM86XX_CHIPID "mambo"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_MAMBOLIGHT)
+#define S_EM86XX_CHIPID "mambolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGOLIGHT)
+#define S_EM86XX_CHIPID "tangolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO15)
+#define S_EM86XX_CHIPID "tango15"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+#define S_EM86XX_CHIPID "tango2"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#define S_EM86XX_CHIPID "tango3"
+#else
+#error EM86XX_CHIP is not set
+#endif
+
+/* 
+  revisions...
+  
+  Referring to whatever is written at the surface of the BGA,
+  not the PCI revid / subid / etc. This detail is important for some chips
+  are ambiguous software wise.
+  
+  1: ES1
+  2: ES2
+  3: ES3
+  4: ES4 
+  5: ES5 
+  6: ES6 
+  65: revA
+  66: revB
+  67: revC
+  
+  No ID, but numbers. For a 8630ES2 for instance: build with
+  RMCFLAGS="... -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=2 ..."
+
+  --------------------------------------------------------------------------
+  package writing          ES1  ES2  ES3  ES4     ES5     ES6  ES7  ES8  ES9 revA revB revC
+
+  EM86XX_REVISION            1    2    3    4       5       6    7    8    9  'A'  'B'  'C'
+
+  8600 `mambo' series                                                           1    2    3
+
+  8620 `tangolight' series                                                    (a)  (b) 0x82
+  8622 `tango15' series   0x81                (d)0x81                   0x82
+                                                                           ^this is the PCI revID
+
+  863x `tango2' series (c)0x81 0x81 0x81 0x82 (e)0x82 (f)0x83 0x84 0x85 0x86                
+
+  (a) don't remember
+  (b) no such chip
+  (c) 8630: FibbedES1 ES1 ES2 ES3 are the same chip
+  (d) 8622: ES1 and revA cannot be distinguished from revID. Software test impossible in practice
+  (e) 8630: ES4 and ES5 cannot be distinguished from revID. Software test with 0x6c900 bit12
+  (f) 8634: ES6 and RevA have the same revID (just different bonding option)
+      8634: ES7 and RevB have the same revID (just different bonding option)
+      8634: ES9 and RevC have the same revID (just different bonding option)
+  --------------------------------------------------------------------------
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#ifndef EM86XX_REVISION
+#error EM86XX_REVISION is not set
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='A') 
+#error inconsistent: 863x revA is actually -DWITH_PROD=1 -DEM86XX_REVISION=6
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='B') 
+#error inconsistent: 863x revB is actually -DWITH_PROD=1 -DEM86XX_REVISION=7
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='C') 
+#error inconsistent: 863x revC is actually -DWITH_PROD=1 -DEM86XX_REVISION=9
+#endif
+
+#if (EM86XX_REVISION==1)
+#define S_EM86XX_REVISION "ES1"
+#elif (EM86XX_REVISION==2)
+#define S_EM86XX_REVISION "ES2"
+#elif (EM86XX_REVISION==3)
+#define S_EM86XX_REVISION "ES3"
+#elif (EM86XX_REVISION==4)
+#define S_EM86XX_REVISION "ES4"
+#elif (EM86XX_REVISION==5)
+#define S_EM86XX_REVISION "ES5"
+#elif (EM86XX_REVISION==6)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revA"
+#else
+#define S_EM86XX_REVISION "ES6"
+#endif
+#elif (EM86XX_REVISION==7)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revB"
+#else
+#define S_EM86XX_REVISION "ES7"
+#endif
+#elif (EM86XX_REVISION==8)
+#define S_EM86XX_REVISION "ES8"
+#elif (EM86XX_REVISION==9)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revC"
+#else
+#define S_EM86XX_REVISION "ES9"
+#endif
+
+#elif (EM86XX_REVISION=='A')
+#define S_EM86XX_REVISION "revA"
+#elif (EM86XX_REVISION=='B')
+#define S_EM86XX_REVISION "revB"
+#elif (EM86XX_REVISION=='C')
+#define S_EM86XX_REVISION "revC"
+#else
+#error complete revision strings
+#endif
+
+/* the compilation modes */
+#define EM86XX_MODEID_WITHHOST   1000
+#define EM86XX_MODEID_STANDALONE 2000
+
+/* the dsps */
+#define EM86XX_ENGINEID_MPEG0 10
+#define EM86XX_ENGINEID_MPEG1 11
+#define EM86XX_ENGINEID_AUDIO0 20
+#define EM86XX_ENGINEID_AUDIO1 21
+#define EM86XX_ENGINEID_DEMUX 30
+
+/* user does not have to set an engine id. This makes sense for mu only */
+#ifdef EM86XX_ENGINE
+#if (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG0)
+#define SENG "mpeg0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG1)
+#define SENG "mpeg1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO0)
+#define SENG "audio0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO1)
+#define SENG "audio1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_DEMUX)
+#define SENG "demux"
+#else
+#endif // end of engine dependent stuff
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+/*
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_XLOADED_UCODE
+#error inconsistent flag combination.
+#endif
+
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_IRQHANDLER_BOOTLOADER
+#error inconsistent flag combination.
+#endif
+*/
+#ifdef WITH_UCODE_BOOTLOADER
+#error inconsistent flag combination. You probably want WITH_XLOADED_UCODE
+#endif
+
+#endif
+
+/* the microcode debug mode */
+
+#define EM86XX_DEBUG_CHIP	1000
+#define EM86XX_DEBUG_SIMU	2000
+
+#endif // __RMEM86XXID_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/sigblock.h linux-2.6.25.8-clean/include/asm-mips/tango2/sigblock.h
--- linux-2.6.25.8/include/asm-mips/tango2/sigblock.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/sigblock.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,261 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SIG_BLOCK_H__
+#define __SIG_BLOCK_H__
+
+#define DEFAULT_IRQ_ROUTE1	0x55555555 /* All PCI IRQs route to LOG2_CPU_PCI_INTB */
+#define DEFAULT_IRQ_ROUTE2	0x00030000 /* ISA IDE uses LOG2_CPU_PCU_INTD, Timing slot 0 */
+#define DEFAULT_IRQ_RISE_EDGE_LO	0xff284a00 /* IRQ14 active low level, IRQ19/21 active riseedge */
+#define DEFAULT_IRQ_RISE_EDGE_HI	0x00000000 /* IRQ14 active low level, IRQ19/21 active rise edge */
+#define DEFAULT_IRQ_FALL_EDGE_LO	0x00004000
+#define DEFAULT_IRQ_FALL_EDGE_HI	0x00000000
+#define DEFAULT_IRQ_GPIO_MAP	0x0607080d /* ISA IDE/GPIO 6, PCI/GPIO 8 */
+#define DEFAULT_DEV_ENABLED	0x00003cf7 /* ISAIDE/BMIDE/PCIHOST/IR/FIP/I2CM/I2CS/PCI1-4 enabled */
+#define DEFAULT_PB_DEF_TIMING	0x01090008
+#define DEFAULT_PB_CS_CONFIG	0x00001044
+#define DEFAULT_PB_TIMING0	0x01090008
+#define DEFAULT_PB_USE_TIMING0	0x000001f4
+#define DEFAULT_PB_TIMING1	0x00110101
+#define DEFAULT_PB_USE_TIMING1	0x000003f3
+#define DEFAULT_PB_TIMING2	0
+#define DEFAULT_PB_USE_TIMING2	0
+#define DEFAULT_PB_TIMING3	0
+#define DEFAULT_PB_USE_TIMING3	0
+#define DEFAULT_PB_TIMING4	0
+#define DEFAULT_PB_USE_TIMING4	0
+#define DEFAULT_PB_TIMING5	0
+#define DEFAULT_PB_USE_TIMING5	0
+
+#define DEFAULT_SYSCLK_PLL	0x0 /* Set by XOS */
+#define DEFAULT_SYSCLK_DIV	0x0 /* Not changed */
+
+#define DEFAULT_ETH_MAC_HI	0x00000000 /* MAC address */
+#define DEFAULT_ETH_MAC_LO	0x00000000
+
+/* This list of devices in the enable list field (irq_route2) */
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+/*				19-32: undefined */
+
+#ifndef __ASSEMBLY__
+
+struct hwinfo {
+	unsigned long sysclk_pll; /* The setting for the PLL */
+	unsigned long sysclk_div;
+
+	/* Only 4 IRQs can be used for PCI devices (LOG2_CPU_PCI_INTA-D,
+	   so we can encode it in 2 bits. Each device can have 4 IRQ
+	   routing and as as result we can use one byte to represent
+	   the IRQ route for a given device (IDSELx). Bu using 8 bytes,
+	   we can represent the PCI devices (IDSEL1-6, 5-6 reserved) as
+	   well as ISA IDE information and device enabling list*/
+	unsigned long irq_route1;	/* PCI dev 1-4 */
+
+	/* PCI dev 5-6, ISA IDE information, device enabling list */
+	unsigned long irq_route2;	/* PCI dev 5-6: bit 0-15 */
+					/* ISA IDE: bit 16-17: IRQ offset */
+
+	unsigned long irq_rise_edge_hi; /* Rising edge config */
+	unsigned long irq_rise_edge_lo; /* Rising edge config */
+	unsigned long irq_fall_edge_hi; /* Falling edge config */
+	unsigned long irq_fall_edge_lo; /* Falling edge config */
+
+	unsigned long gpio_irq_map; /* GPIO pins hook to IRQ13..16 */
+	unsigned long dev_enabled;  /* Device enabling list*/
+
+	unsigned long pb_def_timing;
+	unsigned long pb_cs_config;
+	unsigned long pb_timing0;
+	unsigned long pb_use_timing0;
+	unsigned long pb_timing1;
+	unsigned long pb_use_timing1;
+	unsigned long pb_timing2;
+	unsigned long pb_use_timing2;
+	unsigned long pb_timing3;
+	unsigned long pb_use_timing3;
+	unsigned long pb_timing4;
+	unsigned long pb_use_timing4;
+	unsigned long pb_timing5;
+	unsigned long pb_use_timing5;
+
+	unsigned long mac_hi;	/* Ethernet MAC address */
+	unsigned long mac_lo;
+};
+
+/* Definition of signature block (192bytes), which should start at 0xbfc00000 */
+/* There'll be 20bytes sha1sum afterward (0xbfc000c0-0xbfc000d3) */
+struct signature_block {
+	unsigned long opcodes[2];  /* For opcodes, fixed value 0x10000034/0x00000000 */
+	struct hwinfo hwinfo;
+	/* 
+	   zboot or such specific extensions 
+
+	   Note that YAMON requires extension[2]=0x1105e0 (product ID `thirdparty')
+	 */
+	unsigned long extension[20];	
+};
+
+//RMmustBeEqual(sizeof(struct signature_block),3*64,seed0);
+
+#ifdef __EMHWLIB_REGISTERS_TANGO2_H__
+static inline int isaide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ISAIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int bmide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> BMIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sata_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SATA_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int scard_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SCARD_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int gnet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> GNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pci_host_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> PCIHOST_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ethernet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ETHERNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ir_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> IR_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int fip_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> FIP_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cm_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CM_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cs_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CS_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sdio_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SDIO_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int usb_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> USB_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pcidev_enabled(const struct signature_block *sigptr, int pci_idsel)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> (pci_idsel - 1 + PCI1_SHIFT)) & 1) != 0) ? 1 : 0);
+}
+
+/* Given PCI device idsel number and INT number, returning the IRQ number
+   for it */
+static inline int pcidev_intr_num(const struct signature_block *sigptr,
+				const int pci_idsel, const int int_num)
+{
+	unsigned long route;
+	int irq;
+
+	if (pcidev_enabled(sigptr, pci_idsel) == 0)
+		return(-1);
+	else if ((pci_idsel >= 1) && (pci_idsel <= 4)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route1) >> ((pci_idsel - 1) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else if ((pci_idsel >= 5) && (pci_idsel <= 6)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route2) >> ((pci_idsel - 5) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else 
+		return(-1);
+
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+ 
+/* Find out the CS# used by ISA IDE */
+static inline int isaide_cs_select(const struct signature_block *sigptr)
+{
+	unsigned long cs_config = (sigptr->hwinfo.pb_cs_config >> 12) & 0xf;
+	int i;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+
+	for (i = 0; i < 4; i++) {
+		if ((cs_config & 0x1) != 0) 
+			return(i);
+		else
+			cs_config >>= 1;
+	}
+	return(-1);
+}
+
+/* Return the IRQ number for ISA IDE */
+static inline int isaide_intr_num(const struct signature_block *sigptr)
+{
+	int irq;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+	else
+		irq = (int)(((sigptr->hwinfo.irq_route2) >> 16) & 0x3);
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+
+static inline int isaide_timing_slot(const struct signature_block *sigptr)
+{
+	unsigned long slot;
+
+	slot = ((sigptr->hwinfo.irq_route2) >> 18) & 0x7;
+	return((int)slot);
+}
+#endif /* __EMHWLIB_REGISTERS_TANGO2_H__ */
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* !__SIG_BLOCK_H__ */
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/sigblock.inc linux-2.6.25.8-clean/include/asm-mips/tango2/sigblock.inc
--- linux-2.6.25.8/include/asm-mips/tango2/sigblock.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/sigblock.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,59 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/sigblock.inc (generated from emhwlib_hal/include/sigblock.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+DEFAULT_IRQ_ROUTE1=0x55555555
+DEFAULT_IRQ_ROUTE2=0x30000
+DEFAULT_IRQ_RISE_EDGE_LO=0xff284a00
+DEFAULT_IRQ_RISE_EDGE_HI=0x0
+DEFAULT_IRQ_FALL_EDGE_LO=0x4000
+DEFAULT_IRQ_FALL_EDGE_HI=0x0
+DEFAULT_IRQ_GPIO_MAP=0x607080d
+DEFAULT_DEV_ENABLED=0x3cf7
+DEFAULT_PB_DEF_TIMING=0x1090008
+DEFAULT_PB_CS_CONFIG=0x1044
+DEFAULT_PB_TIMING0=0x1090008
+DEFAULT_PB_USE_TIMING0=0x1f4
+DEFAULT_PB_TIMING1=0x110101
+DEFAULT_PB_USE_TIMING1=0x3f3
+DEFAULT_PB_TIMING2=0x0
+DEFAULT_PB_USE_TIMING2=0x0
+DEFAULT_PB_TIMING3=0x0
+DEFAULT_PB_USE_TIMING3=0x0
+DEFAULT_PB_TIMING4=0x0
+DEFAULT_PB_USE_TIMING4=0x0
+DEFAULT_PB_TIMING5=0x0
+DEFAULT_PB_USE_TIMING5=0x0
+DEFAULT_SYSCLK_PLL=0x0
+DEFAULT_SYSCLK_DIV=0x0
+DEFAULT_ETH_MAC_HI=0x0
+DEFAULT_ETH_MAC_LO=0x0
+ISAIDE_SHIFT=0x0
+BMIDE_SHIFT=0x1
+PCIHOST_SHIFT=0x2
+ETHERNET_SHIFT=0x3
+IR_SHIFT=0x4
+FIP_SHIFT=0x5
+I2CM_SHIFT=0x6
+I2CS_SHIFT=0x7
+SDIO_SHIFT=0x8
+USB_SHIFT=0x9
+PCI1_SHIFT=0xa
+PCI2_SHIFT=0xb
+PCI3_SHIFT=0xc
+PCI4_SHIFT=0xd
+PCI5_SHIFT=0xe
+PCI6_SHIFT=0xf
+SATA_SHIFT=0x10
+SCARD_SHIFT=0x11
+GNET_SHIFT=0x12
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/tango2.h linux-2.6.25.8-clean/include/asm-mips/tango2/tango2.h
--- linux-2.6.25.8/include/asm-mips/tango2/tango2.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/tango2.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,65 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   tango2.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO2_H__
+#define __TANGO2_H__
+#include <asm/tango2/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_resources_tango2.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#endif
+/* Baudrate setting */
+#if defined(CONFIG_TANGO2_SMP863X)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO2_SMP863X)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO2_SMP863X)
+#if (EM86XX_REVISION <= 3)
+#define SYS_clkgen_pll        SYS_clkgen3_pll
+#else /* For ES4 or above */
+#define SYS_clkgen_pll        SYS_clkgen3_pll
+#endif
+#endif
+
+#endif // __TANGO2_H__
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/tango2_gbus.h linux-2.6.25.8-clean/include/asm-mips/tango2/tango2_gbus.h
--- linux-2.6.25.8/include/asm-mips/tango2/tango2_gbus.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/tango2_gbus.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,147 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+  Refer to bug #3644.
+
+  TLB-based implementation works on the ranges:
+  [0x00000000..0x20000000[ access thru kseg1
+  [0x20000000..0x2xxxxxxx (size  of dram1, a  parameter of ioremap())[
+  access thru tlb. Outside: unpredictable/oops.
+
+  Remap-based implementation does:
+  00xy b27b26..b0 to 101y(b27|x)b26..b0.
+  and works  everywhere excepted ranges:  [0x18000000..0x20000000[ and
+  [0x28000000..0xffffffff]
+
+  Test with
+  {
+	volatile int q=gbus_read_uint32(pGBus,0x1020212c); // correct
+	q=gbus_read_uint32(pGBus,0x1f20212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2020212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2720212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2820212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2f20212c);              // incorrect
+  }
+*/
+
+#ifndef __TANGO2_GBUS_H
+#define __TANGO2_GBUS_H
+
+//#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	ext	\\res, \\addr, 29, 1				\n"
+	"	bnez	\\res, 1f					\n"
+	"	lui	\\tmp, 0xa000					\n"
+	"	or	\\res, \\tmp, \\addr				\n"
+	"	j	2f						\n"
+	"	nop							\n"
+	"1:								\n"
+	"	lui	\\tmp, 0x2000					\n"
+	"	sub	\\res, \\addr, \\tmp				\n"
+	"	lw	\\tmp, em86xx_tlb_dram1_map_base		\n"
+	"	add	\\res, \\tmp					\n"
+	"2:								\n"
+	"	.endm");
+
+#else
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	rotr	\\res, \\addr, 29				\n"
+	"	ins	\\res, \\res, 30, 1				\n"
+	"	or	\\res, 5					\n"
+	"	rotr	\\res, 3					\n"
+	"	.endm");
+#endif
+
+
+/*
+ * we just want to set kseg1 bit, most of the time address is known at
+ * compile time, so this will usually be reduced to 2 instructions
+ */
+
+#define BUILD_GBUS_READ(size)						\
+static inline RMuint32 gbus_read_dram_uint##size(struct gbus *pgbus,	\
+					    RMuint32 byte_address)	\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		return *((volatile RMuint##size *)KSEG1ADDR(byte_address)); \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		return *((volatile RMuint##size *)res);			\
+	}								\
+}
+
+BUILD_GBUS_READ(8);
+BUILD_GBUS_READ(16);
+BUILD_GBUS_READ(32);
+
+#define BUILD_GBUS_WRITE(size)						\
+static inline void gbus_write_dram_uint##size(struct gbus *pgbus,	\
+				     RMuint32 byte_address,		\
+				     RMuint##size data)			\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data; \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		*((volatile RMuint##size *)res) = data;			\
+	}								\
+}
+
+BUILD_GBUS_WRITE(8);
+BUILD_GBUS_WRITE(16);
+BUILD_GBUS_WRITE(32);
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_readl(r)		gbus_read_uint32(pGBus, (r))
+#define gbus_writel(r, v)	gbus_write_uint32(pGBus, (r), (v))
+#define gbus_readw(r)		gbus_read_uint16(pGBus, (r))
+#define gbus_writew(r, v)	gbus_write_uint16(pGBus, (r), (v))
+#define gbus_readb(r)		gbus_read_uint8(pGBus, (r))
+#define gbus_writeb(r, v)	gbus_write_uint8(pGBus, (r), (v))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO2_GBUS_H */
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/tango2_usb.h linux-2.6.25.8-clean/include/asm-mips/tango2/tango2_usb.h
--- linux-2.6.25.8/include/asm-mips/tango2/tango2_usb.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/tango2_usb.h	2008-06-26 15:01:02.000000000 -0400
@@ -0,0 +1,38 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO2_USB_H
+#define __TANGO2_USB_H
+
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+
+#define TANGOX_EHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT)
+#define TANGOX_OHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+
+#define TANGOX_EHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE	(REG_BASE_host_interface + 0x1700)
+
+/*
+ * helpers to access USB registers
+ */
+#define RD_OHCI_REG32(r)	\
+		gbus_readl(TANGOX_OHCI_BASE_ADDR + (r))
+
+#define WR_OHCI_REG32(r, v)	\
+		gbus_writel(TANGOX_OHCI_BASE_ADDR + (r), (v))
+
+#define RD_USB_REG32(r)	\
+		gbus_readl(TANGOX_USB_CTL_STATUS_REG_BASE + (r))
+
+#define WR_USB_REG32(r, v)	\
+		gbus_writel(TANGOX_USB_CTL_STATUS_REG_BASE + (r), (v))
+
+#endif
diff -Naur linux-2.6.25.8/include/asm-mips/tango2/tango2api.h linux-2.6.25.8-clean/include/asm-mips/tango2/tango2api.h
--- linux-2.6.25.8/include/asm-mips/tango2/tango2api.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango2/tango2api.h	2008-06-26 14:59:52.000000000 -0400
@@ -0,0 +1,118 @@
+/*
+ * include/asm-mips/tango2/tangoa2pi.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango2/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA1, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_UNUSED1, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_init(void);
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int any);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+
+int em86xx_mbus_setup_dma_common(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+void em86xx_mbus_setup_dma_linear(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int flags);
+void em86xx_mbus_setup_dma_double(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int addr2, unsigned int count2, unsigned int flags);
+void em86xx_mbus_setup_dma_rectangle(unsigned int regbase, unsigned int addr, unsigned int horiz, unsigned int lines, int skip, unsigned int flags);
+void em86xx_mbus_setup_dma_void(unsigned int regbase);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+#if defined(CONFIG_EM86XX_UART0_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART0_AS_GPIO_PARTIAL)
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+#endif
+#if defined(CONFIG_EM86XX_UART1_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART1_AS_GPIO_PARTIAL)
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+#endif
+
+#endif
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,67 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram.h
+  @brief  
+
+  fm stands for: first megabyte.
+
+  THE CODE USING THESE SYMBOLS ASSUMES THAT THE END BOUNDARY OF AN
+  ENTITY IS THE START BOUNDARY OF THE NEXT ENTITY
+  
+  htoinc.pl emhwlib_dram.h emhwlib_dram.inc
+  
+  @author Emmanuel Michon
+  @date   2004-07-26
+*/
+
+#ifndef __EMHWLIB_DRAM_H__
+#define __EMHWLIB_DRAM_H__
+
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO3
+#include "emhwlib_dram_tango3.h"
+#elif EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+#include "emhwlib_dram_tango2.h"
+#else
+#include "emhwlib_dram_others.h"
+#endif
+
+#define MEMCFG_SIGNATURE	0x6766636d // `m' `c' `f' `g'
+
+#ifndef __ASSEMBLY__
+
+/* This is the memory map data structure, the size is 64 bytes */
+typedef struct {
+	unsigned int signature;                                                           // ...fc0
+	unsigned int dram0_size;            /* The size of DRAM0 */
+	unsigned int dram1_size;            /* The size of DRAM1 */
+	unsigned int dram2_size;            /* The size of DRAM2 */
+	unsigned int dram0_removable_topreserved;     /* The size of top reserved in DRAM0   ...fd0 */
+	unsigned int dram1_removable_topreserved;     /* The size of top reserved in DRAM1 */
+	unsigned int dram0_top_removable_area;    /* for special use such as splash screen */ 
+	                                          /* users can use set and get properties on the memory reserved by this variable */
+	unsigned int dram0_fixed_topreserved;     /* The size of top reserved in DRAM0 */
+	unsigned int dram1_fixed_topreserved;     /* The size of top reserved in DRAM1       ...fe0 */
+	unsigned int dram2_fixed_topreserved;     /* The size of top reserved in DRAM2 */
+	unsigned int kernel_end;            /* The end offset of kernel */
+	unsigned int checksum;		    /* The checksum */
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+	unsigned int dram1_kernel_end;	    /* The end offset of kernel used data in second dram */
+	unsigned int curtainA0;                                                      
+	unsigned int curtainB0;
+	unsigned int curtainC;
+#else
+	unsigned int reserved[4];           /* Reserved for extension */
+#endif
+} memcfg_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif // __EMHWLIB_DRAM_H__
+ 
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_others.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_others.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_others.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_others.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,37 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram_others.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed
+  that computing FM_IRQHANDLER_STACKTOP_USR-FM_IRQHANDLER_CODE
+  is a proper way to access the max usable size for
+  FM_IRQHANDLER_CODE.
+
+  @author Emmanuel Michon
+  @date   2005-04-11
+*/
+
+#ifndef __EMHWLIB_DRAM_OTHERS_H__
+#define __EMHWLIB_DRAM_OTHERS_H__
+
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_IRQHANDLER_CODE         0x00011000
+#define FM_IRQHANDLER_STACKTOP_USR 0x00040000 /* defined, but never used */
+#define FM_IRQHANDLER_STACKTOP_IRQ 0x00048000
+#define FM_IRQHANDLER_STACKTOP_FIQ 0x00050000
+#define FM_STACKTOP_SVC            0x00058000
+#define FM_DRM			   0x00058000
+#define FM_GNET			   0x00058000 /* incompatible with DRM */
+#define FM_BOOTLOADER_CODE         0x00060000
+#define FM_RESERVED                0x00080000 /* The size reserved */
+
+#endif // __EMHWLIB_DRAM_OTHERS_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_others.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_others.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_others.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_others.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,25 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_others.inc (generated from emhwlib/include/emhwlib_dram_others.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_IRQHANDLER_CODE=0x11000
+FM_IRQHANDLER_STACKTOP_USR=0x40000
+FM_IRQHANDLER_STACKTOP_IRQ=0x48000
+FM_IRQHANDLER_STACKTOP_FIQ=0x50000
+FM_STACKTOP_SVC=0x58000
+FM_DRM=0x58000
+FM_GNET=0x58000
+FM_BOOTLOADER_CODE=0x60000
+FM_RESERVED=0x80000
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_tango3.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_tango3.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_tango3.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_tango3.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,49 @@
+/*****************************************
+ Copyright  2004-2005
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   emhwlib_dram_tango2.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed that computing
+  FM_Y-FM_X is a proper way to access the max usable size for FM_X.
+
+  See SMP8630 software spec 3.3
+
+  @author Emmanuel Michon, YH Lin, Julien Soulier
+  @date   2005-04-06
+*/
+
+#ifndef __EMHWLIB_DRAM_TANGO2_H__
+#define __EMHWLIB_DRAM_TANGO2_H__
+
+/* Spec 3.3.5: stage (S4) [fully functional player memory map] */
+#define FM_GNET                    0x00000000
+#define FM_SCRATCH                 0x00000f08 /* 184 bytes */
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_XTASK_API               0x00009e00 /* 512 bytes */
+#define FM_XOSDBG                  0x0000a000
+#define FM_XTASK1DBG               0x0000c000
+#define FM_XTASK2DBG               0x0000d000
+#define FM_XTASK3DBG               0x0000e000
+#define FM_XTASK4DBG               0x0000f000
+#define FM_SCRATCH2                0x00010000
+#define FM_DRAMCALIBRATION         0x0001f000
+#define FM_RESERVED                0x00020000
+
+/*
+  Spec 3.3.5: stage (S0) [bootstrap memory map]
+
+  Because you will use zboot/yamon to download linux/CE
+  at start of DRAM, the former are away from beginning.
+*/
+#define FM_ZBOOT                   0x01000000
+#define FM_YAMON_text_ram          0x01000000
+#define FM_YAMON__ftext_init       0x01200000
+#define FM_yamon_appl__ftext       0x01210000
+#define FM_linuxmips__ftext        0x00020000
+
+#endif // __EMHWLIB_DRAM_TANGO2_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_tango3.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_tango3.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_dram_tango3.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_dram_tango3.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,32 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_tango2.inc (generated from emhwlib/include/emhwlib_dram_tango2.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_GNET=0x0
+FM_SCRATCH=0xf08
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_XTASK_API=0x9e00
+FM_XOSDBG=0xa000
+FM_XTASK1DBG=0xc000
+FM_XTASK2DBG=0xd000
+FM_XTASK3DBG=0xe000
+FM_XTASK4DBG=0xf000
+FM_SCRATCH2=0x10000
+FM_DRAMCALIBRATION=0x1f000
+FM_RESERVED=0x20000
+FM_ZBOOT=0x1000000
+FM_YAMON_text_ram=0x1000000
+FM_YAMON__ftext_init=0x1200000
+FM_yamon_appl__ftext=0x1210000
+FM_linuxmips__ftext=0x20000
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,46 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Emmanuel Michon
+  @date   2005-03-17
+*/
+
+#ifndef __EMHWLIB_LRAM_H__
+#define __EMHWLIB_LRAM_H__
+
+#if (EM86XX_CHIP<EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_others.h"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_tango3.h"
+#else
+#error EM86XX_CHIP is not set in RMCFLAGS: refer to rmdef/rmem86xxid.h. 
+#endif
+
+#endif // __EMHWLIB_LRAM_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,41 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram.inc (generated from emhwlib_hal/include/emhwlib_lram.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x1800
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_others.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_others.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_others.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_others.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,98 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_others.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_OTHERS_H__
+#define __EMHWLIB_LRAM_OTHERS_H__
+
+#define LR_CPU_IDLELOOP          0x00000000 /* CPU uses 0x80 bytes, up to 0x0080 */
+#define LR_UCLINUX_END           0x00000100
+
+#define LR_VSYNC_STRUCT          0x00000200 /* 2KB of data structures */
+#define LR_VSYNC_CODE            0x00000a00 /* 2KB of code */
+#define LR_VSYNC_END             0x00001200
+
+#define LR_STACKTOP              0x000017F4 /* in case a bootstrap routine needs a stack in local ram. Use this boundary */
+
+#define LR_PCI_INTERRUPT_ENABLE  0x000017F4
+#define LR_HOST_INTERRUPT_STATUS 0x000017F8
+#define LR_CPU_BRU_JUMP          0x000017FC /* `bootrom_ucos jump' (debug purpose) */
+
+#define LR_MU_PROFILE_STATUS     0x00001800
+
+#define LR_DRAM_DMA_SUSPEND               0x00001c8c
+#define LR_SUSPEND_ACK_MPEG0              0x00001c90
+#define LR_SUSPEND_ACK_MPEG1              0x00001c94
+#define LR_SUSPEND_ACK_AUDIO0             0x00001c98
+#define LR_SUSPEND_ACK_AUDIO1             0x00001c9c
+#define LR_SUSPEND_ACK_DEMUX              0x00001ca0
+#define LR_SUSPEND_ACK_IH                 0x00001ca4
+
+#define LR_HB_IH                 0x00001ca8
+
+#define LR_IH_LOG_FIFO           0x00001cac /* in some cases (splash screen) find the location of the log_fifo is not that easy. Read it here. */
+
+#define LR_HB_HOST               0x00001cb0
+#define LR_HB_CPU                0x00001cb4
+#define LR_HB_MPEG0              0x00001cb8
+#define LR_HB_MPEG1              0x00001cbc
+#define LR_HB_AUDIO0             0x00001cc0
+#define LR_HB_AUDIO1             0x00001cc4
+#define LR_HB_DEMUX              0x00001cc8
+#define LR_HB_XPU                0x00001ccc
+
+#define LR_IDMA                  0x00001cd0 /* 16bytes. Obsoletizes LR_HMMAD */
+
+#define LR_ETH_MAC_LO            0x00001ce0 /* Ethernet MAC addr low 4 bytes */
+#define LR_ETH_MAC_HI            0x00001ce4 /* Ethernet MAC addr high bytes */
+#define LR_HB_VSYNC              0x00001ce8
+ 
+#define LR_SW_VAL_VSYNC_COUNT    0x00001cec /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x00001cf0 /* this location is used to store a pixel address to write the frame count */
+
+#define LR_HMMAD                 0x00001cf4
+#define LR_KEY_ZONE              0x00001D00 /* 0x200 bytes, up to 0x1F00 */
+#define LR_YAMON_DIGITS          0x00001F00
+#define LR_XPU_DUMP              0x00001F00 /* 0x80 bytes, up to 0x1F80 */
+
+#define LR_VSYNC_PERIOD          0x00001FA0 /* 0x20 bytes, up to 0x1FC0 */
+
+#define LR_RANDOM_SEED           0x00001FC8 /* 0x08 bytes, up to 0x1FD0 */
+#define LR_LOCAL_DEBUG_PROBE     0x00001FD0 /* 0x20 bytes, up to 0x1FF0 */
+
+#define LR_XENV_LOCATION         0x00001FF0 /* Location of XENV, found by XOS */
+#define LR_GNET_MAC              0x00001FF4
+#define LR_ZBOOT_STAGE           0x00001FF8
+#define LR_XPU_STAGE             0x00001FFC
+
+#endif // __EMHWLIB_LRAM_OTHERS_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_others.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_others.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_others.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_others.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,58 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram_others.inc (generated from emhwlib_hal/include/emhwlib_lram_others.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_CPU_IDLELOOP=0x0
+LR_UCLINUX_END=0x100
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x17f4
+LR_PCI_INTERRUPT_ENABLE=0x17f4
+LR_HOST_INTERRUPT_STATUS=0x17f8
+LR_CPU_BRU_JUMP=0x17fc
+LR_MU_PROFILE_STATUS=0x1800
+LR_DRAM_DMA_SUSPEND=0x1c8c
+LR_SUSPEND_ACK_MPEG0=0x1c90
+LR_SUSPEND_ACK_MPEG1=0x1c94
+LR_SUSPEND_ACK_AUDIO0=0x1c98
+LR_SUSPEND_ACK_AUDIO1=0x1c9c
+LR_SUSPEND_ACK_DEMUX=0x1ca0
+LR_SUSPEND_ACK_IH=0x1ca4
+LR_HB_IH=0x1ca8
+LR_IH_LOG_FIFO=0x1cac
+LR_HB_HOST=0x1cb0
+LR_HB_CPU=0x1cb4
+LR_HB_MPEG0=0x1cb8
+LR_HB_MPEG1=0x1cbc
+LR_HB_AUDIO0=0x1cc0
+LR_HB_AUDIO1=0x1cc4
+LR_HB_DEMUX=0x1cc8
+LR_HB_XPU=0x1ccc
+LR_IDMA=0x1cd0
+LR_ETH_MAC_LO=0x1ce0
+LR_ETH_MAC_HI=0x1ce4
+LR_HB_VSYNC=0x1ce8
+LR_SW_VAL_VSYNC_COUNT=0x1cec
+LR_SW_VAL_PIXEL_ADDR=0x1cf0
+LR_HMMAD=0x1cf4
+LR_KEY_ZONE=0x1d00
+LR_YAMON_DIGITS=0x1f00
+LR_XPU_DUMP=0x1f00
+LR_VSYNC_PERIOD=0x1fa0
+LR_RANDOM_SEED=0x1fc8
+LR_LOCAL_DEBUG_PROBE=0x1fd0
+LR_XENV_LOCATION=0x1ff0
+LR_GNET_MAC=0x1ff4
+LR_ZBOOT_STAGE=0x1ff8
+LR_XPU_STAGE=0x1ffc
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_tango3.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_tango3.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_tango3.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_tango3.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,98 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_tango3.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_TANGO3_H__
+#define __EMHWLIB_LRAM_TANGO3_H__
+
+/*
+  Leaving 2.3KB to for some startup code and stack
+  
+  as long as the value of this symbol moves only up with time, backward compatibility is ok */
+#define LR_STACKTOP              0x00000900
+
+#define LR_VSYNC_STRUCT          0x00000900
+
+/*
+  shortcoming to be address with first hw releases
+ */
+#define LR_SHUTTLE_STACKTOP      0x00001800
+
+#define LR_VSYNC_STRUCT_END      0x00001900
+
+/*
+  range from LR_STACKTOP to the first of the below block is 
+  reserved for future use (~100 slots)
+ */
+
+
+
+/* To be approved. */
+#define LR_IDMA                  0x00001968 /* 16bytes. Obsoletizes LR_HMMAD */
+/* To be approved. */
+#define LR_VSYNC_PERIOD          0x00001978 /* 0x20 bytes, up to 0x1998 */
+
+
+#define LR_ZBOOTXENV_LOCATION    0x00001994
+#define LR_BAT_D0                0x00001998
+#define LR_BAT_D1                0x0000199c
+#define LR_BAT_D2                0x000019a0
+#define LR_CHANNEL_INDEX         0x000019a4
+#define LR_HB_IPU                0x000019a8
+#define LR_PCI_INTERRUPT_ENABLE  0x000019ac
+#define LR_HOST_INTERRUPT_STATUS 0x000019b0
+#define LR_DRAM_DMA_SUSPEND      0x000019b4
+#define LR_SUSPEND_ACK_MPEG0     0x000019b8
+#define LR_SUSPEND_ACK_MPEG1     0x000019bc
+#define LR_SUSPEND_ACK_AUDIO0    0x000019c0
+#define LR_SUSPEND_ACK_AUDIO1    0x000019c4
+#define LR_SUSPEND_ACK_DEMUX     0x000019c8
+#define LR_SUSPEND_ACK_IH        0x000019cc
+#define LR_HB_IH                 0x000019d0
+#define LR_HB_HOST               0x000019d4
+#define LR_HB_CPU                0x000019d8
+#define LR_HB_MPEG0              0x000019dc
+#define LR_HB_MPEG1              0x000019e0
+#define LR_HB_AUDIO0             0x000019e4
+#define LR_HB_AUDIO1             0x000019e8
+#define LR_HB_DEMUX              0x000019ec
+#define LR_HB_XPU                0x000019f0
+#define LR_HB_VSYNC              0x000019f4
+#define LR_SW_VAL_VSYNC_COUNT    0x000019f8 /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x000019fc /* this location is used to store a pixel address to write the frame count */
+
+#define LR_XENV2_RW              0x00001a00 /* up to 768 bytes */
+
+#define LR_XENV2_RO              0x00001d00 /* up to the end, 768 bytes. This area is written by xpu, r.o. for others */
+
+#endif // __EMHWLIB_LRAM_TANGO3_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_tango3.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_tango3.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_lram_tango3.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_lram_tango3.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,43 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram_tango3.inc (generated from emhwlib_hal/include/emhwlib_lram_tango3.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x1800
+LR_CHANNEL_INDEX=0x19a4
+LR_HB_IPU=0x19a8
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_registers_tango3.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_registers_tango3.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_registers_tango3.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_registers_tango3.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,758 @@
+/******************************************************/
+/* This file is generated automatically, DO NOT EDIT! */
+/******************************************************/
+/*
+ * ../emhwlib_hal/include/tango3/emhwlib_registers_tango3.h
+ *
+ * Copyright (c) 2001-2007 Sigma Designs, Inc. 
+ * All Rights Reserved. 
+ *
+ */
+ 
+/**
+  @file ../emhwlib_hal/include/tango3/emhwlib_registers_tango3.h
+  @brief emhwlib generated file
+   
+  @author Jacques Mahe, Christian Wolff, Julien Soulier, Emmanuel Michon
+  @ingroup hwlproperties
+*/
+
+#ifndef __EMHWLIB_REGISTERS_TANGO3_H__
+#define __EMHWLIB_REGISTERS_TANGO3_H__
+
+/* SystemBlock registers */
+#define REG_BASE_system_block 0x00010000 /* width RMuint32 */
+#define SYS_clkgen0_pll 0x0000 /* width RMuint32 */
+#define SYS_clkgen0_div 0x0004 /* width RMuint32 */
+#define SYS_clkgen1_pll 0x0008 /* width RMuint32 */
+#define SYS_clkgen1_div 0x000C /* width RMuint32 */
+#define SYS_clkgen2_pll 0x0010 /* width RMuint32 */
+#define SYS_clkgen2_div 0x0014 /* width RMuint32 */
+#define SYS_clkgen3_pll 0x0018 /* width RMuint32 */
+#define SYS_clkgen3_div 0x001C /* width RMuint32 */
+#define SYS_avclk_mux 0x0038 /* width RMuint32 */
+#define SYS_sysclk_mux 0x003C /* width RMuint32 */
+#define SYS_clk_cnt 0x0040 /* width RMuint32 */
+#define SYS_xtal_in_cnt 0x0048 /* width RMuint32 */
+#define DRAM_vbus_w0_cfg 0x0300 /* width RMuint32 */
+#define DRAM_vbus_w1_cfg 0x0304 /* width RMuint32 */
+#define DRAM_vbus_w2_cfg 0x0308 /* width RMuint32 */
+#define DRAM_vbus_w3_cfg 0x030c /* width RMuint32 */
+#define DRAM_vbus_r0_cfg 0x0340 /* width RMuint32 */
+#define DRAM_vbus_r1_cfg 0x0344 /* width RMuint32 */
+#define DRAM_vbus_r2_cfg 0x0348 /* width RMuint32 */
+#define DRAM_vbus_r3_cfg 0x034c /* width RMuint32 */
+#define DRAM_vbus_r4_cfg 0x0350 /* width RMuint32 */
+#define DRAM_vbus_r5_cfg 0x0354 /* width RMuint32 */
+#define DRAM_vbus_r6_cfg 0x0358 /* width RMuint32 */
+#define DRAM_vbus_r7_cfg 0x035c /* width RMuint32 */
+#define DRAM_vbus_r8_cfg 0x0360 /* width RMuint32 */
+#define DRAM_vbus_r9_cfg 0x0364 /* width RMuint32 */
+#define DRAM_vbus_r10_cfg 0x0368 /* width RMuint32 */
+#define DRAM_vbus_r11_cfg 0x036c /* width RMuint32 */
+#define DRAM_mbus_w0_cfg 0x0200 /* width RMuint32 */
+#define DRAM_mbus_w1_cfg 0x0204 /* width RMuint32 */
+#define DRAM_mbus_w2_cfg 0x0208 /* width RMuint32 */
+#define DRAM_mbus_w3_cfg 0x020c /* width RMuint32 */
+#define DRAM_mbus_w4_cfg 0x0210 /* width RMuint32 */
+#define DRAM_mbus_w5_cfg 0x0214 /* width RMuint32 */
+#define DRAM_mbus_w6_cfg 0x0218 /* width RMuint32 */
+#define DRAM_mbus_w7_cfg 0x021c /* width RMuint32 */
+#define DRAM_mbus_w8_cfg 0x0220 /* width RMuint32 */
+#define DRAM_mbus_w9_cfg 0x0224 /* width RMuint32 */
+#define DRAM_mbus_w10_cfg 0x0228 /* width RMuint32 */
+#define DRAM_mbus_r0_cfg 0x0240 /* width RMuint32 */
+#define DRAM_mbus_r1_cfg 0x0244 /* width RMuint32 */
+#define DRAM_mbus_r2_cfg 0x0248 /* width RMuint32 */
+#define DRAM_mbus_r3_cfg 0x024c /* width RMuint32 */
+#define DRAM_mbus_r4_cfg 0x0250 /* width RMuint32 */
+#define DRAM_mbus_r5_cfg 0x0254 /* width RMuint32 */
+#define DRAM_mbus_r6_cfg 0x0258 /* width RMuint32 */
+#define DRAM_mbus_r7_cfg 0x025c /* width RMuint32 */
+#define DRAM_mbus_r8_cfg 0x0260 /* width RMuint32 */
+#define DRAM_mbus_r9_cfg 0x0264 /* width RMuint32 */
+#define DRAM_mbus_r10_cfg 0x0268 /* width RMuint32 */
+#define SYS_hostclk_mux 0x0030 /* width RMuint32 */
+#define SYS_sysclk_premux 0x0034 /* width RMuint32 */
+#define SYS_rnd_cnt 0x0044 /* width RMuint32 */
+#define SYS_cnt_cfg 0x004c /* width RMuint32 */
+#define SYS_cfg_cnt0 0x0050 /* width RMuint32 */
+#define SYS_cfg_cnt1 0x0054 /* width RMuint32 */
+#define SYS_cfg_cnt2 0x0058 /* width RMuint32 */
+#define SYS_cfg_cnt3 0x005c /* width RMuint32 */
+#define SYS_cfg_cnt4 0x0060 /* width RMuint32 */
+#define SYS_cleandiv0_div 0x0080 /* width RMuint32 */
+#define SYS_cleandiv1_div 0x0088 /* width RMuint32 */
+#define SYS_cleandiv2_div 0x0090 /* width RMuint32 */
+#define SYS_cleandiv3_div 0x0098 /* width RMuint32 */
+#define SYS_cleandiv4_div 0x00a0 /* width RMuint32 */
+#define SYS_cleandiv5_div 0x00a8 /* width RMuint32 */
+#define SYS_cleandiv6_div 0x00b0 /* width RMuint32 */
+#define SYS_cleandiv7_div 0x00b8 /* width RMuint32 */
+#define SYS_cleandiv8_div 0x00c0 /* width RMuint32 */
+#define SYS_cleandiv9_div 0x00c8 /* width RMuint32 */
+#define SYS_cleandiv10_div 0x00d0 /* width RMuint32 */
+#define SYS_watchdog_counter 0xfd00 /* width RMuint32 */
+#define SYS_watchdog_configuration 0xfd04 /* width RMuint32 */
+#define MARB_mid01_cfg 0x0200 /* width RMuint32 */
+#define MARB_mid21_cfg 0x0204 /* width RMuint32 */
+#define MARB_mid02_cfg 0x0208 /* width RMuint32 */
+#define MARB_mid22_cfg 0x020c /* width RMuint32 */
+#define MARB_mid03_cfg 0x0210 /* width RMuint32 */
+#define MARB_mid23_cfg 0x0214 /* width RMuint32 */
+#define MARB_mid04_cfg 0x0218 /* width RMuint32 */
+#define MARB_mid24_cfg 0x021c /* width RMuint32 */
+#define MARB_mid25_cfg 0x0220 /* width RMuint32 */
+#define MARB_mid08_cfg 0x0224 /* width RMuint32 */
+#define MARB_mid28_cfg 0x0228 /* width RMuint32 */
+#define MARB_mid29_cfg 0x022c /* width RMuint32 */
+#define MARB_mid0C_cfg 0x0230 /* width RMuint32 */
+#define MARB_mid2C_cfg 0x0234 /* width RMuint32 */
+#define MARB_mid0E_cfg 0x0238 /* width RMuint32 */
+#define MARB_mid2E_cfg 0x023c /* width RMuint32 */
+#define MARB_mid10_cfg 0x0240 /* width RMuint32 */
+#define MARB_mid30_cfg 0x0244 /* width RMuint32 */
+#define MARB_mid14_cfg 0x0248 /* width RMuint32 */
+#define MARB_mid34_cfg 0x024c /* width RMuint32 */
+#define MARB_mid05_cfg 0x0250 /* width RMuint32 */
+#define MARB_mid26_cfg 0x0254 /* width RMuint32 */
+#define MARB_mid09_cfg 0x0258 /* width RMuint32 */
+#define MARB_mid2A_cfg 0x025c /* width RMuint32 */
+#define MARB_mid06_cfg 0x0260 /* width RMuint32 */
+#define MARB_mid0A_cfg 0x0264 /* width RMuint32 */
+#define MARB_mid1C_cfg 0x0268 /* width RMuint32 */
+#define MARB_mid3C_cfg 0x026c /* width RMuint32 */
+#define VARB_mid01_cfg 0x0300 /* width RMuint32 */
+#define VARB_mid02_cfg 0x0304 /* width RMuint32 */
+#define VARB_mid21_cfg 0x0308 /* width RMuint32 */
+#define VARB_mid22_cfg 0x030c /* width RMuint32 */
+#define VARB_mid23_cfg 0x0310 /* width RMuint32 */
+#define VARB_mid24_cfg 0x0314 /* width RMuint32 */
+#define VARB_mid25_cfg 0x0318 /* width RMuint32 */
+#define VARB_mid26_cfg 0x031c /* width RMuint32 */
+#define VARB_mid27_cfg 0x0320 /* width RMuint32 */
+#define VARB_mid28_cfg 0x0324 /* width RMuint32 */
+#define VARB_mid29_cfg 0x0328 /* width RMuint32 */
+#define VARB_mid2A_cfg 0x032c /* width RMuint32 */
+#define VARB_mid10_cfg 0x0330 /* width RMuint32 */
+#define VARB_mid30_cfg 0x0334 /* width RMuint32 */
+#define VARB_mid31_cfg 0x0338 /* width RMuint32 */
+#define VARB_mid03_cfg 0x033c /* width RMuint32 */
+#define IARB_mid01_cfg 0x0400 /* width RMuint32 */
+#define IARB_mid02_cfg 0x0404 /* width RMuint32 */
+#define SYS_gpio_dir 0x0500 /* width RMuint32 */
+#define SYS_gpio_data 0x0504 /* width RMuint32 */
+#define SYS_gpio_int 0x0508 /* width RMuint32 */
+#define SYS_gpio15_pwm 0x0510 /* width RMuint32 */
+#define SYS_gpio14_pwm 0x0514 /* width RMuint32 */
+#define REG_BASE_dram_controller_0 0x00030000 /* width RMuint32 */
+#define REG_BASE_dram_controller_1 0x00040000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0_alias 0x10000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0 0x80000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1_alias 0x20000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1 0xc0000000 /* width RMuint32 */
+#define DRAM_dunit_cfg 0x0000 /* width RMuint32 */
+#define DRAM_dunit_delay0_ctrl 0x0004 /* width RMuint32 */
+#define DRAM_dunit_delay1_ctrl 0x0008 /* width RMuint32 */
+#define DRAM_dunit_auto_delay 0x000c /* width RMuint32 */
+#define DRAM_dunit_fall_delay0 0x0010 /* width RMuint32 */
+#define DRAM_dunit_fall_delay1 0x0014 /* width RMuint32 */
+#define DRAM_dunit_bw_lobound 0x0018 /* width RMuint32 */
+#define DRAM_dunit_bw_hibound 0x001c /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cfg 0x0020 /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cnt 0x0024 /* width RMuint32 */
+#define DRAM_dunit_bw_cntall 0x0028 /* width RMuint32 */
+#define DRAM_dunit_calibration_delay 0x0030 /* width RMuint32 */
+#define DRAM_dunit_calibration_rise_err 0x0034 /* width RMuint32 */
+#define DRAM_dunit_calibration_fall_err 0x0038 /* width RMuint32 */
+#define DRAM_dunit_calibration_page 0x0088 /* width RMuint32 */
+#define DRAM_dunit_flush_buffer 0x0104 /* width RMuint32 */
+#define REG_BASE_host_interface 0x00020000 /* width RMuint32 */
+#define MEM_BASE_host_interface 0x40000000 /* width RMuint32 */
+#define IDE_data 0x0000 /* width RMuint32 */
+#define IDE_error 0x0004 /* width RMuint32 */
+#define IDE_count 0x0008 /* width RMuint32 */
+#define IDE_start_sector 0x000c /* width RMuint32 */
+#define IDE_cylinder_lo 0x0010 /* width RMuint32 */
+#define IDE_cylinder_hi 0x0014 /* width RMuint32 */
+#define IDE_head_device 0x0018 /* width RMuint32 */
+#define IDE_cmd_stat 0x001c /* width RMuint32 */
+#define IDE_irq_stat 0x0218 /* width RMuint32 */
+#define IDE_cmd_stat__ 0x021c /* width RMuint32 */
+#define PB_timing0 0x0800 /* width RMuint32 */
+#define PB_timing1 0x0804 /* width RMuint32 */
+#define PB_timing2 0x0808 /* width RMuint32 */
+#define PB_timing3 0x080c /* width RMuint32 */
+#define PB_timing4 0x0810 /* width RMuint32 */
+#define PB_timing5 0x0814 /* width RMuint32 */
+#define PB_default_timing 0x0818 /* width RMuint32 */
+#define PB_use_timing0 0x081c /* width RMuint32 */
+#define PB_use_timing1 0x0820 /* width RMuint32 */
+#define PB_use_timing2 0x0824 /* width RMuint32 */
+#define PB_use_timing3 0x0828 /* width RMuint32 */
+#define PB_use_timing4 0x082c /* width RMuint32 */
+#define PB_use_timing5 0x0830 /* width RMuint32 */
+#define PB_CS_config 0x0834 /* width RMuint32 */
+#define PB_automode_start_address 0x0840 /* width RMuint32 */
+#define PB_automode_control 0x0844 /* width RMuint32 */
+#define EMHWLIB_IS_HOST 0xe000 /* width RMuint32 */
+#define HOST_REG1 0xfed0 /* width RMuint32 */
+#define HOST_REG2 0xfed4 /* width RMuint32 */
+#define READ_ADDRESS 0xfec0 /* width RMuint32 */
+#define READ_COUNTER 0xfec4 /* width RMuint32 */
+#define READ_ENABLE 0xfec8 /* width RMuint32 */
+#define REV_ORDER 0xfecc /* width RMuint32 */
+#define WRITE_ADDRESS 0xfed8 /* width RMuint32 */
+#define WRITE_COUNTER 0xfedc /* width RMuint32 */
+#define WRITE_ENABLE 0xfee0 /* width RMuint32 */
+#define BURST 0xfee4 /* width RMuint32 */
+#define PCI_TIMEOUT 0x8000 /* width RMuint32 */
+#define PCI_TIMEOUT_STATUS 0x8004 /* width RMuint32 */
+#define PCI_TIMER 0x8008 /* width RMuint32 */
+#define PCI_TIMER_TEST 0x800c /* width RMuint32 */
+#define PCI_WAKEUP 0x8010 /* width RMuint32 */
+#define PCI_REGION_0_BASE 0x9000 /* width RMuint32 */
+#define PCI_REGION_1_BASE 0x9004 /* width RMuint32 */
+#define PCI_REGION_2_BASE 0x9008 /* width RMuint32 */
+#define PCI_REGION_3_BASE 0x900c /* width RMuint32 */
+#define PCI_REGION_4_BASE 0x9010 /* width RMuint32 */
+#define PCI_REGION_5_BASE 0x9014 /* width RMuint32 */
+#define PCI_REGION_6_BASE 0x9018 /* width RMuint32 */
+#define PCI_REGION_7_BASE 0x901c /* width RMuint32 */
+#define PCI_irq_status 0x9020 /* width RMuint32 */
+#define PCI_irq_set 0x9024 /* width RMuint32 */
+#define PCI_irq_clear 0x9028 /* width RMuint32 */
+#define SBOX_FIFO_RESET 0x90a0 /* width RMuint32 */
+#define SBOX_FIFO_RESET2 0x90a4 /* width RMuint32 */
+#define SBOX_ROUTE 0x90a8 /* width RMuint32 */
+#define SBOX_ROUTE2 0x90ac /* width RMuint32 */
+#define output_SBOX_MBUS_W0 0x9080 /* width RMuint32 */
+#define output_SBOX_MBUS_W1 0x9084 /* width RMuint32 */
+#define output_SBOX_PCI_MASTER 0x9088 /* width RMuint32 */
+#define output_SBOX_PCI_SLAVE 0x908c /* width RMuint32 */
+#define output_SBOX_SATA 0x9090 /* width RMuint32 */
+#define output_SBOX_IDE_ISA 0x9094 /* width RMuint32 */
+#define output_SBOX_IDE_DVD 0x9098 /* width RMuint32 */
+#define output_SBOX_SATA2 0x909c /* width RMuint32 */
+#define output_SBOX_MBUS_W2 0x90b0 /* width RMuint32 */
+#define input_keep_SBOX 0 /* width RMuint32 */
+#define input_MBUS_R0_SBOX 1 /* width RMuint32 */
+#define input_MBUS_R1_SBOX 2 /* width RMuint32 */
+#define input_PCI_MASTER_SBOX 3 /* width RMuint32 */
+#define input_PCI_SLAVE_SBOX 4 /* width RMuint32 */
+#define input_SATA_SBOX 5 /* width RMuint32 */
+#define input_IDE_ISA_SBOX 6 /* width RMuint32 */
+#define input_IDE_DVD_SBOX 7 /* width RMuint32 */
+#define input_SATA2_SBOX 8 /* width RMuint32 */
+#define input_MBUS_R2_SBOX 9 /* width RMuint32 */
+#define input_unconnected_SBOX 0xf /* width RMuint32 */
+#define host_mutex0 0x9040 /* width RMuint32 */
+#define host_mutex1 0x9044 /* width RMuint32 */
+#define host_mutex2 0x9048 /* width RMuint32 */
+#define host_mutex3 0x904c /* width RMuint32 */
+#define host_mutex4 0x9050 /* width RMuint32 */
+#define host_mutex5 0x9054 /* width RMuint32 */
+#define host_mutex6 0x9058 /* width RMuint32 */
+#define host_mutex7 0x905c /* width RMuint32 */
+#define host_mutex8 0x9060 /* width RMuint32 */
+#define host_mutex9 0x9064 /* width RMuint32 */
+#define host_mutex10 0x9068 /* width RMuint32 */
+#define host_mutex11 0x906c /* width RMuint32 */
+#define host_mutex12 0x9070 /* width RMuint32 */
+#define host_mutex13 0x9074 /* width RMuint32 */
+#define host_mutex14 0x9078 /* width RMuint32 */
+#define host_mutex15 0x907c /* width RMuint32 */
+#define PCI_host_reg5 0xfe94 /* width RMuint32 */
+#define PCI_chip_is_host 0xfe90 /* width RMuint32 */
+#define IDECTRL_idesrc 0x20d0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim1 0x20e0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim2 0x20f0 /* width RMuint32 */
+#define IDECTRL_pri_idectl 0x2100 /* width RMuint32 */
+#define IDECTRL_pri_drv0tim 0x2110 /* width RMuint32 */
+#define IDECTRL_pri_drv1tim 0x2120 /* width RMuint32 */
+#define IDECTRL_idemisc 0x2130 /* width RMuint32 */
+#define IDECTRL_idestatus 0x2140 /* width RMuint32 */
+#define IDECTRL_udmactl 0x2150 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim1 0x2160 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim2 0x2170 /* width RMuint32 */
+#define IDECTRL_pref_st 0x2310 /* width RMuint32 */
+#define IDECTRL_pri_ctrlblock 0x2398 /* width RMuint32 */
+#define IDECTRL_pri_cmdblock 0x23c0 /* width RMuint32 */
+#define IDECTRL_bmic 0x2400 /* width RMuint32 */
+#define IDECTRL_bmis 0x2410 /* width RMuint32 */
+#define IDECTRL_bmidtp 0x2420 /* width RMuint32 */
+#define IDECTRL_ide_dmaptr 0x2780 /* width RMuint32 */
+#define IDECTRL_ide_dmalen 0x2790 /* width RMuint32 */
+#define IDECTRL_pio_prefetch_data 0x27c0 /* width RMuint32 */
+#define MEM_BASE_pfla 0x40000000 /* width RMuint32 */
+#define PB_CS0_OFFSET 0x00000000 /* width RMuint32 */
+#define PB_CS1_OFFSET 0x04000000 /* width RMuint32 */
+#define PB_CS2_OFFSET 0x08000000 /* width RMuint32 */
+#define PB_CS3_OFFSET 0x0c000000 /* width RMuint32 */
+#define ETH_gpio_dir1 0x7100 /* width RMuint32 */
+#define ETH_gpio_data1 0x7104 /* width RMuint32 */
+#define ETH_gpio_mask1 0x7108 /* width RMuint32 */
+#define ETH_gpio_dir2 0x710c /* width RMuint32 */
+#define ETH_gpio_data2 0x7110 /* width RMuint32 */
+#define PB_CS_config1 0x0838 /* width RMuint32 */
+#define PB_CS_ctrl 0x083c /* width RMuint32 */
+#define PB_strap_ctrl 0x0880 /* width RMuint32 */
+#define PB_strap0 0x0884 /* width RMuint32 */
+#define PB_strap1 0x0888 /* width RMuint32 */
+#define PB_ECC_code0 0x08c0 /* width RMuint32 */
+#define PB_ECC_code1 0x08c4 /* width RMuint32 */
+#define PB_ECC_code2 0x08c8 /* width RMuint32 */
+#define PB_ECC_code3 0x08cc /* width RMuint32 */
+#define PB_ECC_clear 0x08d0 /* width RMuint32 */
+#define MIF_W2_ADD 0xb100 /* width RMuint32 */
+#define MIF_W2_CNT 0xb104 /* width RMuint32 */
+#define MIF_W2_SKIP 0xb108 /* width RMuint32 */
+#define MIF_W2_CMD 0xb10c /* width RMuint32 */
+#define MIF_R2_ADD 0xb140 /* width RMuint32 */
+#define MIF_R2_CNT 0xb144 /* width RMuint32 */
+#define MIF_R2_SKIP 0xb148 /* width RMuint32 */
+#define MIF_R2_CMD 0xb14c /* width RMuint32 */
+#define PCI_host_reg1 0xfed0 /* width RMuint32 */
+#define PCI_host_reg2 0xfed4 /* width RMuint32 */
+#define PCI_host_reg3 0xfe80 /* width RMuint32 */
+#define PCI_host_reg4 0xfe84 /* width RMuint32 */
+#define PCI_pcictrl_reg1 0xfe88 /* width RMuint32 */
+#define PCI_pcictrl_reg2 0xfe8c /* width RMuint32 */
+#define PCI_pcictrl_reg3 0xfefc /* width RMuint32 */
+#define PCI_REG0 0xfee8 /* width RMuint32 */
+#define PCI_REG1 0xfeec /* width RMuint32 */
+#define PCI_REG2 0xfef0 /* width RMuint32 */
+#define PCI_REG3 0xfef4 /* width RMuint32 */
+#define PCI_CONFIG 0xfef8 /* width RMuint32 */
+#define MIF_W0_ADD 0xb000 /* width RMuint32 */
+#define MIF_W0_CNT 0xb004 /* width RMuint32 */
+#define MIF_W0_SKIP 0xb008 /* width RMuint32 */
+#define MIF_W0_CMD 0xb00c /* width RMuint32 */
+#define MIF_W1_ADD 0xb040 /* width RMuint32 */
+#define MIF_W1_CNT 0xb044 /* width RMuint32 */
+#define MIF_W1_SKIP 0xb048 /* width RMuint32 */
+#define MIF_W1_CMD 0xb04c /* width RMuint32 */
+#define MIF_R0_ADD 0xb080 /* width RMuint32 */
+#define MIF_R0_CNT 0xb084 /* width RMuint32 */
+#define MIF_R0_SKIP 0xb088 /* width RMuint32 */
+#define MIF_R0_CMD 0xb08c /* width RMuint32 */
+#define MIF_R1_ADD 0xb0c0 /* width RMuint32 */
+#define MIF_R1_CNT 0xb0c4 /* width RMuint32 */
+#define MIF_R1_SKIP 0xb0c8 /* width RMuint32 */
+#define MIF_R1_CMD 0xb0cc /* width RMuint32 */
+#define MBUS_IDLE 0 /* width RMuint32 */
+#define MBUS_LINEAR 1 /* width RMuint32 */
+#define MBUS_DOUBLE 2 /* width RMuint32 */
+#define MBUS_RECTANGLE 3 /* width RMuint32 */
+#define MBUS_VOID 4 /* width RMuint32 */
+#define MBUS_LINEAR_VOID 5 /* width RMuint32 */
+#define MBUS_DOUBLE_VOID 6 /* width RMuint32 */
+#define MBUS_RECTANGLE_VOID 7 /* width RMuint32 */
+#define MBUS_TILED 8 /* width RMuint32 */
+#define GBUS_MUTEX_XPU 0x14 /* width RMuint32 */
+#define GBUS_MUTEX_PT110 0x16 /* width RMuint32 */
+#define GBUS_MUTEX_TDMX 0x19 /* width RMuint32 */
+#define GBUS_MUTEX_AUDIO_0 0x1b /* width RMuint32 */
+#define GBUS_MUTEX_AUDIO_1 0x1c /* width RMuint32 */
+#define GBUS_MUTEX_MPEG_0 0x1d /* width RMuint32 */
+#define GBUS_MUTEX_MPEG_1 0x1e /* width RMuint32 */
+#define GBUS_MUTEX_HOST 0x1f /* width RMuint32 */
+#define GBUS_MUTEX_LOCAL 0x10 /* width RMuint32 */
+/* SystemBlock registers done */
+
+/* CPUBlock registers */
+#define REG_BASE_cpu_block 0x00060000 /* width RMuint32 */
+#define CPU_time0_load 0xc500 /* width RMuint32 */
+#define CPU_time0_value 0xc504 /* width RMuint32 */
+#define CPU_time0_ctrl 0xc508 /* width RMuint32 */
+#define CPU_time0_clr 0xc50c /* width RMuint32 */
+#define CPU_time1_load 0xc600 /* width RMuint32 */
+#define CPU_time1_value 0xc604 /* width RMuint32 */
+#define CPU_time1_ctrl 0xc608 /* width RMuint32 */
+#define CPU_time1_clr 0xc60c /* width RMuint32 */
+#define CPU_rtc_data 0xc800 /* width RMuint32 */
+#define CPU_rtc_match 0xc804 /* width RMuint32 */
+#define CPU_rtc_stat 0xc808 /* width RMuint32 */
+#define CPU_rtc_load 0xc80c /* width RMuint32 */
+#define CPU_rtc_ctrl 0xc810 /* width RMuint32 */
+#define CPU_irq_status 0xe000 /* width RMuint32 */
+#define CPU_irq_rawstat 0xe004 /* width RMuint32 */
+#define CPU_irq_enableset 0xe008 /* width RMuint32 */
+#define CPU_irq_enableclr 0xe00c /* width RMuint32 */
+#define CPU_irq_softset 0xe010 /* width RMuint32 */
+#define CPU_irq_softclr 0xe014 /* width RMuint32 */
+#define CPU_fiq_status 0xe100 /* width RMuint32 */
+#define CPU_fiq_rawstat 0xe104 /* width RMuint32 */
+#define CPU_fiq_enableset 0xe108 /* width RMuint32 */
+#define CPU_fiq_enableclr 0xe10c /* width RMuint32 */
+#define CPU_fiq_softset 0xe110 /* width RMuint32 */
+#define CPU_fiq_softclr 0xe114 /* width RMuint32 */
+#define CPU_edge_status 0xe200 /* width RMuint32 */
+#define CPU_edge_rawstat 0xe204 /* width RMuint32 */
+#define CPU_edge_config_rise 0xe208 /* width RMuint32 */
+#define CPU_edge_config_fall 0xe20c /* width RMuint32 */
+#define CPU_SOFT_INT 0x00000001 /* width RMuint32 */
+#define CPU_UART0_INT 0x00000002 /* width RMuint32 */
+#define CPU_UART1_INT 0x00000004 /* width RMuint32 */
+#define CPU_TIMER0_INT 0x00000020 /* width RMuint32 */
+#define CPU_TIMER1_INT 0x00000040 /* width RMuint32 */
+#define CPU_HOST_MBUS_W0_INT 0x00000200 /* width RMuint32 */
+#define CPU_HOST_MBUS_W1_INT 0x00000400 /* width RMuint32 */
+#define CPU_HOST_MBUS_R0_INT 0x00000800 /* width RMuint32 */
+#define CPU_HOST_MBUS_R1_INT 0x00001000 /* width RMuint32 */
+#define CPU_PCI_INTA 0x00002000 /* width RMuint32 */
+#define CPU_PCI_INTB 0x00004000 /* width RMuint32 */
+#define CPU_PCI_INTC 0x00008000 /* width RMuint32 */
+#define CPU_PCI_INTD 0x00010000 /* width RMuint32 */
+#define CPU_PCI_FAULT_INT 0x00100000 /* width RMuint32 */
+#define CPU_INFRARED_INT 0x00200000 /* width RMuint32 */
+#define CPU_SFLA_INT 0x00000010 /* width RMuint32 */
+#define CPU_DVD_INT 0x00000080 /* width RMuint32 */
+#define CPU_ETH_INT 0x00000100 /* width RMuint32 */
+#define CPU_DMAIDE_INT 0x00020000 /* width RMuint32 */
+#define CPU_IDE_INT 0x00040000 /* width RMuint32 */
+#define CPU_FRONTPANEL_INT 0x00080000 /* width RMuint32 */
+#define CPU_I2C_INT 0x00400000 /* width RMuint32 */
+#define CPU_GFX_ACCEL_INT 0x00800000 /* width RMuint32 */
+#define CPU_VSYNC0_INT 0x01000000 /* width RMuint32 */
+#define CPU_VSYNC1_INT 0x02000000 /* width RMuint32 */
+#define CPU_VSYNC2_INT 0x04000000 /* width RMuint32 */
+#define CPU_VSYNC3_INT 0x08000000 /* width RMuint32 */
+#define CPU_VSYNC4_INT 0x10000000 /* width RMuint32 */
+#define CPU_VSYNC4BKEND_INT 0x20000000 /* width RMuint32 */
+#define CPU_VSYNC5_INT 0x40000000 /* width RMuint32 */
+#define CPU_VSYNC5BKEND_INT 0x80000000 /* width RMuint32 */
+#define CPU_SMARTCARD_HI_INT 0x00000001 /* width RMuint32 */
+#define CPU_HDMI_HI_INT 0x00000002 /* width RMuint32 */
+#define CPU_HDMI_I2C_HI_INT 0x00000004 /* width RMuint32 */
+#define CPU_VBUS_W0_HI_INT 0x00000008 /* width RMuint32 */
+#define CPU_VBUS_W3_HI_INT 0x00000010 /* width RMuint32 */
+#define CPU_ETH_PHY_HI_INT 0x00000020 /* width RMuint32 */
+#define CPU_ETH_MAC_HI_INT 0x00000040 /* width RMuint32 */
+#define CPU_USB_OHCI_MAC_HI_INT 0x00000080 /* width RMuint32 */
+#define CPU_USB_EHCI_MAC_HI_INT 0x00000100 /* width RMuint32 */
+#define LOG2_CPU_SOFT_INT 0 /* width RMuint32 */
+#define LOG2_CPU_UART0_INT 1 /* width RMuint32 */
+#define LOG2_CPU_UART1_INT 2 /* width RMuint32 */
+#define LOG2_CPU_TIMER0_INT 5 /* width RMuint32 */
+#define LOG2_CPU_TIMER1_INT 6 /* width RMuint32 */
+#define LOG2_CPU_DVD_INT 7 /* width RMuint32 */
+#define LOG2_CPU_RTC_INT 8 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W0_INT 9 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W1_INT 10 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R0_INT 11 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R1_INT 12 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTA 13 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTB 14 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTC 15 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTD 16 /* width RMuint32 */
+#define LOG2_CPU_DMAIDE_INT 17 /* width RMuint32 */
+#define LOG2_CPU_IDE_INT 18 /* width RMuint32 */
+#define LOG2_CPU_FRONTPANEL_INT 19 /* width RMuint32 */
+#define LOG2_CPU_PCI_FAULT_INT 20 /* width RMuint32 */
+#define LOG2_CPU_INFRARED_INT 21 /* width RMuint32 */
+#define LOG2_CPU_I2C_INT 22 /* width RMuint32 */
+#define LOG2_CPU_GFX_ACCEL_INT 23 /* width RMuint32 */
+#define LOG2_CPU_VSYNC0_INT 24 /* width RMuint32 */
+#define LOG2_CPU_VSYNC1_INT 25 /* width RMuint32 */
+#define LOG2_CPU_VSYNC2_INT 26 /* width RMuint32 */
+#define LOG2_CPU_VSYNC3_INT 27 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4_INT 28 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4BKEND_INT 29 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5_INT 30 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5BKEND_INT 31 /* width RMuint32 */
+#define LOG2_CPU_SMARTCARD_INT 32 /* width RMuint32 */
+#define LOG2_CPU_HDMI_INT 33 /* width RMuint32 */
+#define LOG2_CPU_HDMI_I2C_INT 34 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W0_INT 35 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W3_INT 36 /* width RMuint32 */
+#define LOG2_CPU_ETH_PHY_INT 37 /* width RMuint32 */
+#define LOG2_CPU_ETH_MAC_INT 38 /* width RMuint32 */
+#define LOG2_CPU_USB_OHCI_INT 39 /* width RMuint32 */
+#define LOG2_CPU_USB_EHCI_INT 40 /* width RMuint32 */
+#define LOG2_CPU_SATA_INT 41 /* width RMuint32 */
+#define LOG2_CPU_DMASATA_INT 42 /* width RMuint32 */
+#define LOG2_XPU_W0_INT 43 /* width RMuint32 */
+#define LOG2_XPU_R0_INT 44 /* width RMuint32 */
+#define LOG2_XPU_W_SP_INT 45 /* width RMuint32 */
+#define LOG2_XPU_R_SP_INT 46 /* width RMuint32 */
+#define LOG2_CPU_GPIO24_INT 47 /* width RMuint32 */
+#define LOG2_CPU_GPIO25_INT 48 /* width RMuint32 */
+#define LOG2_CPU_GPIO26_INT 49 /* width RMuint32 */
+#define LOG2_CPU_GPIO27_INT 50 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W4_INT 51 /* width RMuint32 */
+#define LOG2_CPU_SMARTCARD1_INT 52 /* width RMuint32 */
+#define LOG2_CPU_HDMI_CEC_INT 53 /* width RMuint32 */
+#define CPU_edge_status_hi 0xe220 /* width RMuint32 */
+#define CPU_edge_rawstat_hi 0xe224 /* width RMuint32 */
+#define CPU_edge_config_rise_hi 0xe228 /* width RMuint32 */
+#define CPU_edge_config_fall_hi 0xe22c /* width RMuint32 */
+#define CPU_irq_status_hi 0xe018 /* width RMuint32 */
+#define CPU_irq_rawstat_hi 0xe01c /* width RMuint32 */
+#define CPU_irq_enableset_hi 0xe020 /* width RMuint32 */
+#define CPU_irq_enableclr_hi 0xe024 /* width RMuint32 */
+#define CPU_fiq_status_hi 0xe118 /* width RMuint32 */
+#define CPU_fiq_rawstat_hi 0xe11c /* width RMuint32 */
+#define CPU_fiq_enableset_hi 0xe120 /* width RMuint32 */
+#define CPU_fiq_enableclr_hi 0xe124 /* width RMuint32 */
+#define CPU_iiq_status 0xe300 /* width RMuint32 */
+#define CPU_iiq_rawstat 0xe304 /* width RMuint32 */
+#define CPU_iiq_enableset 0xe308 /* width RMuint32 */
+#define CPU_iiq_enableclr 0xe30c /* width RMuint32 */
+#define CPU_iiq_softset 0xe310 /* width RMuint32 */
+#define CPU_iiq_softclr 0xe314 /* width RMuint32 */
+#define CPU_iiq_status_hi 0xe318 /* width RMuint32 */
+#define CPU_iiq_rawstat_hi 0xe31c /* width RMuint32 */
+#define CPU_iiq_enableset_hi 0xe320 /* width RMuint32 */
+#define CPU_iiq_enableclr_hi 0xe324 /* width RMuint32 */
+#define CPU_UART_GPIOMODE 0x38 /* width RMuint32 */
+#define CPU_UART_GPIODIR 0x30 /* width RMuint32 */
+#define CPU_UART_GPIODATA 0x34 /* width RMuint32 */
+#define CPU_edge_config_rise_set 0xe210 /* width RMuint32 */
+#define CPU_edge_config_rise_clr 0xe214 /* width RMuint32 */
+#define CPU_edge_config_fall_set 0xe218 /* width RMuint32 */
+#define CPU_edge_config_fall_clr 0xe21c /* width RMuint32 */
+#define CPU_edge_config_rise_set_hi 0xe230 /* width RMuint32 */
+#define CPU_edge_config_rise_clr_hi 0xe234 /* width RMuint32 */
+#define CPU_edge_config_fall_set_hi 0xe238 /* width RMuint32 */
+#define CPU_edge_config_fall_clr_hi 0xe23c /* width RMuint32 */
+#define intentionaldiff_em 0xeee0 /* width RMuint32 */
+#define CPU_pm_select_0 0xc900 /* width RMuint32 */
+#define CPU_pm_counter_0 0xc904 /* width RMuint32 */
+#define CPU_pm_select_1 0xc908 /* width RMuint32 */
+#define CPU_pm_counter_1 0xc90c /* width RMuint32 */
+#define CPU_remap 0xf000 /* width RMuint32 */
+#define CPU_remap1 0xf004 /* width RMuint32 */
+#define CPU_remap2 0xf008 /* width RMuint32 */
+#define CPU_remap3 0xf00c /* width RMuint32 */
+#define CPU_remap4 0xf010 /* width RMuint32 */
+#define CPU_remap5 0xf014 /* width RMuint32 */
+#define CPU_remap6 0xf018 /* width RMuint32 */
+#define CPU_remap7 0xf01c /* width RMuint32 */
+#define CPU_remap_address 0x1fc00000 /* width RMuint32 */
+#define CPU_remap1_address 0 /* width RMuint32 */
+#define CPU_remap2_address 0x04000000 /* width RMuint32 */
+#define CPU_remap3_address 0x08000000 /* width RMuint32 */
+#define CPU_remap4_address 0x0c000000 /* width RMuint32 */
+#define CPU_remap5_address 0x10000000 /* width RMuint32 */
+#define CPU_remap6_address 0x14000000 /* width RMuint32 */
+#define CPU_remap7_address 0x18000000 /* width RMuint32 */
+#define REG_BASE_irq_handler_block 0xf0000 /* width RMuint32 */
+#define G2L_BIST_BUSY 0xffe0 /* width RMuint32 */
+#define G2L_BIST_PASS 0xffe4 /* width RMuint32 */
+#define G2L_BIST_MASK 0xffe8 /* width RMuint32 */
+#define G2L_RESET_CONTROL 0xfffc /* width RMuint32 */
+#define CPU_UART0_base 0xc100 /* width RMuint32 */
+#define CPU_UART1_base 0xc200 /* width RMuint32 */
+#define CPU_UART_RBR 0x00 /* width RMuint32 */
+#define CPU_UART_THR 0x04 /* width RMuint32 */
+#define CPU_UART_IER 0x08 /* width RMuint32 */
+#define CPU_UART_IIR 0x0c /* width RMuint32 */
+#define CPU_UART_FCR 0x10 /* width RMuint32 */
+#define CPU_UART_LCR 0x14 /* width RMuint32 */
+#define CPU_UART_MCR 0x18 /* width RMuint32 */
+#define CPU_UART_LSR 0x1c /* width RMuint32 */
+#define CPU_UART_MSR 0x20 /* width RMuint32 */
+#define CPU_UART_SCR 0x24 /* width RMuint32 */
+#define CPU_UART_CLKDIV 0x28 /* width RMuint32 */
+#define CPU_UART_CLKSEL 0x2c /* width RMuint32 */
+/* CPUBlock registers done */
+
+/* XPUBlock registers */
+#define REG_BASE_xpu_block 0x000e0000 /* width RMuint32 */
+/* XPUBlock registers done */
+
+/* IPUBlock registers */
+#define REG_BASE_ipu_block 0x000f0000 /* width RMuint32 */
+/* IPUBlock registers done */
+
+/* DisplayBlock registers */
+#define REG_BASE_display_block 0x00070000 /* width RMuint32 */
+#define PMEM_BASE_display_block 0x00300000 /* width RMuint32 */
+#define VIF_w0 0x4000 /* width RMuint32 */
+#define VIF_w1 0x4100 /* width RMuint32 */
+#define VIF_w2 0x4200 /* width RMuint32 */
+#define VIF_w3 0x4F00 /* width RMuint32 */
+#define VIF_r0 0x4300 /* width RMuint32 */
+#define VIF_r1 0x4400 /* width RMuint32 */
+#define VIF_r2 0x4500 /* width RMuint32 */
+#define VIF_r3 0x4600 /* width RMuint32 */
+#define VIF_r4 0x4700 /* width RMuint32 */
+#define VIF_r5 0x4800 /* width RMuint32 */
+#define VIF_r6 0x4900 /* width RMuint32 */
+#define VIF_r7 0x4A00 /* width RMuint32 */
+#define VIF_r8 0x4B00 /* width RMuint32 */
+#define VIF_r9 0x4C00 /* width RMuint32 */
+#define VIF_r10 0x4D00 /* width RMuint32 */
+#define VIF_r11 0x4E00 /* width RMuint32 */
+#define VIF_offs 0x0100 /* width RMuint32 */
+#define VIF_add 0x0000 /* width RMuint32 */
+#define VIF_cnt 0x0004 /* width RMuint32 */
+#define VIF_skip 0x0008 /* width RMuint32 */
+#define VIF_cmd 0x000c /* width RMuint32 */
+#define VIF_addB 0x0010 /* width RMuint32 */
+#define VIF_cntB 0x0014 /* width RMuint32 */
+#define VIF_skipB 0x0018 /* width RMuint32 */
+#define VBUS_IDLE 0x0 /* width RMuint32 */
+#define VBUS_LINEAR 0x1 /* width RMuint32 */
+#define VBUS_DOUBLE 0x2 /* width RMuint32 */
+#define VBUS_RECTANGLE 0x3 /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD 0x4 /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE 0x5 /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN 0x6 /* width RMuint32 */
+#define VBUS_VOID 0x8 /* width RMuint32 */
+#define VBUS_LINEAR_VOID 0x9 /* width RMuint32 */
+#define VBUS_DOUBLE_VOID 0xa /* width RMuint32 */
+#define VBUS_RECTANGLE_VOID 0xb /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD_VOID 0xc /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE_VOID 0xd /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN_VOID 0xe /* width RMuint32 */
+/* DisplayBlock registers done */
+
+/* DemuxEngine registers */
+#define REG_BASE_demux_engine 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_0 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_0 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_1 0x000b0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_1 0x00170000 /* width RMuint32 */
+#define TDMX_gpio_data 0x2e0c /* width RMuint32 */
+#define TDMX_gpio_dir 0x2e0d /* width RMuint32 */
+/* DemuxEngine registers done */
+
+/* MpegEngine registers */
+#define REG_BASE_mpeg_engine_0 0x00080000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_0 0x00110000 /* width RMuint32 */
+#define REG_BASE_mpeg_engine_1 0x00090000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_1 0x00130000 /* width RMuint32 */
+#define RBUS_offset 0x4000 /* width RMuint32 */
+/* MpegEngine registers done */
+
+/* VideoDecoder registers */
+/* VideoDecoder registers done */
+
+/* AudioEngine registers */
+#define REG_BASE_audio_engine_0 0x000c0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_0 0x00190000 /* width RMuint32 */
+#define REG_BASE_audio_engine_1 0x000d0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_1 0x001b0000 /* width RMuint32 */
+#define audio_mutex0 0x3e90 /* width RMuint32 */
+#define audio_mutex1 0x3e91 /* width RMuint32 */
+#define audio_mutex2 0x3e92 /* width RMuint32 */
+#define audio_mutex3 0x3e93 /* width RMuint32 */
+#define audio_mutex4 0x3e94 /* width RMuint32 */
+#define audio_mutex5 0x3e95 /* width RMuint32 */
+#define audio_mutex6 0x3e96 /* width RMuint32 */
+#define audio_mutex7 0x3e97 /* width RMuint32 */
+/* AudioEngine registers done */
+
+/* AudioDecoder registers */
+/* AudioDecoder registers done */
+
+/* AudioCapture registers */
+/* AudioCapture registers done */
+
+/* VoipCodec registers */
+/* VoipCodec registers done */
+
+/* CRCDecoder registers */
+/* CRCDecoder registers done */
+
+/* XCRCDecoder registers */
+/* XCRCDecoder registers done */
+
+/* StreamCapture registers */
+/* StreamCapture registers done */
+
+/* RawDataTransfer registers */
+/* RawDataTransfer registers done */
+
+/* I2C registers */
+#define I2C_MASTER_CONFIG 0x80 /* width RMuint32 */
+#define I2C_MASTER_CLK_DIV 0x84 /* width RMuint32 */
+#define I2C_MASTER_DEV_ADDR 0x88 /* width RMuint32 */
+#define I2C_MASTER_ADDR 0x8c /* width RMuint32 */
+#define I2C_MASTER_DATA_OUT 0x90 /* width RMuint32 */
+#define I2C_MASTER_DATA_IN 0x94 /* width RMuint32 */
+#define I2C_MASTER_STATUS 0x98 /* width RMuint32 */
+#define I2C_MASTER_STARTXFER 0x9c /* width RMuint32 */
+#define I2C_MASTER_BYTE_CNT 0xa0 /* width RMuint32 */
+#define I2C_MASTER_INTEN 0xa4 /* width RMuint32 */
+#define I2C_MASTER_INT 0xa8 /* width RMuint32 */
+#define I2C_SLAVE_ADDR_REG 0xC0 /* width RMuint32 */
+#define I2C_SLAVE_DATAOUT 0xC4 /* width RMuint32 */
+#define I2C_SLAVE_DATAIN 0xC8 /* width RMuint32 */
+#define I2C_SLAVE_STATUS 0xCC /* width RMuint32 */
+#define I2C_SLAVE_INTEN 0xD0 /* width RMuint32 */
+#define I2C_SLAVE_INT 0xD4 /* width RMuint32 */
+#define I2C_SLAVE_BUS_HOLD 0xD8 /* width RMuint32 */
+/* I2C registers done */
+
+/* MM registers */
+/* MM registers done */
+
+/* SpuDecoder registers */
+/* SpuDecoder registers done */
+
+/* PictureTransform registers */
+/* PictureTransform registers done */
+
+/* ClosedCaptionDecoder registers */
+/* ClosedCaptionDecoder registers done */
+
+/* RTC registers */
+/* RTC registers done */
+
+/* Cipher registers */
+/* Cipher registers done */
+
+/* STC registers */
+/* STC registers done */
+
+/* PLL registers */
+/* PLL registers done */
+
+/* DemuxCipher registers */
+/* DemuxCipher registers done */
+
+/* DemuxTask registers */
+/* DemuxTask registers done */
+
+/* DemuxOutput registers */
+/* DemuxOutput registers done */
+
+/* CCFifo registers */
+/* CCFifo registers done */
+
+/* Sha1Sum registers */
+/* Sha1Sum registers done */
+
+/* XTask registers */
+/* XTask registers done */
+
+/* TTXFifo registers */
+/* TTXFifo registers done */
+
+/* VCXO registers */
+/* VCXO registers done */
+
+/* PPF registers */
+/* PPF registers done */
+
+#endif /* __EMHWLIB_REGISTERS_TANGO3_H__ */
+
+/* End of generated file ../emhwlib_hal/include/tango3/emhwlib_registers_tango3.h */
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_registers_tango3.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_registers_tango3.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_registers_tango3.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_registers_tango3.inc	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,609 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/tango3/emhwlib_registers_tango3.inc (generated from emhwlib_hal/include/tango3/emhwlib_registers_tango3.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+REG_BASE_system_block=0x10000
+SYS_clkgen0_pll=0x0
+SYS_clkgen0_div=0x4
+SYS_clkgen1_pll=0x8
+SYS_clkgen1_div=0xc
+SYS_clkgen2_pll=0x10
+SYS_clkgen2_div=0x14
+SYS_clkgen3_pll=0x18
+SYS_clkgen3_div=0x1c
+SYS_avclk_mux=0x38
+SYS_sysclk_mux=0x3c
+SYS_clk_cnt=0x40
+SYS_xtal_in_cnt=0x48
+DRAM_vbus_w0_cfg=0x300
+DRAM_vbus_w1_cfg=0x304
+DRAM_vbus_w2_cfg=0x308
+DRAM_vbus_w3_cfg=0x30c
+DRAM_vbus_r0_cfg=0x340
+DRAM_vbus_r1_cfg=0x344
+DRAM_vbus_r2_cfg=0x348
+DRAM_vbus_r3_cfg=0x34c
+DRAM_vbus_r4_cfg=0x350
+DRAM_vbus_r5_cfg=0x354
+DRAM_vbus_r6_cfg=0x358
+DRAM_vbus_r7_cfg=0x35c
+DRAM_vbus_r8_cfg=0x360
+DRAM_vbus_r9_cfg=0x364
+DRAM_vbus_r10_cfg=0x368
+DRAM_vbus_r11_cfg=0x36c
+DRAM_mbus_w0_cfg=0x200
+DRAM_mbus_w1_cfg=0x204
+DRAM_mbus_w2_cfg=0x208
+DRAM_mbus_w3_cfg=0x20c
+DRAM_mbus_w4_cfg=0x210
+DRAM_mbus_w5_cfg=0x214
+DRAM_mbus_w6_cfg=0x218
+DRAM_mbus_w7_cfg=0x21c
+DRAM_mbus_w8_cfg=0x220
+DRAM_mbus_w9_cfg=0x224
+DRAM_mbus_w10_cfg=0x228
+DRAM_mbus_r0_cfg=0x240
+DRAM_mbus_r1_cfg=0x244
+DRAM_mbus_r2_cfg=0x248
+DRAM_mbus_r3_cfg=0x24c
+DRAM_mbus_r4_cfg=0x250
+DRAM_mbus_r5_cfg=0x254
+DRAM_mbus_r6_cfg=0x258
+DRAM_mbus_r7_cfg=0x25c
+DRAM_mbus_r8_cfg=0x260
+DRAM_mbus_r9_cfg=0x264
+DRAM_mbus_r10_cfg=0x268
+SYS_hostclk_mux=0x30
+SYS_sysclk_premux=0x34
+SYS_rnd_cnt=0x44
+SYS_cnt_cfg=0x4c
+SYS_cfg_cnt0=0x50
+SYS_cfg_cnt1=0x54
+SYS_cfg_cnt2=0x58
+SYS_cfg_cnt3=0x5c
+SYS_cfg_cnt4=0x60
+SYS_cleandiv0_div=0x80
+SYS_cleandiv1_div=0x88
+SYS_cleandiv2_div=0x90
+SYS_cleandiv3_div=0x98
+SYS_cleandiv4_div=0xa0
+SYS_cleandiv5_div=0xa8
+SYS_cleandiv6_div=0xb0
+SYS_cleandiv7_div=0xb8
+SYS_cleandiv8_div=0xc0
+SYS_cleandiv9_div=0xc8
+SYS_cleandiv10_div=0xd0
+MARB_mid01_cfg=0x200
+MARB_mid21_cfg=0x204
+MARB_mid02_cfg=0x208
+MARB_mid22_cfg=0x20c
+MARB_mid04_cfg=0x210
+MARB_mid24_cfg=0x214
+MARB_mid25_cfg=0x218
+MARB_mid08_cfg=0x21c
+MARB_mid28_cfg=0x220
+MARB_mid29_cfg=0x224
+MARB_mid0C_cfg=0x228
+MARB_mid2C_cfg=0x22c
+MARB_mid10_cfg=0x230
+MARB_mid30_cfg=0x234
+MARB_mid31_cfg=0x238
+MARB_mid12_cfg=0x23c
+MARB_mid32_cfg=0x240
+VARB_mid01_cfg=0x300
+VARB_mid02_cfg=0x304
+VARB_mid21_cfg=0x308
+VARB_mid22_cfg=0x30c
+VARB_mid23_cfg=0x310
+VARB_mid24_cfg=0x314
+VARB_mid25_cfg=0x318
+VARB_mid26_cfg=0x31c
+VARB_mid27_cfg=0x320
+VARB_mid28_cfg=0x324
+VARB_mid29_cfg=0x328
+VARB_mid2A_cfg=0x32c
+VARB_mid10_cfg=0x330
+VARB_mid30_cfg=0x334
+VARB_mid31_cfg=0x338
+VARB_mid03_cfg=0x33c
+IARB_mid01_cfg=0x400
+IARB_mid02_cfg=0x404
+SYS_gpio_dir=0x500
+SYS_gpio_data=0x504
+SYS_gpio_int=0x508
+SYS_gpio15_pwm=0x510
+SYS_gpio14_pwm=0x514
+REG_BASE_dram_controller_0=0x30000
+REG_BASE_dram_controller_1=0x40000
+MEM_BASE_dram_controller_0=0x80000000
+MEM_BASE_dram_controller_1=0xc0000000
+MEM_BASE_dram_controller_0_alias=0x10000000
+MEM_BASE_dram_controller_1_alias=0x20000000 
+DRAM_dunit_cfg=0x0
+DRAM_dunit_delay0_ctrl=0x4
+DRAM_dunit_delay1_ctrl=0x8
+DRAM_dunit_auto_delay=0xc
+DRAM_dunit_fall_delay0=0x10
+DRAM_dunit_fall_delay1=0x14
+DRAM_dunit_bw_lobound=0x18
+DRAM_dunit_bw_hibound=0x1c
+DRAM_dunit_bw_probe_cfg=0x20
+DRAM_dunit_bw_probe_cnt=0x24
+DRAM_dunit_bw_cntall=0x28
+DRAM_dunit_calibration_delay=0x30
+DRAM_dunit_calibration_rise_err=0x34
+DRAM_dunit_calibration_fall_err=0x38
+DRAM_dunit_calibration_page=0x88
+DRAM_dunit_flush_buffer=0x104
+REG_BASE_host_interface=0x20000
+MEM_BASE_host_interface=0x40000000
+IDE_data=0x0
+IDE_error=0x4
+IDE_count=0x8
+IDE_start_sector=0xc
+IDE_cylinder_lo=0x10
+IDE_cylinder_hi=0x14
+IDE_head_device=0x18
+IDE_cmd_stat=0x1c
+IDE_irq_stat=0x218
+IDE_cmd_stat__=0x21c
+PB_timing0=0x800
+PB_timing1=0x804
+PB_timing2=0x808
+PB_timing3=0x80c
+PB_timing4=0x810
+PB_timing5=0x814
+PB_default_timing=0x818
+PB_use_timing0=0x81c
+PB_use_timing1=0x820
+PB_use_timing2=0x824
+PB_use_timing3=0x828
+PB_use_timing4=0x82c
+PB_use_timing5=0x830
+PB_CS_config=0x834
+PB_automode_start_address=0x840
+PB_automode_control=0x844
+EMHWLIB_IS_HOST=0xe000
+HOST_REG1=0xfed0
+HOST_REG2=0xfed4
+READ_ADDRESS=0xfec0
+READ_COUNTER=0xfec4
+READ_ENABLE=0xfec8
+REV_ORDER=0xfecc
+WRITE_ADDRESS=0xfed8
+WRITE_COUNTER=0xfedc
+WRITE_ENABLE=0xfee0
+BURST=0xfee4
+PCI_TIMEOUT=0x8000
+PCI_TIMEOUT_STATUS=0x8004
+PCI_TIMER=0x8008
+PCI_TIMER_TEST=0x800c
+PCI_WAKEUP=0x8010
+PCI_REGION_0_BASE=0x9000
+PCI_REGION_1_BASE=0x9004
+PCI_REGION_2_BASE=0x9008
+PCI_REGION_3_BASE=0x900c
+PCI_REGION_4_BASE=0x9010
+PCI_REGION_5_BASE=0x9014
+PCI_REGION_6_BASE=0x9018
+PCI_REGION_7_BASE=0x901c
+PCI_irq_status=0x9020
+PCI_irq_set=0x9024
+PCI_irq_clear=0x9028
+SBOX_FIFO_RESET=0x90a0
+SBOX_ROUTE=0x90a8
+output_SBOX_MBUS_W0=0x9080
+output_SBOX_MBUS_W1=0x9084
+output_SBOX_PCI_MASTER=0x9088
+output_SBOX_PCI_SLAVE=0x908c
+output_SBOX_CIPHER=0x9090
+output_SBOX_IDE_ISA=0x9094
+output_SBOX_IDE_DVD=0x9098
+input_keep_SBOX=0x0
+input_MBUS_R0_SBOX=0x1
+input_MBUS_R1_SBOX=0x2
+input_PCI_MASTER_SBOX=0x3
+input_PCI_SLAVE_SBOX=0x4
+input_CIPHER_SBOX=0x5
+input_IDE_DVD_SBOX=0x6
+input_IDE_ISA_SBOX=0x7
+input_SFLA_SBOX=0x8
+input_unconnected_SBOX=0xf
+host_mutex0=0x9040
+host_mutex1=0x9044
+host_mutex2=0x9048
+host_mutex3=0x904c
+host_mutex4=0x9050
+host_mutex5=0x9054
+host_mutex6=0x9058
+host_mutex7=0x905c
+host_mutex8=0x9060
+host_mutex9=0x9064
+host_mutex10=0x9068
+host_mutex11=0x906c
+host_mutex12=0x9070
+host_mutex13=0x9074
+host_mutex14=0x9078
+host_mutex15=0x907c
+PCI_host_reg5=0xfe94
+PCI_chip_is_host=0xfe90
+IDECTRL_idesrc=0x20d0
+IDECTRL_pri_drv1udmatim1=0x20e0
+IDECTRL_pri_drv1udmatim2=0x20f0
+IDECTRL_pri_idectl=0x2100
+IDECTRL_pri_drv0tim=0x2110
+IDECTRL_pri_drv1tim=0x2120
+IDECTRL_idemisc=0x2130
+IDECTRL_idestatus=0x2140
+IDECTRL_udmactl=0x2150
+IDECTRL_pri_drv0udmatim1=0x2160
+IDECTRL_pri_drv0udmatim2=0x2170
+IDECTRL_pref_st=0x2310
+IDECTRL_pri_ctrlblock=0x2398
+IDECTRL_pri_cmdblock=0x23c0
+IDECTRL_bmic=0x2400
+IDECTRL_bmis=0x2410
+IDECTRL_bmidtp=0x2420
+IDECTRL_ide_dmaptr=0x2780
+IDECTRL_ide_dmalen=0x2790
+IDECTRL_pio_prefetch_data=0x27c0
+MEM_BASE_pfla=0x40000000
+PB_CS0_OFFSET=0x0
+PB_CS1_OFFSET=0x4000000
+PB_CS2_OFFSET=0x8000000
+PB_CS3_OFFSET=0xc000000
+ETH_gpio_dir1=0x7100
+ETH_gpio_data1=0x7104
+ETH_gpio_mask1=0x7108
+ETH_gpio_dir2=0x710c
+ETH_gpio_data2=0x7110
+PCI_host_reg1=0xfed0
+PCI_host_reg2=0xfed4
+PCI_host_reg3=0xfe80
+PCI_host_reg4=0xfe84
+PCI_pcictrl_reg1=0xfe88
+PCI_pcictrl_reg2=0xfe8c
+PCI_pcictrl_reg3=0xfefc
+PCI_REG0=0xfee8
+PCI_REG1=0xfeec
+PCI_REG2=0xfef0
+PCI_REG3=0xfef4
+PCI_CONFIG=0xfef8
+MIF_W0_ADD=0xb000
+MIF_W0_CNT=0xb004
+MIF_W0_SKIP=0xb008
+MIF_W0_CMD=0xb00c
+MIF_W1_ADD=0xb040
+MIF_W1_CNT=0xb044
+MIF_W1_SKIP=0xb048
+MIF_W1_CMD=0xb04c
+MIF_R0_ADD=0xb080
+MIF_R0_CNT=0xb084
+MIF_R0_SKIP=0xb088
+MIF_R0_CMD=0xb08c
+MIF_R1_ADD=0xb0c0
+MIF_R1_CNT=0xb0c4
+MIF_R1_SKIP=0xb0c8
+MIF_R1_CMD=0xb0cc
+MBUS_IDLE=0x0
+MBUS_LINEAR=0x1
+MBUS_DOUBLE=0x2
+MBUS_RECTANGLE=0x3
+MBUS_VOID=0x4
+MBUS_LINEAR_VOID=0x5
+MBUS_DOUBLE_VOID=0x6
+MBUS_RECTANGLE_VOID=0x7
+MBUS_TILED=0x8
+GBUS_MUTEX_XPU=0x14
+GBUS_MUTEX_PT110=0x16
+GBUS_MUTEX_TDMX=0x19
+GBUS_MUTEX_AUDIO_0=0x1b
+GBUS_MUTEX_AUDIO_1=0x1c
+GBUS_MUTEX_MPEG_0=0x1d
+GBUS_MUTEX_MPEG_1=0x1e
+GBUS_MUTEX_HOST=0x1f
+GBUS_MUTEX_LOCAL=0x10
+REG_BASE_cpu_block=0x60000
+CPU_time0_load=0xc500
+CPU_time0_value=0xc504
+CPU_time0_ctrl=0xc508
+CPU_time0_clr=0xc50c
+CPU_time1_load=0xc600
+CPU_time1_value=0xc604
+CPU_time1_ctrl=0xc608
+CPU_time1_clr=0xc60c
+CPU_rtc_data=0xc800
+CPU_rtc_match=0xc804
+CPU_rtc_stat=0xc808
+CPU_rtc_load=0xc80c
+CPU_rtc_ctrl=0xc810
+CPU_irq_status=0xe000
+CPU_irq_rawstat=0xe004
+CPU_irq_enableset=0xe008
+CPU_irq_enableclr=0xe00c
+CPU_irq_softset=0xe010
+CPU_irq_softclr=0xe014
+CPU_fiq_status=0xe100
+CPU_fiq_rawstat=0xe104
+CPU_fiq_enableset=0xe108
+CPU_fiq_enableclr=0xe10c
+CPU_fiq_softset=0xe110
+CPU_fiq_softclr=0xe114
+CPU_edge_status=0xe200
+CPU_edge_rawstat=0xe204
+CPU_edge_config_rise=0xe208
+CPU_edge_config_fall=0xe20c
+CPU_SOFT_INT=0x1
+CPU_UART0_INT=0x2
+CPU_UART1_INT=0x4
+CPU_TIMER0_INT=0x20
+CPU_TIMER1_INT=0x40
+CPU_HOST_MBUS_W0_INT=0x200
+CPU_HOST_MBUS_W1_INT=0x400
+CPU_HOST_MBUS_R0_INT=0x800
+CPU_HOST_MBUS_R1_INT=0x1000
+CPU_PCI_INTA=0x2000
+CPU_PCI_INTB=0x4000
+CPU_PCI_INTC=0x8000
+CPU_PCI_INTD=0x10000
+CPU_PCI_FAULT_INT=0x100000
+CPU_INFRARED_INT=0x200000
+CPU_SFLA_INT=0x10
+CPU_DVD_INT=0x80
+CPU_ETH_INT=0x100
+CPU_DMAIDE_INT=0x20000
+CPU_IDE_INT=0x40000
+CPU_FRONTPANEL_INT=0x80000
+CPU_I2C_INT=0x400000
+CPU_GFX_ACCEL_INT=0x800000
+CPU_VSYNC0_INT=0x1000000
+CPU_VSYNC1_INT=0x2000000
+CPU_VSYNC2_INT=0x4000000
+CPU_VSYNC3_INT=0x8000000
+CPU_VSYNC4_INT=0x10000000
+CPU_VSYNC4BKEND_INT=0x20000000
+CPU_VSYNC5_INT=0x40000000
+CPU_VSYNC5BKEND_INT=0x80000000
+CPU_SMARTCARD_HI_INT=0x1
+CPU_HDMI_HI_INT=0x2
+CPU_HDMI_I2C_HI_INT=0x4
+CPU_VBUS_W0_HI_INT=0x8
+CPU_VBUS_W3_HI_INT=0x10
+CPU_ETH_PHY_HI_INT=0x20
+CPU_ETH_MAC_HI_INT=0x40
+CPU_USB_OHCI_MAC_HI_INT=0x80
+CPU_USB_EHCI_MAC_HI_INT=0x100
+LOG2_CPU_SOFT_INT=0x0
+LOG2_CPU_UART0_INT=0x1
+LOG2_CPU_UART1_INT=0x2
+LOG2_CPU_TIMER0_INT=0x5
+LOG2_CPU_TIMER1_INT=0x6
+LOG2_CPU_DVD_INT=0x7
+LOG2_CPU_RTC_INT=0x8
+LOG2_CPU_HOST_MBUS_W0_INT=0x9
+LOG2_CPU_HOST_MBUS_W1_INT=0xa
+LOG2_CPU_HOST_MBUS_R0_INT=0xb
+LOG2_CPU_HOST_MBUS_R1_INT=0xc
+LOG2_CPU_PCI_INTA=0xd
+LOG2_CPU_PCI_INTB=0xe
+LOG2_CPU_PCI_INTC=0xf
+LOG2_CPU_PCI_INTD=0x10
+LOG2_CPU_DMAIDE_INT=0x11
+LOG2_CPU_IDE_INT=0x12
+LOG2_CPU_FRONTPANEL_INT=0x13
+LOG2_CPU_PCI_FAULT_INT=0x14
+LOG2_CPU_INFRARED_INT=0x15
+LOG2_CPU_I2C_INT=0x16
+LOG2_CPU_GFX_ACCEL_INT=0x17
+LOG2_CPU_VSYNC0_INT=0x18
+LOG2_CPU_VSYNC1_INT=0x19
+LOG2_CPU_VSYNC2_INT=0x1a
+LOG2_CPU_VSYNC3_INT=0x1b
+LOG2_CPU_VSYNC4_INT=0x1c
+LOG2_CPU_VSYNC4BKEND_INT=0x1d
+LOG2_CPU_VSYNC5_INT=0x1e
+LOG2_CPU_VSYNC5BKEND_INT=0x1f
+LOG2_CPU_SMARTCARD_INT=0x20
+LOG2_CPU_HDMI_INT=0x21
+LOG2_CPU_HDMI_I2C_INT=0x22
+LOG2_CPU_VBUS_W0_INT=0x23
+LOG2_CPU_VBUS_W3_INT=0x24
+LOG2_CPU_ETH_PHY_INT=0x25
+LOG2_CPU_ETH_MAC_INT=0x26
+LOG2_CPU_USB_OHCI_INT=0x27
+LOG2_CPU_USB_EHCI_INT=0x28
+LOG2_CPU_SATA_INT=0x29
+LOG2_CPU_DMASATA_INT=0x2a
+LOG2_XPU_W0_INT=0x2b
+LOG2_XPU_R0_INT=0x2c
+LOG2_XPU_W_SP_INT=0x2d
+LOG2_XPU_R_SP_INT=0x2e
+LOG2_CPU_GPIO24_INT=0x2f
+LOG2_CPU_GPIO25_INT=0x30
+LOG2_CPU_GPIO26_INT=0x31
+LOG2_CPU_GPIO27_INT=0x32
+LOG2_CPU_VBUS_W4_INT=0x33
+LOG2_CPU_SMARTCARD2_INT=0x34
+LOG2_CPU_HDMI_CEC_INT=0x35
+CPU_edge_status_hi=0xe220
+CPU_edge_rawstat_hi=0xe224
+CPU_edge_config_rise_hi=0xe228
+CPU_edge_config_fall_hi=0xe22c
+CPU_irq_status_hi=0xe018
+CPU_irq_rawstat_hi=0xe01c
+CPU_irq_enableset_hi=0xe020
+CPU_irq_enableclr_hi=0xe024
+CPU_fiq_status_hi=0xe118
+CPU_fiq_rawstat_hi=0xe11c
+CPU_fiq_enableset_hi=0xe120
+CPU_fiq_enableclr_hi=0xe124
+CPU_iiq_status=0xe300
+CPU_iiq_rawstat=0xe304
+CPU_iiq_enableset=0xe308
+CPU_iiq_enableclr=0xe30c
+CPU_iiq_softset=0xe310
+CPU_iiq_softclr=0xe314
+CPU_iiq_status_hi=0xe318
+CPU_iiq_rawstat_hi=0xe31c
+CPU_iiq_enableset_hi=0xe320
+CPU_iiq_enableclr_hi=0xe324
+CPU_UART_GPIOMODE=0x38
+CPU_UART_GPIODIR=0x30
+CPU_UART_GPIODATA=0x34
+CPU_edge_config_rise_set=0xe210
+CPU_edge_config_rise_clr=0xe214
+CPU_edge_config_fall_set=0xe218
+CPU_edge_config_fall_clr=0xe21c
+CPU_edge_config_rise_set_hi=0xe230
+CPU_edge_config_rise_clr_hi=0xe234
+CPU_edge_config_fall_set_hi=0xe238
+CPU_edge_config_fall_clr_hi=0xe23c
+intentionaldiff_em=0xeee0
+CPU_pm_select_0=0xc900
+CPU_pm_counter_0=0xc904
+CPU_pm_select_1=0xc908
+CPU_pm_counter_1=0xc90c
+CPU_remap=0xf000
+CPU_remap1=0xf004
+CPU_remap2=0xf008
+CPU_remap3=0xf00c
+CPU_remap4=0xf010
+CPU_remap5=0xf014
+CPU_remap6=0xf018
+CPU_remap7=0xf01c
+CPU_remap_address=0x1fc00000
+CPU_remap1_address=0x0
+CPU_remap2_address=0x4000000
+CPU_remap3_address=0x8000000
+CPU_remap4_address=0xc000000
+CPU_remap5_address=0x10000000
+CPU_remap6_address=0x14000000
+CPU_remap7_address=0x18000000
+REG_BASE_irq_handler_block=0xf0000
+G2L_BIST_BUSY=0xffe0
+G2L_BIST_PASS=0xffe4
+G2L_BIST_MASK=0xffe8
+G2L_RESET_CONTROL=0xfffc
+CPU_UART0_base=0xc100
+CPU_UART1_base=0xc200
+CPU_UART_RBR=0x0
+CPU_UART_THR=0x4
+CPU_UART_IER=0x8
+CPU_UART_IIR=0xc
+CPU_UART_FCR=0x10
+CPU_UART_LCR=0x14
+CPU_UART_MCR=0x18
+CPU_UART_LSR=0x1c
+CPU_UART_MSR=0x20
+CPU_UART_SCR=0x24
+CPU_UART_CLKDIV=0x28
+CPU_UART_CLKSEL=0x2c
+REG_BASE_xpu_block=0xe0000
+REG_BASE_ipu_block=0xf0000
+REG_BASE_display_block=0x70000
+PMEM_BASE_display_block=0x300000
+VIF_w0=0x4000
+VIF_w1=0x4100
+VIF_w2=0x4200
+VIF_w3=0x4f00
+VIF_r0=0x4300
+VIF_r1=0x4400
+VIF_r2=0x4500
+VIF_r3=0x4600
+VIF_r4=0x4700
+VIF_r5=0x4800
+VIF_r6=0x4900
+VIF_r7=0x4a00
+VIF_r8=0x4b00
+VIF_r9=0x4c00
+VIF_r10=0x4d00
+VIF_r11=0x4e00
+VIF_offs=0x100
+VIF_add=0x0
+VIF_cnt=0x4
+VIF_skip=0x8
+VIF_cmd=0xc
+VIF_addB=0x10
+VIF_cntB=0x14
+VIF_skipB=0x18
+VBUS_IDLE=0x0
+VBUS_LINEAR=0x1
+VBUS_DOUBLE=0x2
+VBUS_RECTANGLE=0x3
+VBUS_DOUBLE_FIELD=0x4
+VBUS_DOUBLE_RECTANGLE=0x5
+VBUS_8BYTE_COLUMN=0x6
+VBUS_VOID=0x8
+VBUS_LINEAR_VOID=0x9
+VBUS_DOUBLE_VOID=0xa
+VBUS_RECTANGLE_VOID=0xb
+VBUS_DOUBLE_FIELD_VOID=0xc
+VBUS_DOUBLE_RECTANGLE_VOID=0xd
+VBUS_8BYTE_COLUMN_VOID=0xe
+REG_BASE_demux_engine=0xa0000
+MEM_BASE_demux_engine=0x140000
+PMEM_BASE_demux_engine=0x140000
+DMEM_BASE_demux_engine=0x150000
+REG_BASE_demux_engine_0=0xa0000
+MEM_BASE_demux_engine_0=0x140000
+PMEM_BASE_demux_engine_0=0x140000
+DMEM_BASE_demux_engine_0=0x150000
+REG_BASE_demux_engine_1=0xb0000
+MEM_BASE_demux_engine_1=0x160000
+PMEM_BASE_demux_engine_1=0x160000
+DMEM_BASE_demux_engine_1=0x170000
+TDMX_gpio_data=0x2e0c
+TDMX_gpio_dir=0x2e0d
+REG_BASE_mpeg_engine_0=0x80000
+MEM_BASE_mpeg_engine_0=0x100000
+PMEM_BASE_mpeg_engine_0=0x100000
+DMEM_BASE_mpeg_engine_0=0x110000
+REG_BASE_mpeg_engine_1=0x90000
+MEM_BASE_mpeg_engine_1=0x120000
+PMEM_BASE_mpeg_engine_1=0x120000
+DMEM_BASE_mpeg_engine_1=0x130000
+RBUS_offset=0x4000
+REG_BASE_audio_engine_0=0xc0000
+MEM_BASE_audio_engine_0=0x180000
+PMEM_BASE_audio_engine_0=0x180000
+DMEM_BASE_audio_engine_0=0x190000
+REG_BASE_audio_engine_1=0xd0000
+MEM_BASE_audio_engine_1=0x1a0000
+PMEM_BASE_audio_engine_1=0x1a0000
+DMEM_BASE_audio_engine_1=0x1b0000
+audio_mutex0=0x3e90
+audio_mutex1=0x3e91
+audio_mutex2=0x3e92
+audio_mutex3=0x3e93
+audio_mutex4=0x3e94
+audio_mutex5=0x3e95
+audio_mutex6=0x3e96
+audio_mutex7=0x3e97
+I2C_MASTER_CONFIG=0x80
+I2C_MASTER_CLK_DIV=0x84
+I2C_MASTER_DEV_ADDR=0x88
+I2C_MASTER_ADDR=0x8c
+I2C_MASTER_DATA_OUT=0x90
+I2C_MASTER_DATA_IN=0x94
+I2C_MASTER_STATUS=0x98
+I2C_MASTER_STARTXFER=0x9c
+I2C_MASTER_BYTE_CNT=0xa0
+I2C_MASTER_INTEN=0xa4
+I2C_MASTER_INT=0xa8
+I2C_SLAVE_ADDR_REG=0xc0
+I2C_SLAVE_DATAOUT=0xc4
+I2C_SLAVE_DATAIN=0xc8
+I2C_SLAVE_STATUS=0xcc
+I2C_SLAVE_INTEN=0xd0
+I2C_SLAVE_INT=0xd4
+I2C_SLAVE_BUS_HOLD=0xd8
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_shared.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_shared.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_shared.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_shared.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,114 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_shared.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2005-03-22
+*/
+
+#ifndef __EMHWLIB_RESOURCES_SHARED_H__
+#define __EMHWLIB_RESOURCES_SHARED_H__
+
+#define VIDEO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex1))
+#define VIDEO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex1))
+#define AUDIO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex1))
+#define DEMUX_RPC_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex3))
+
+// pt110 local ram map
+#define UCLINUX_CURRENT_PROCESS (REG_BASE_cpu_block + 0x0000)
+
+#define RESET_VECTOR   (REG_BASE_cpu_block + 0x0000)
+#define UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0004)
+#define SWI_VECTOR     (REG_BASE_cpu_block + 0x0008)
+#define I_ABORT_VECTOR (REG_BASE_cpu_block + 0x000c)
+#define D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0010)
+#define RSV_VECTOR     (REG_BASE_cpu_block + 0x0014)
+#define IRQ_VECTOR     (REG_BASE_cpu_block + 0x0018)
+#define FIQ_VECTOR     (REG_BASE_cpu_block + 0x001c)
+
+#define RESET_JUMP     (REG_BASE_cpu_block + 0x0020)
+#define UNDEF_JUMP     (REG_BASE_cpu_block + 0x0024)
+#define SWI_JUMP       (REG_BASE_cpu_block + 0x0028)
+#define I_ABORT_JUMP   (REG_BASE_cpu_block + 0x002c)
+#define D_ABORT_JUMP   (REG_BASE_cpu_block + 0x0030)
+#define RSV_JUMP       (REG_BASE_cpu_block + 0x0034)
+#define IRQ_JUMP       (REG_BASE_cpu_block + 0x0038)
+#define FIQ_JUMP       (REG_BASE_cpu_block + 0x003c)
+
+#define INFINITE_LOOP  (REG_BASE_cpu_block + 0x0040)
+
+/* where to store uclinux interrupt handler */
+#define UCLINUX_RESET_VECTOR   (REG_BASE_cpu_block + 0x0044)
+#define UCLINUX_UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0048)
+#define UCLINUX_SWI_VECTOR     (REG_BASE_cpu_block + 0x004c)
+#define UCLINUX_I_ABORT_VECTOR (REG_BASE_cpu_block + 0x0050)
+#define UCLINUX_D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0054)
+#define UCLINUX_RSV_VECTOR     (REG_BASE_cpu_block + 0x0058)
+#define UCLINUX_IRQ_VECTOR     (REG_BASE_cpu_block + 0x005c)
+#define UCLINUX_FIQ_VECTOR     (REG_BASE_cpu_block + 0x0060)
+
+/* where to store fiq/irq enable values */
+#define UCLINUX_IRQ_ENABLE      (REG_BASE_cpu_block + 0x0064)
+#define UCLINUX_FIQ_ENABLE      (REG_BASE_cpu_block + 0x0068)
+
+/* we use this in uClinux to handshake llad with the hardware library. llad will 
+   initialize the value to 0. As long as this value is 0, llad will mask the
+   triggered interrupt. When the CPUBlock is done loading the IRQ handler, it
+   will set this value to all the IRQ that are now being handled by itself. Next
+   time llad receives an IRQ, it will read this value and if set to the proper
+   interrupt value, it will return without masking the interrupt.
+   This value is a mask of all the IRQs handled by the IRQ handler (see em8xxx
+   hardware IRQ register).
+
+   *** IMPORTANT *** This value must be update in llad.c if changed.
+*/
+#define UCLINUX_LLAD_IRQHANDLER_HANDSHAKE    (REG_BASE_cpu_block + 0x006C)
+
+/* these symbols are used to store the entry point of the irqhandler
+   loaded by the bootloader.  when uclinux boots it overwrites the
+   interrupt vector, and when we load emhwlib we must restore the RUA
+   entry point in the vector. Since the current version of the emhwlib
+   loaded may not match the irqhandler loaded by bootloader, the entry
+   points should not be determined at compilation time, but rather at
+   runtime.
+*/
+#define IRQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0070) 
+#define FIQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0074) 
+#define UNDEFHANDLER_ENTRY (REG_BASE_cpu_block + 0x0078) 
+#define JUMPTABLE_ADDRESS  (REG_BASE_cpu_block + 0x007c)
+
+/* address of linux General exeption handler */
+#define LINUX_GE (REG_BASE_cpu_block + 0x0080)
+
+// random seeds (refer to gbuslib/include/gbus_random.h)
+#define RANDOM0              (REG_BASE_cpu_block + LR_RANDOM_SEED + 0)
+#define RANDOM1              (REG_BASE_cpu_block + LR_RANDOM_SEED + 4)
+
+#define PCI_INTERRUPT_ENABLE    (REG_BASE_cpu_block + LR_PCI_INTERRUPT_ENABLE)
+#define HOST_INTERRUPT_STATUS   (REG_BASE_cpu_block + LR_HOST_INTERRUPT_STATUS)
+
+// next 8 dword locations are for local debug, they are reset to 0 at vsync_init time.
+// Please do not affect them in cvs source.
+#define DEBUG_PROBE0                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x00)
+#define DEBUG_PROBE1                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x04)
+#define DEBUG_PROBE2                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x08)
+#define DEBUG_PROBE3                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x0c)
+#define DEBUG_PROBE4                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x10)
+#define DEBUG_PROBE5                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x14)
+#define DEBUG_PROBE6                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x18)
+#define DEBUG_PROBE7                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x1c)
+
+// uses 8 entries, up to 0x1EF0
+#define PARAM_VSYNC_PERIOD_DEC0        (REG_BASE_cpu_block + LR_VSYNC_PERIOD)  // video decoder 0
+
+#endif // __EMHWLIB_RESOURCES_SHARED_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_shared.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_shared.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_shared.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_shared.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_resources_shared.inc (generated from emhwlib/include/emhwlib_resources_shared.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_tango3.h linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_tango3.h
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_tango3.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_tango3.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,48 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_tango2.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-01-28y
+*/
+
+#ifndef __EMHWLIB_RESOURCES_TANGO3_H__
+#define __EMHWLIB_RESOURCES_TANGO3_H__
+
+#define VSYNC_PARAM_MUTEX   ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex2))
+#define PCI_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex3))
+#define GFX_MUTEX           ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex4))
+#define HOST_MBUS_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex5))
+#define SOFT_IRQ_MUTEX_TASK ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex6))
+#define SOFT_IRQ_MUTEX_IRQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex7))
+#define SOFT_IRQ_MUTEX_FIQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex8))
+#define RTC_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex9))
+#define XRPC_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex10))
+#define XTASK_MUTEX         ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex11))
+#define IDMA_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex12)) /* keep same as tango15 */
+#define TIMER_IRQ_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex13)) 
+#define SSD_MUTEX           ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex14)) 
+
+#define AUDIO_0_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex0))
+#define AUDIO_1_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex0))
+#define VIDEO_0_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex0))
+#define VIDEO_1_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex0))
+#define DEMUX_IRQ_MUTEX     ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex0))
+#define DEMUX_EMHWLIB_MUTEX ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex4))
+#define TIMER_UPDATE_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex5))
+
+#define AUDIO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex1))
+#define AUDIO_1_ENET_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex2))
+#define AUDIO_1_INTSTATUS_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex3))
+
+#endif // __EMHWLIB_RESOURCES_TANGO3_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_tango3.inc linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_tango3.inc
--- linux-2.6.25.8/include/asm-mips/tango3/emhwlib_resources_tango3.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/emhwlib_resources_tango3.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/tango3/emhwlib_resources_tango3.inc (generated from emhwlib/include/tango3/emhwlib_resources_tango3.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/hardware.h linux-2.6.25.8-clean/include/asm-mips/tango3/hardware.h
--- linux-2.6.25.8/include/asm-mips/tango3/hardware.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/hardware.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,114 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+
+// UART0
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+// UART0
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#if defined(CONFIG_TANGO3_SMP865X)
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+#else
+#error "Unsupported Tango3 chip."
+#endif
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+// IDE interrupts
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+// MBUS interface
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+// GPIO
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+// UART GPIO
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	7   	/* 2^(7+3) = 1024MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<(MAX_LOG2_PCIMEM_MAP+3))*7)>>3)	/* Max ~896MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x40000000UL)   /* base address of EM86xx PCI slave */
+
+// Peripheral bus Registers
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+// Bus Master IDE
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+#ifndef __ASSEMBLY__
+
+// Physical address mapping
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+	extern unsigned long phy_remap, max_remap_size;
+
+	/* for Tango3, another remap takes place */
+	if ((physaddr >= CPU_REMAP_SPACE) && (physaddr < (CPU_REMAP_SPACE + max_remap_size)))
+		return(phy_remap + (physaddr - CPU_REMAP_SPACE));
+	else {
+		printk(KERN_ERR "dma_address conversion failure (0x%08lx in range 0x%08x-0x%08lx)\n",
+			physaddr, CPU_REMAP_SPACE, CPU_REMAP_SPACE + max_remap_size);
+		return(physaddr); /* use whatever is specified */
+	}
+}
+
+// Inverted physical address mapping
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+	extern unsigned long phy_remap, max_remap_size;
+
+	if ((mapaddr >= phy_remap) && (mapaddr < (phy_remap + max_remap_size)))
+		return(CPU_REMAP_SPACE + (mapaddr - phy_remap));
+	else {
+		printk(KERN_ERR "dma_address inversion failure (0x%08lx in range 0x%08lx-0x%08lx)\n",
+			mapaddr, phy_remap, phy_remap + max_remap_size);
+		return(mapaddr); /* use whatever is specified */
+	}
+}
+#endif
+
+#endif //__HARDWARE_H
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/ir.h linux-2.6.25.8-clean/include/asm-mips/tango3/ir.h
--- linux-2.6.25.8/include/asm-mips/tango3/ir.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/ir.h	2008-06-27 16:08:10.000000000 -0400
@@ -0,0 +1,34 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+                                                                                
+/*
+ * IR related definitions, and function prototypes.
+ */
+#ifndef _IR_H_
+#define _IR_H_
+                                                                                
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#elif !defined(BOOTLOADER)
+#include <sys/ioctl.h>
+#endif /* __KERNEL__ */
+
+#if defined(__KERNEL__) || !defined(BOOTLOADER)
+/* ioctl commands for user level applications*/
+#define IR_IOC_MAGIC           'I'
+#define IR_IOCSETREPEATKEYS	_IO(IR_IOC_MAGIC, 0)
+#define IR_IOCGETREPEATKEYS	_IO(IR_IOC_MAGIC, 1)
+#define IR_IOCSETWAITPERIOD	_IO(IR_IOC_MAGIC, 2)
+#define IR_IOCGETWAITPERIOD	_IO(IR_IOC_MAGIC, 3)
+#endif /* __KERNEL__ || !BOOTLOADER */
+                                                                                
+#endif /* _IR_H_ */
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/memcfg.h linux-2.6.25.8-clean/include/asm-mips/tango3/memcfg.h
--- linux-2.6.25.8/include/asm-mips/tango3/memcfg.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/memcfg.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,45 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* For more memcfg operations */
+
+#ifndef _MEMCFG_H_
+#define _MEMCFG_H_
+
+#include <linux/config.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/emhwlib_lram.h>
+#include <asm/tango3/emhwlib_dram.h>
+
+static inline int is_valid_memcfg(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	if ((memcfg_ptr->signature) != MEMCFG_SIGNATURE)
+		return(0);
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	return((sum == 0) ? 1 : 0);
+}
+
+static inline void gen_memcfg_checksum(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	memcfg_ptr->checksum = 0;
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	memcfg_ptr->checksum = ~sum + 1;
+}
+
+#endif /* _MEMCFG_H_ */
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/rmdefs.h linux-2.6.25.8-clean/include/asm-mips/tango3/rmdefs.h
--- linux-2.6.25.8/include/asm-mips/tango3/rmdefs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/rmdefs.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/rmem86xxid.h linux-2.6.25.8-clean/include/asm-mips/tango3/rmem86xxid.h
--- linux-2.6.25.8/include/asm-mips/tango3/rmem86xxid.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/rmem86xxid.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,203 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   rmem86xxid.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-09-22
+*/
+
+#ifndef __RMEM86XXID_H__
+#define __RMEM86XXID_H__
+
+/*
+  the main chip ids 
+  
+  tango3 is for asic development (should be tango\infty)
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#define EM86XX_CHIPID_MAMBO      1000
+#define EM86XX_CHIPID_MAMBOLIGHT 2000
+#define EM86XX_CHIPID_TANGO      3000
+#define EM86XX_CHIPID_TANGOLIGHT 4000
+#define EM86XX_CHIPID_TANGO15    4500
+#define EM86XX_CHIPID_TANGO2     5000
+#define EM86XX_CHIPID_TANGO3    10000
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_MAMBO)
+#define S_EM86XX_CHIPID "mambo"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_MAMBOLIGHT)
+#define S_EM86XX_CHIPID "mambolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGOLIGHT)
+#define S_EM86XX_CHIPID "tangolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO15)
+#define S_EM86XX_CHIPID "tango15"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+#define S_EM86XX_CHIPID "tango2"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#define S_EM86XX_CHIPID "tango3"
+#else
+#error EM86XX_CHIP is not set
+#endif
+
+/* 
+  revisions...
+  
+  Referring to whatever is written at the surface of the BGA,
+  not the PCI revid / subid / etc. This detail is important for some chips
+  are ambiguous software wise.
+  
+  1: ES1
+  2: ES2
+  3: ES3
+  4: ES4 
+  5: ES5 
+  6: ES6 
+  65: revA
+  66: revB
+  67: revC
+  
+  No ID, but numbers. For a 8630ES2 for instance: build with
+  RMCFLAGS="... -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=2 ..."
+
+  --------------------------------------------------------------------------
+  package writing          ES1  ES2  ES3  ES4     ES5     ES6  ES7  ES8  ES9 revA revB revC
+
+  EM86XX_REVISION            1    2    3    4       5       6    7    8    9  'A'  'B'  'C'
+
+  8600 `mambo' series                                                           1    2    3
+
+  8620 `tangolight' series                                                    (a)  (b) 0x82
+  8622 `tango15' series   0x81                (d)0x81                   0x82
+                                                                           ^this is the PCI revID
+
+  863x `tango2' series (c)0x81 0x81 0x81 0x82 (e)0x82 (f)0x83 0x84 0x85 0x86                
+
+  (a) don't remember
+  (b) no such chip
+  (c) 8630: FibbedES1 ES1 ES2 ES3 are the same chip
+  (d) 8622: ES1 and revA cannot be distinguished from revID. Software test impossible in practice
+  (e) 8630: ES4 and ES5 cannot be distinguished from revID. Software test with 0x6c900 bit12
+  (f) 8634: ES6 and RevA have the same revID (just different bonding option)
+      8634: ES7 and RevB have the same revID (just different bonding option)
+      8634: ES9 and RevC have the same revID (just different bonding option)
+  --------------------------------------------------------------------------
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#ifndef EM86XX_REVISION
+#error EM86XX_REVISION is not set
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='A') 
+#error inconsistent: 863x revA is actually -DWITH_PROD=1 -DEM86XX_REVISION=6
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='B') 
+#error inconsistent: 863x revB is actually -DWITH_PROD=1 -DEM86XX_REVISION=7
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='C') 
+#error inconsistent: 863x revC is actually -DWITH_PROD=1 -DEM86XX_REVISION=9
+#endif
+
+#if (EM86XX_REVISION==1)
+#define S_EM86XX_REVISION "ES1"
+#elif (EM86XX_REVISION==2)
+#define S_EM86XX_REVISION "ES2"
+#elif (EM86XX_REVISION==3)
+#define S_EM86XX_REVISION "ES3"
+#elif (EM86XX_REVISION==4)
+#define S_EM86XX_REVISION "ES4"
+#elif (EM86XX_REVISION==5)
+#define S_EM86XX_REVISION "ES5"
+#elif (EM86XX_REVISION==6)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revA"
+#else
+#define S_EM86XX_REVISION "ES6"
+#endif
+#elif (EM86XX_REVISION==7)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revB"
+#else
+#define S_EM86XX_REVISION "ES7"
+#endif
+#elif (EM86XX_REVISION==8)
+#define S_EM86XX_REVISION "ES8"
+#elif (EM86XX_REVISION==9)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revC"
+#else
+#define S_EM86XX_REVISION "ES9"
+#endif
+
+#elif (EM86XX_REVISION=='A')
+#define S_EM86XX_REVISION "revA"
+#elif (EM86XX_REVISION=='B')
+#define S_EM86XX_REVISION "revB"
+#elif (EM86XX_REVISION=='C')
+#define S_EM86XX_REVISION "revC"
+#else
+#error complete revision strings
+#endif
+
+/* the compilation modes */
+#define EM86XX_MODEID_WITHHOST   1000
+#define EM86XX_MODEID_STANDALONE 2000
+
+/* the dsps */
+#define EM86XX_ENGINEID_MPEG0 10
+#define EM86XX_ENGINEID_MPEG1 11
+#define EM86XX_ENGINEID_AUDIO0 20
+#define EM86XX_ENGINEID_AUDIO1 21
+#define EM86XX_ENGINEID_DEMUX 30
+
+/* user does not have to set an engine id. This makes sense for mu only */
+#ifdef EM86XX_ENGINE
+#if (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG0)
+#define SENG "mpeg0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG1)
+#define SENG "mpeg1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO0)
+#define SENG "audio0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO1)
+#define SENG "audio1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_DEMUX)
+#define SENG "demux"
+#else
+#endif // end of engine dependent stuff
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+/*
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_XLOADED_UCODE
+#error inconsistent flag combination.
+#endif
+
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_IRQHANDLER_BOOTLOADER
+#error inconsistent flag combination.
+#endif
+*/
+#ifdef WITH_UCODE_BOOTLOADER
+#error inconsistent flag combination. You probably want WITH_XLOADED_UCODE
+#endif
+
+#endif
+
+/* the microcode debug mode */
+
+#define EM86XX_DEBUG_CHIP	1000
+#define EM86XX_DEBUG_SIMU	2000
+
+#endif // __RMEM86XXID_H__
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/sigblock.h linux-2.6.25.8-clean/include/asm-mips/tango3/sigblock.h
--- linux-2.6.25.8/include/asm-mips/tango3/sigblock.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/sigblock.h	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,261 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SIG_BLOCK_H__
+#define __SIG_BLOCK_H__
+
+#define DEFAULT_IRQ_ROUTE1	0x55555555 /* All PCI IRQs route to LOG2_CPU_PCI_INTB */
+#define DEFAULT_IRQ_ROUTE2	0x00030000 /* ISA IDE uses LOG2_CPU_PCU_INTD, Timing slot 0 */
+#define DEFAULT_IRQ_RISE_EDGE_LO	0xff284a00 /* IRQ14 active low level, IRQ19/21 active riseedge */
+#define DEFAULT_IRQ_RISE_EDGE_HI	0x00000000 /* IRQ14 active low level, IRQ19/21 active rise edge */
+#define DEFAULT_IRQ_FALL_EDGE_LO	0x00004000
+#define DEFAULT_IRQ_FALL_EDGE_HI	0x00000000
+#define DEFAULT_IRQ_GPIO_MAP	0x0607080d /* ISA IDE/GPIO 6, PCI/GPIO 8 */
+#define DEFAULT_DEV_ENABLED	0x00003cf7 /* ISAIDE/BMIDE/PCIHOST/IR/FIP/I2CM/I2CS/PCI1-4 enabled */
+#define DEFAULT_PB_DEF_TIMING	0x01090008
+#define DEFAULT_PB_CS_CONFIG	0x00001044
+#define DEFAULT_PB_TIMING0	0x01090008
+#define DEFAULT_PB_USE_TIMING0	0x000001f4
+#define DEFAULT_PB_TIMING1	0x00110101
+#define DEFAULT_PB_USE_TIMING1	0x000003f3
+#define DEFAULT_PB_TIMING2	0
+#define DEFAULT_PB_USE_TIMING2	0
+#define DEFAULT_PB_TIMING3	0
+#define DEFAULT_PB_USE_TIMING3	0
+#define DEFAULT_PB_TIMING4	0
+#define DEFAULT_PB_USE_TIMING4	0
+#define DEFAULT_PB_TIMING5	0
+#define DEFAULT_PB_USE_TIMING5	0
+
+#define DEFAULT_SYSCLK_PLL	0x0 /* Set by XOS */
+#define DEFAULT_SYSCLK_DIV	0x0 /* Not changed */
+
+#define DEFAULT_ETH_MAC_HI	0x00000000 /* MAC address */
+#define DEFAULT_ETH_MAC_LO	0x00000000
+
+/* This list of devices in the enable list field (irq_route2) */
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+/*				19-32: undefined */
+
+#ifndef __ASSEMBLY__
+
+struct hwinfo {
+	unsigned long sysclk_pll; /* The setting for the PLL */
+	unsigned long sysclk_div;
+
+	/* Only 4 IRQs can be used for PCI devices (LOG2_CPU_PCI_INTA-D,
+	   so we can encode it in 2 bits. Each device can have 4 IRQ
+	   routing and as as result we can use one byte to represent
+	   the IRQ route for a given device (IDSELx). Bu using 8 bytes,
+	   we can represent the PCI devices (IDSEL1-6, 5-6 reserved) as
+	   well as ISA IDE information and device enabling list*/
+	unsigned long irq_route1;	/* PCI dev 1-4 */
+
+	/* PCI dev 5-6, ISA IDE information, device enabling list */
+	unsigned long irq_route2;	/* PCI dev 5-6: bit 0-15 */
+					/* ISA IDE: bit 16-17: IRQ offset */
+
+	unsigned long irq_rise_edge_hi; /* Rising edge config */
+	unsigned long irq_rise_edge_lo; /* Rising edge config */
+	unsigned long irq_fall_edge_hi; /* Falling edge config */
+	unsigned long irq_fall_edge_lo; /* Falling edge config */
+
+	unsigned long gpio_irq_map; /* GPIO pins hook to IRQ13..16 */
+	unsigned long dev_enabled;  /* Device enabling list*/
+
+	unsigned long pb_def_timing;
+	unsigned long pb_cs_config;
+	unsigned long pb_timing0;
+	unsigned long pb_use_timing0;
+	unsigned long pb_timing1;
+	unsigned long pb_use_timing1;
+	unsigned long pb_timing2;
+	unsigned long pb_use_timing2;
+	unsigned long pb_timing3;
+	unsigned long pb_use_timing3;
+	unsigned long pb_timing4;
+	unsigned long pb_use_timing4;
+	unsigned long pb_timing5;
+	unsigned long pb_use_timing5;
+
+	unsigned long mac_hi;	/* Ethernet MAC address */
+	unsigned long mac_lo;
+};
+
+/* Definition of signature block (192bytes), which should start at 0xbfc00000 */
+/* There'll be 20bytes sha1sum afterward (0xbfc000c0-0xbfc000d3) */
+struct signature_block {
+	unsigned long opcodes[2];  /* For opcodes, fixed value 0x10000034/0x00000000 */
+	struct hwinfo hwinfo;
+	/* 
+	   zboot or such specific extensions 
+
+	   Note that YAMON requires extension[2]=0x1105e0 (product ID `thirdparty')
+	 */
+	unsigned long extension[20];	
+};
+
+//RMmustBeEqual(sizeof(struct signature_block),3*64,seed0);
+
+#ifdef __EMHWLIB_REGISTERS_TANGO2_H__
+static inline int isaide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ISAIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int bmide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> BMIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sata_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SATA_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int scard_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SCARD_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int gnet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> GNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pci_host_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> PCIHOST_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ethernet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ETHERNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ir_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> IR_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int fip_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> FIP_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cm_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CM_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cs_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CS_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sdio_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SDIO_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int usb_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> USB_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pcidev_enabled(const struct signature_block *sigptr, int pci_idsel)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> (pci_idsel - 1 + PCI1_SHIFT)) & 1) != 0) ? 1 : 0);
+}
+
+/* Given PCI device idsel number and INT number, returning the IRQ number
+   for it */
+static inline int pcidev_intr_num(const struct signature_block *sigptr,
+				const int pci_idsel, const int int_num)
+{
+	unsigned long route;
+	int irq;
+
+	if (pcidev_enabled(sigptr, pci_idsel) == 0)
+		return(-1);
+	else if ((pci_idsel >= 1) && (pci_idsel <= 4)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route1) >> ((pci_idsel - 1) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else if ((pci_idsel >= 5) && (pci_idsel <= 6)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route2) >> ((pci_idsel - 5) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else 
+		return(-1);
+
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+ 
+/* Find out the CS# used by ISA IDE */
+static inline int isaide_cs_select(const struct signature_block *sigptr)
+{
+	unsigned long cs_config = (sigptr->hwinfo.pb_cs_config >> 12) & 0xf;
+	int i;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+
+	for (i = 0; i < 4; i++) {
+		if ((cs_config & 0x1) != 0) 
+			return(i);
+		else
+			cs_config >>= 1;
+	}
+	return(-1);
+}
+
+/* Return the IRQ number for ISA IDE */
+static inline int isaide_intr_num(const struct signature_block *sigptr)
+{
+	int irq;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+	else
+		irq = (int)(((sigptr->hwinfo.irq_route2) >> 16) & 0x3);
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+
+static inline int isaide_timing_slot(const struct signature_block *sigptr)
+{
+	unsigned long slot;
+
+	slot = ((sigptr->hwinfo.irq_route2) >> 18) & 0x7;
+	return((int)slot);
+}
+#endif /* __EMHWLIB_REGISTERS_TANGO2_H__ */
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* !__SIG_BLOCK_H__ */
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/sigblock.inc linux-2.6.25.8-clean/include/asm-mips/tango3/sigblock.inc
--- linux-2.6.25.8/include/asm-mips/tango3/sigblock.inc	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/sigblock.inc	2008-06-26 14:59:42.000000000 -0400
@@ -0,0 +1,59 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/sigblock.inc (generated from emhwlib_hal/include/sigblock.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007. All rights reserved.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+DEFAULT_IRQ_ROUTE1=0x55555555
+DEFAULT_IRQ_ROUTE2=0x30000
+DEFAULT_IRQ_RISE_EDGE_LO=0xff284a00
+DEFAULT_IRQ_RISE_EDGE_HI=0x0
+DEFAULT_IRQ_FALL_EDGE_LO=0x4000
+DEFAULT_IRQ_FALL_EDGE_HI=0x0
+DEFAULT_IRQ_GPIO_MAP=0x607080d
+DEFAULT_DEV_ENABLED=0x3cf7
+DEFAULT_PB_DEF_TIMING=0x1090008
+DEFAULT_PB_CS_CONFIG=0x1044
+DEFAULT_PB_TIMING0=0x1090008
+DEFAULT_PB_USE_TIMING0=0x1f4
+DEFAULT_PB_TIMING1=0x110101
+DEFAULT_PB_USE_TIMING1=0x3f3
+DEFAULT_PB_TIMING2=0x0
+DEFAULT_PB_USE_TIMING2=0x0
+DEFAULT_PB_TIMING3=0x0
+DEFAULT_PB_USE_TIMING3=0x0
+DEFAULT_PB_TIMING4=0x0
+DEFAULT_PB_USE_TIMING4=0x0
+DEFAULT_PB_TIMING5=0x0
+DEFAULT_PB_USE_TIMING5=0x0
+DEFAULT_SYSCLK_PLL=0x0
+DEFAULT_SYSCLK_DIV=0x0
+DEFAULT_ETH_MAC_HI=0x0
+DEFAULT_ETH_MAC_LO=0x0
+ISAIDE_SHIFT=0x0
+BMIDE_SHIFT=0x1
+PCIHOST_SHIFT=0x2
+ETHERNET_SHIFT=0x3
+IR_SHIFT=0x4
+FIP_SHIFT=0x5
+I2CM_SHIFT=0x6
+I2CS_SHIFT=0x7
+SDIO_SHIFT=0x8
+USB_SHIFT=0x9
+PCI1_SHIFT=0xa
+PCI2_SHIFT=0xb
+PCI3_SHIFT=0xc
+PCI4_SHIFT=0xd
+PCI5_SHIFT=0xe
+PCI6_SHIFT=0xf
+SATA_SHIFT=0x10
+SCARD_SHIFT=0x11
+GNET_SHIFT=0x12
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/tango3.h linux-2.6.25.8-clean/include/asm-mips/tango3/tango3.h
--- linux-2.6.25.8/include/asm-mips/tango3/tango3.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/tango3.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,62 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   tango3.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO3_H__
+#define __TANGO3_H__
+#include <linux/config.h>
+#include <asm/tango3/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/emhwlib_lram.h>
+#include <asm/tango3/emhwlib_resources_tango3.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#endif
+/* Baudrate setting */
+#if defined(CONFIG_TANGO3_SMP865X)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGOX_SMP865X */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO3_SMP865X)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGOX_SMP865X */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO3_SMP865X)
+#define SYS_clkgen_pll        SYS_clkgen3_pll
+#endif
+
+#endif // __TANGO3_H__
+
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/tango3_gbus.h linux-2.6.25.8-clean/include/asm-mips/tango3/tango3_gbus.h
--- linux-2.6.25.8/include/asm-mips/tango3/tango3_gbus.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/tango3_gbus.h	2008-06-26 14:59:44.000000000 -0400
@@ -0,0 +1,146 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+  Refer to bug #3644.
+
+  TLB-based implementation works on the ranges:
+  [0x00000000..0x20000000[ access thru kseg1
+  [0x20000000..0x2xxxxxxx (size  of dram1, a  parameter of ioremap())[
+  access thru tlb. Outside: unpredictable/oops.
+
+  Remap-based implementation does:
+  00xy b27b26..b0 to 101y(b27|x)b26..b0.
+  and works  everywhere excepted ranges:  [0x18000000..0x20000000[ and
+  [0x28000000..0xffffffff]
+
+  Test with
+  {
+	volatile int q=gbus_read_uint32(pGBus,0x1020212c); // correct
+	q=gbus_read_uint32(pGBus,0x1f20212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2020212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2720212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2820212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2f20212c);              // incorrect
+  }
+*/
+
+#ifndef __TANGO3_GBUS_H
+#define __TANGO3_GBUS_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+#ifdef CONFIG_TANGO3_USE_TLB_REMAP_DRAM1
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	ext	\\res, \\addr, 29, 1				\n"
+	"	bnez	\\res, 1f					\n"
+	"	lui	\\tmp, 0xa000					\n"
+	"	or	\\res, \\tmp, \\addr				\n"
+	"	j	2f						\n"
+	"	nop							\n"
+	"1:								\n"
+	"	lui	\\tmp, 0x2000					\n"
+	"	sub	\\res, \\addr, \\tmp				\n"
+	"	lw	\\tmp, em86xx_tlb_dram1_map_base		\n"
+	"	add	\\res, \\tmp					\n"
+	"2:								\n"
+	"	.endm");
+
+#else
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	rotr	\\res, \\addr, 29				\n"
+	"	ins	\\res, \\res, 30, 1				\n"
+	"	or	\\res, 5					\n"
+	"	rotr	\\res, 3					\n"
+	"	.endm");
+#endif
+
+
+/*
+ * we just want to set kseg1 bit, most of the time address is known at
+ * compile time, so this will usually be reduced to 2 instructions
+ */
+
+#define BUILD_GBUS_READ(size)						\
+static inline RMuint32 gbus_read_dram_uint##size(struct gbus *pgbus,	\
+					    RMuint32 byte_address)	\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		return *((volatile RMuint##size *)KSEG1ADDR(byte_address)); \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		return *((volatile RMuint##size *)res);			\
+	}								\
+}
+
+BUILD_GBUS_READ(8);
+BUILD_GBUS_READ(16);
+BUILD_GBUS_READ(32);
+
+#define BUILD_GBUS_WRITE(size)						\
+static inline void gbus_write_dram_uint##size(struct gbus *pgbus,	\
+				     RMuint32 byte_address,		\
+				     RMuint##size data)			\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data; \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		*((volatile RMuint##size *)res) = data;			\
+	}								\
+}
+
+BUILD_GBUS_WRITE(8);
+BUILD_GBUS_WRITE(16);
+BUILD_GBUS_WRITE(32);
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_readl(r)		gbus_read_uint32(pGBus, (r))
+#define gbus_writel(r, v)	gbus_write_uint32(pGBus, (r), (v))
+#define gbus_readw(r)		gbus_read_uint16(pGBus, (r))
+#define gbus_writew(r, v)	gbus_write_uint16(pGBus, (r), (v))
+#define gbus_readb(r)		gbus_read_uint8(pGBus, (r))
+#define gbus_writeb(r, v)	gbus_write_uint8(pGBus, (r), (v))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO3_GBUS_H */
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/tango3_usb.h linux-2.6.25.8-clean/include/asm-mips/tango3/tango3_usb.h
--- linux-2.6.25.8/include/asm-mips/tango3/tango3_usb.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/tango3_usb.h	2008-06-26 15:01:02.000000000 -0400
@@ -0,0 +1,38 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_USB_H
+#define __TANGO3_USB_H
+
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+
+#define TANGOX_EHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT)
+#define TANGOX_OHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+
+#define TANGOX_EHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE	(REG_BASE_host_interface + 0x1700)
+
+/*
+ * helpers to access USB registers
+ */
+#define RD_OHCI_REG32(r)	\
+		gbus_readl(TANGOX_OHCI_BASE_ADDR + (r))
+
+#define WR_OHCI_REG32(r, v)	\
+		gbus_writel(TANGOX_OHCI_BASE_ADDR + (r), (v))
+
+#define RD_USB_REG32(r)	\
+		gbus_readl(TANGOX_USB_CTL_STATUS_REG_BASE + (r))
+
+#define WR_USB_REG32(r, v)	\
+		gbus_writel(TANGOX_USB_CTL_STATUS_REG_BASE + (r), (v))
+
+#endif
diff -Naur linux-2.6.25.8/include/asm-mips/tango3/tango3api.h linux-2.6.25.8-clean/include/asm-mips/tango3/tango3api.h
--- linux-2.6.25.8/include/asm-mips/tango3/tango3api.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/asm-mips/tango3/tango3api.h	2008-06-26 14:59:52.000000000 -0400
@@ -0,0 +1,118 @@
+/*
+ * include/asm-mips/tango3/tango3api.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango3/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA1, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_SATA2, SBOX_MBUS_W2, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_init(void);
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int any);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+
+int em86xx_mbus_setup_dma_common(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+void em86xx_mbus_setup_dma_linear(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int flags);
+void em86xx_mbus_setup_dma_double(unsigned int regbase, unsigned int addr, unsigned int count, unsigned int addr2, unsigned int count2, unsigned int flags);
+void em86xx_mbus_setup_dma_rectangle(unsigned int regbase, unsigned int addr, unsigned int horiz, unsigned int lines, int skip, unsigned int flags);
+void em86xx_mbus_setup_dma_void(unsigned int regbase);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+#if defined(CONFIG_EM86XX_UART0_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART0_AS_GPIO_PARTIAL)
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+#endif
+#if defined(CONFIG_EM86XX_UART1_AS_GPIO_FULL) || defined(CONFIG_EM86XX_UART1_AS_GPIO_PARTIAL)
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+#endif
+
+#endif
+
diff -Naur linux-2.6.25.8/include/asm-mips/thread_info.h linux-2.6.25.8-clean/include/asm-mips/thread_info.h
--- linux-2.6.25.8/include/asm-mips/thread_info.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/thread_info.h	2008-09-22 22:16:34.000000000 -0400
@@ -122,6 +122,7 @@
 #define TIF_32BIT_REGS		22	/* also implies 16/32 fprs */
 #define TIF_32BIT_ADDR		23	/* 32-bit address space (o32/n32) */
 #define TIF_FPUBOUND		24	/* thread bound to FPU-full CPU set */
+#define TIF_DMA		25	/* thread is doing kernel-userspace dma */
 #define TIF_SYSCALL_TRACE	31	/* syscall trace active */
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -Naur linux-2.6.25.8/include/asm-mips/uaccess.h linux-2.6.25.8-clean/include/asm-mips/uaccess.h
--- linux-2.6.25.8/include/asm-mips/uaccess.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/asm-mips/uaccess.h	2008-12-11 14:51:31.000000000 -0500
@@ -438,12 +438,15 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);	\
+	__cu_len = __invoke_copy_to_user_dma(__cu_to, __cu_from, __cu_len);	\
 	__cu_len;							\
 })
 
 extern size_t __copy_user_inatomic(void *__to, const void *__from, size_t __n);
 
+extern size_t __invoke_copy_to_user_dma(void __user * __cu_to, const void * __cu_from, long __cu_len);
+extern size_t __invoke_copy_from_user_dma(void * __cu_to, const void __user * __cu_from, long __cu_len);
+
 #define __copy_to_user_inatomic(to, from, n)				\
 ({									\
 	void __user *__cu_to;						\
@@ -453,7 +456,7 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);	\
+	__cu_len = __invoke_copy_to_user_dma(__cu_to, __cu_from, __cu_len);	\
 	__cu_len;							\
 })
 
@@ -471,6 +474,8 @@
 	__cu_len;							\
 })
 
+extern long long em86_stats[20];
+
 /*
  * copy_to_user: - Copy a block of data into user space.
  * @to:   Destination address, in user space.
@@ -495,7 +500,7 @@
 	__cu_from = (from);						\
 	__cu_len = (n);							\
 	if (access_ok(VERIFY_WRITE, __cu_to, __cu_len))			\
-		__cu_len = __invoke_copy_to_user(__cu_to, __cu_from,	\
+		__cu_len = __invoke_copy_to_user_dma(__cu_to, __cu_from,	\
 		                                 __cu_len);		\
 	__cu_len;							\
 })
@@ -506,6 +511,7 @@
 	register const void __user *__cu_from_r __asm__("$5");		\
 	register long __cu_len_r __asm__("$6");				\
 									\
+	em86_stats[4]+=(n); \
 	__cu_to_r = (to);						\
 	__cu_from_r = (from);						\
 	__cu_len_r = (n);						\
@@ -529,6 +535,7 @@
 	register const void __user *__cu_from_r __asm__("$5");		\
 	register long __cu_len_r __asm__("$6");				\
 									\
+	em86_stats[6]+=(n); \
 	__cu_to_r = (to);						\
 	__cu_from_r = (from);						\
 	__cu_len_r = (n);						\
@@ -573,7 +580,7 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,		\
+	__cu_len = __invoke_copy_from_user_dma(__cu_to, __cu_from,		\
 	                                   __cu_len);			\
 	__cu_len;							\
 })
@@ -605,7 +612,7 @@
 	__cu_from = (from);						\
 	__cu_len = (n);							\
 	if (access_ok(VERIFY_READ, __cu_from, __cu_len))		\
-		__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,	\
+		__cu_len = __invoke_copy_from_user_dma(__cu_to, __cu_from,	\
 		                                   __cu_len);		\
 	__cu_len;							\
 })
@@ -645,6 +652,7 @@
 {
 	__kernel_size_t res;
 
+	em86_stats[8]+=(size); 
 	might_sleep();
 	__asm__ __volatile__(
 		"move\t$4, %1\n\t"
diff -Naur linux-2.6.25.8/include/linux/serial_reg.h linux-2.6.25.8-clean/include/linux/serial_reg.h
--- linux-2.6.25.8/include/linux/serial_reg.h	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/include/linux/serial_reg.h	2008-06-26 14:59:44.000000000 -0400
@@ -15,12 +15,44 @@
 #define _LINUX_SERIAL_REG_H
 
 /*
- * DLAB=0
+ * smp863x has an 16550 uart, but registers have been messed up...
  */
+#ifdef CONFIG_TANGOX
+
 #define UART_RX		0	/* In:  Receive buffer */
-#define UART_TX		0	/* Out: Transmit buffer */
+#define UART_TX		1	/* Out: Transmit buffer */
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#define UART_FCR	4	/* Out: FIFO Control Register */
+#define UART_LCR	5	/* Out: Line Control Register */
+#define UART_MCR	6	/* Out: Modem Control Register */
+#define UART_LSR	7	/* In:  Line Status Register */
+#define UART_MSR	8	/* In:  Modem Status Register */
+#define UART_SCR	9	/* I/O: Scratch Register */
+
+/* EFR does not exist on TANGOX,  we use a magic to catch accesses and
+ * make them nop */
+#define UART_EFR	42
+
+#else
 
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+#endif
+
+/*
+ * DLAB=0
+ */
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +62,6 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
-#define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -40,7 +71,6 @@
 
 #define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
 
-#define UART_FCR	2	/* Out: FIFO Control Register */
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -83,7 +113,6 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
-#define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -99,7 +128,6 @@
 #define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
 #define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
 
-#define UART_MCR	4	/* Out: Modem Control Register */
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -110,7 +138,6 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
-#define UART_LSR	5	/* In:  Line Status Register */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
@@ -120,7 +147,6 @@
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 #define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
 
-#define UART_MSR	6	/* In:  Modem Status Register */
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -131,18 +157,25 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
-#define UART_SCR	7	/* I/O: Scratch Register */
 
 /*
  * DLAB=1
  */
+
+/*
+ * smp863x has DLM and DLM in one register
+ */
+#ifdef CONFIG_TANGOX
+#define UART_DL		10
+#define UART_CLKSEL	11	/* Clock selection */
+#else
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
+#endif
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
-#define UART_EFR	2	/* I/O: Extended Features Register */
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
 #define UART_EFR_SCD		0x20 /* Special character detect */
diff -Naur linux-2.6.25.8/include/linux/squashfs_fs.h linux-2.6.25.8-clean/include/linux/squashfs_fs.h
--- linux-2.6.25.8/include/linux/squashfs_fs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/linux/squashfs_fs.h	2008-07-23 15:17:55.000000000 -0400
@@ -0,0 +1,935 @@
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs.h
+ */
+
+#ifndef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#define CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#endif
+
+#define SQUASHFS_CACHED_FRAGMENTS	CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE	
+#define SQUASHFS_MAJOR			3
+#define SQUASHFS_MINOR			1
+#define SQUASHFS_MAGIC			0x73717368
+#define SQUASHFS_MAGIC_SWAP		0x68737173
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		131072
+#define SQUASHFS_FILE_LOG		17
+
+#define SQUASHFS_FILE_MAX_SIZE		1048576
+
+/* Max number of uids and gids */
+#define SQUASHFS_UIDS			256
+#define SQUASHFS_GUIDS			255
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+
+#define SQUASHFS_INVALID		((long long) 0xffffffffffff)
+#define SQUASHFS_INVALID_FRAG		((unsigned int) 0xffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) -1)
+#define SQUASHFS_USED_BLK		((long long) -2)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_CHECK			2
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+#define SQUASHFS_EXPORT			7
+
+#define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
+
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOI)
+
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOD)
+
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOF)
+
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_FRAG)
+
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_ALWAYS_FRAG)
+
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_DUPLICATE)
+
+#define SQUASHFS_EXPORTABLE(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_EXPORT)
+
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_CHECK)
+
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, \
+		duplicate_checking, exortable)	(noi | (nod << 1) | (check_data << 2) \
+		| (nof << 3) | (no_frag << 4) | (always_frag << 5) | \
+		(duplicate_checking << 6) | (exportable << 7))
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_FILE_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+#define SQUASHFS_LREG_TYPE		9
+
+/* 1.0 filesystem type definitions */
+#define SQUASHFS_TYPES			5
+#define SQUASHFS_IPC_TYPE		0
+
+/* Flag whether block is compressed or uncompressed, bit is set if block is
+ * uncompressed */
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+
+#define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
+		(B) & ~SQUASHFS_COMPRESSED_BIT :  SQUASHFS_COMPRESSED_BIT)
+
+#define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
+
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	((B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_BLOCK(B)	(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
+
+/*
+ * Inode number ops.  Inodes consist of a compressed block number, and an
+ * uncompressed  offset within that block
+ */
+#define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+
+#define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
+
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode_t)(((squashfs_inode_t) (A)\
+					<< 16) + (B)))
+
+/* Compute 32 bit VFS inode number from squashfs inode number */
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + \
+					((b) >> 2) + 1))
+/* XXX */
+
+/* Translate between VFS mode and squashfs mode */
+#define SQUASHFS_MODE(a)		((a) & 0xfff)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES(A)	((A) * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) *\
+						sizeof(long long))
+
+/* inode lookup table defines */
+#define SQUASHFS_LOOKUP_BYTES(A)	((A) * sizeof(squashfs_inode_t))
+
+#define SQUASHFS_LOOKUP_BLOCK(A)		(SQUASHFS_LOOKUP_BYTES(A) / \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_OFFSET(A)		(SQUASHFS_LOOKUP_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCKS(A)	((SQUASHFS_LOOKUP_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_BYTES(A)	(SQUASHFS_LOOKUP_BLOCKS(A) *\
+					sizeof(long long))
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	64
+
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << \
+					(SQUASHFS_MAX_FILE_SIZE_LOG - 2))
+
+#define SQUASHFS_MARKER_BYTE		0xff
+
+/* meta index cache */
+#define SQUASHFS_META_INDEXES	(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))
+#define SQUASHFS_META_ENTRIES	31
+#define SQUASHFS_META_NUMBER	8
+#define SQUASHFS_SLOTS		4
+
+struct meta_entry {
+	long long		data_block;
+	unsigned int		index_block;
+	unsigned short		offset;
+	unsigned short		pad;
+};
+
+struct meta_index {
+	unsigned int		inode_number;
+	unsigned int		offset;
+	unsigned short		entries;
+	unsigned short		skip;
+	unsigned short		locked;
+	unsigned short		pad;
+	struct meta_entry	meta_entry[SQUASHFS_META_ENTRIES];
+};
+
+
+/*
+ * definitions for structures on disk
+ */
+
+typedef long long		squashfs_block_t;
+typedef long long		squashfs_inode_t;
+
+struct squashfs_super_block {
+	unsigned int		s_magic;
+	unsigned int		inodes;
+	unsigned int		bytes_used_2;
+	unsigned int		uid_start_2;
+	unsigned int		guid_start_2;
+	unsigned int		inode_table_start_2;
+	unsigned int		directory_table_start_2;
+	unsigned int		s_major:16;
+	unsigned int		s_minor:16;
+	unsigned int		block_size_1:16;
+	unsigned int		block_log:16;
+	unsigned int		flags:8;
+	unsigned int		no_uids:8;
+	unsigned int		no_guids:8;
+	unsigned int		mkfs_time /* time of filesystem creation */;
+	squashfs_inode_t	root_inode;
+	unsigned int		block_size;
+	unsigned int		fragments;
+	unsigned int		fragment_table_start_2;
+	long long		bytes_used;
+	long long		uid_start;
+	long long		guid_start;
+	long long		inode_table_start;
+	long long		directory_table_start;
+	long long		fragment_table_start;
+	long long		lookup_table_start;
+} __attribute__ ((packed));
+
+struct squashfs_dir_index {
+	unsigned int		index;
+	unsigned int		start_block;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+#define SQUASHFS_BASE_INODE_HEADER		\
+	unsigned int		inode_type:4;	\
+	unsigned int		mode:12;	\
+	unsigned int		uid:8;		\
+	unsigned int		guid:8;		\
+	unsigned int		mtime;		\
+	unsigned int 		inode_number;
+
+struct squashfs_base_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_lreg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	long long		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		parent_inode;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		i_count:16;
+	unsigned int		parent_inode;
+	struct squashfs_dir_index	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header {
+	struct squashfs_base_inode_header	base;
+	struct squashfs_dev_inode_header	dev;
+	struct squashfs_symlink_inode_header	symlink;
+	struct squashfs_reg_inode_header	reg;
+	struct squashfs_lreg_inode_header	lreg;
+	struct squashfs_dir_inode_header	dir;
+	struct squashfs_ldir_inode_header	ldir;
+	struct squashfs_ipc_inode_header	ipc;
+};
+	
+struct squashfs_dir_entry {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	signed int		inode_number:16; /* very important signedness */
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_header {
+	unsigned int		count:8;
+	unsigned int		start_block;
+	unsigned int		inode_number;
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry {
+	long long		start_block;
+	unsigned int		size;
+	unsigned int		pending;
+} __attribute__ ((packed));
+
+extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
+extern int squashfs_uncompress_init(void);
+extern int squashfs_uncompress_exit(void);
+
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating or using a filesystem
+ * on a machine with different byte ordering to the target architecture.
+ *
+ */
+
+#define SQUASHFS_SWAP_START \
+	int bits;\
+	int b_pos;\
+	unsigned long long val;\
+	unsigned char *s;\
+	unsigned char *d;
+
+#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->bytes_used_2, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start_2, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start_2, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start_2, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start_2, d, 192, 32);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 272, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 288, 8);\
+	SQUASHFS_SWAP((s)->no_uids, d, 296, 8);\
+	SQUASHFS_SWAP((s)->no_guids, d, 304, 8);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\
+	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
+	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start_2, d, 472, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 504, 64);\
+	SQUASHFS_SWAP((s)->uid_start, d, 568, 64);\
+	SQUASHFS_SWAP((s)->guid_start, d, 632, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 696, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 760, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 824, 64);\
+	SQUASHFS_SWAP((s)->lookup_table_start, d, 888, 64);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 192, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 224, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 256, 64);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 147, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 160, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 192, 32);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 155, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 168, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 200, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 216, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 40, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+	SQUASHFS_SWAP((s)->inode_number, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
+}
+
+#define SQUASHFS_SWAP_INODE_T(s, d) SQUASHFS_SWAP_LONG_LONGS(s, d, 1)
+
+#define SQUASHFS_SWAP_SHORTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_LONG_LONGS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
+#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * bits / 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			bits)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+#define SQUASHFS_SWAP_LOOKUP_BLOCKS(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+
+struct squashfs_base_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		type:4;
+	unsigned int		offset:4;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+union squashfs_inode_header_1 {
+	struct squashfs_base_inode_header_1	base;
+	struct squashfs_dev_inode_header_1	dev;
+	struct squashfs_symlink_inode_header_1	symlink;
+	struct squashfs_reg_inode_header_1	reg;
+	struct squashfs_dir_inode_header_1	dir;
+	struct squashfs_ipc_inode_header_1	ipc;
+};
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP((s)->type, d, 24, 4);\
+	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
+}
+
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+
+struct squashfs_dir_index_2 {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+struct squashfs_base_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	struct squashfs_dir_index_2	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header_2 {
+	struct squashfs_base_inode_header_2	base;
+	struct squashfs_dev_inode_header_2	dev;
+	struct squashfs_symlink_inode_header_2	symlink;
+	struct squashfs_reg_inode_header_2	reg;
+	struct squashfs_dir_inode_header_2	dir;
+	struct squashfs_ldir_inode_header_2	ldir;
+	struct squashfs_ipc_inode_header_2	ipc;
+};
+	
+struct squashfs_dir_header_2 {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed));
+
+struct squashfs_dir_entry_2 {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry_2 {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_2(s, d) \
+	SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, sizeof(struct squashfs_ipc_inode_header_2))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dev_inode_header_2)); \
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_2));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_reg_inode_header_2));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_ldir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index_2));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+#define SQUASHFS_SWAP_DIR_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header_2));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry_2));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry_2));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_2(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES_2(A)	(A * sizeof(struct squashfs_fragment_entry_2))
+
+#define SQUASHFS_FRAGMENT_INDEX_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_2(A)	((SQUASHFS_FRAGMENT_BYTES_2(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_2(A)	(SQUASHFS_FRAGMENT_INDEXES_2(A) *\
+						sizeof(int))
+
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing
+ * architectures
+ */
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+	/* convert from little endian to big endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, b_pos)
+#else
+	/* convert from big endian to little endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	b_pos = pos % 8;\
+	val = 0;\
+	s = (unsigned char *)p + (pos / 8);\
+	d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+
+#endif
+#endif
diff -Naur linux-2.6.25.8/include/linux/squashfs_fs_i.h linux-2.6.25.8-clean/include/linux/squashfs_fs_i.h
--- linux-2.6.25.8/include/linux/squashfs_fs_i.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/linux/squashfs_fs_i.h	2008-07-10 14:48:20.000000000 -0400
@@ -0,0 +1,45 @@
+#ifndef SQUASHFS_FS_I
+#define SQUASHFS_FS_I
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_i.h
+ */
+
+struct squashfs_inode_info {
+	long long	start_block;
+	unsigned int	offset;
+	union {
+		struct {
+			long long	fragment_start_block;
+			unsigned int	fragment_size;
+			unsigned int	fragment_offset;
+			long long	block_list_start;
+		} s1;
+		struct {
+			long long	directory_index_start;
+			unsigned int	directory_index_offset;
+			unsigned int	directory_index_count;
+			unsigned int	parent_inode;
+		} s2;
+	} u;
+	struct inode	vfs_inode;
+};
+#endif
diff -Naur linux-2.6.25.8/include/linux/squashfs_fs_sb.h linux-2.6.25.8-clean/include/linux/squashfs_fs_sb.h
--- linux-2.6.25.8/include/linux/squashfs_fs_sb.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.25.8-clean/include/linux/squashfs_fs_sb.h	2008-07-23 15:17:55.000000000 -0400
@@ -0,0 +1,76 @@
+#ifndef SQUASHFS_FS_SB
+#define SQUASHFS_FS_SB
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_sb.h
+ */
+
+#include <linux/squashfs_fs.h>
+
+struct squashfs_cache {
+	long long	block;
+	int		length;
+	long long	next_index;
+	char		*data;
+};
+
+struct squashfs_fragment_cache {
+	long long	block;
+	int		length;
+	unsigned int	locked;
+	char		*data;
+};
+
+struct squashfs_sb_info {
+	struct squashfs_super_block	sblk;
+	int			devblksize;
+	int			devblksize_log2;
+	int			swap;
+	struct squashfs_cache	*block_cache;
+	struct squashfs_fragment_cache	*fragment;
+	int			next_cache;
+	int			next_fragment;
+	int			next_meta_index;
+	unsigned int		*uid;
+	unsigned int		*guid;
+	long long		*fragment_index;
+	unsigned int		*fragment_index_2;
+	char			*read_page;
+	/* struct mutex		read_data_mutex; */
+	struct mutex		read_page_mutex;
+	struct mutex		block_cache_mutex;
+	struct mutex		fragment_mutex;
+	struct mutex		meta_index_mutex;
+	wait_queue_head_t	waitq;
+	wait_queue_head_t	fragment_wait_queue;
+	struct meta_index	*meta_index;
+	/* z_stream		stream; */
+	long long		*inode_lookup_table;
+	int			unused_cache_blks;
+	int			unused_frag_blks;
+	int			(*read_inode)(struct inode *i,  squashfs_inode_t \
+				inode);
+	long long		(*read_blocklist)(struct inode *inode, int \
+				index, int readahead_blks, char *block_list, \
+				unsigned short **block_p, unsigned int *bsize);
+	int			(*read_fragment_index_table)(struct super_block *s);
+};
+#endif
diff -Naur linux-2.6.25.8/init/do_mounts_rd.c linux-2.6.25.8-clean/init/do_mounts_rd.c
--- linux-2.6.25.8/init/do_mounts_rd.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/init/do_mounts_rd.c	2008-07-10 14:48:20.000000000 -0400
@@ -5,6 +5,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
 #include <linux/initrd.h>
 #include <linux/string.h>
 
@@ -39,6 +40,7 @@
  * numbers could not be found.
  *
  * We currently check for the following magic numbers:
+ *      squashfs
  * 	minix
  * 	ext2
  *	romfs
@@ -53,6 +55,7 @@
 	struct ext2_super_block *ext2sb;
 	struct romfs_super_block *romfsb;
 	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
 	int nblocks = -1;
 	unsigned char *buf;
 
@@ -64,6 +67,7 @@
 	ext2sb = (struct ext2_super_block *) buf;
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
 	memset(buf, 0xe5, size);
 
 	/*
@@ -101,6 +105,18 @@
 		goto done;
 	}
 
+	/* squashfs is at block zero too */
+	if (squashfsb->s_magic == SQUASHFS_MAGIC) {
+		printk(KERN_NOTICE
+		       "RAMDISK: squashfs filesystem found at block %d\n",
+		       start_block);
+		if (squashfsb->s_major < 3)
+			nblocks = (squashfsb->bytes_used_2+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		else
+			nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
 	/*
 	 * Read block 1 to test for minix and ext2 superblock
 	 */
diff -Naur linux-2.6.25.8/mm/memory.c linux-2.6.25.8-clean/mm/memory.c
--- linux-2.6.25.8/mm/memory.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/mm/memory.c	2008-09-22 22:18:17.000000000 -0400
@@ -1107,8 +1107,10 @@
 			if (pages) {
 				pages[i] = page;
 
-				flush_anon_page(vma, page, start);
-				flush_dcache_page(page);
+				if (!test_thread_flag(TIF_DMA)) {
+					flush_anon_page(vma, page, start);
+					flush_dcache_page(page);
+				}
 			}
 			if (vmas)
 				vmas[i] = vma;
diff -Naur linux-2.6.25.8/mm/page_alloc.c linux-2.6.25.8-clean/mm/page_alloc.c
--- linux-2.6.25.8/mm/page_alloc.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/mm/page_alloc.c	2008-06-26 14:59:44.000000000 -0400
@@ -1471,6 +1471,7 @@
 	int do_retry;
 	int alloc_flags;
 	int did_some_progress;
+	int num_retries = 0;
 
 	might_sleep_if(wait);
 
@@ -1636,6 +1637,12 @@
 
 nopage:
 	if (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit()) {
+		if (++num_retries < 16) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ);
+			goto rebalance;
+		}
+
 		printk(KERN_WARNING "%s: page allocation failure."
 			" order:%d, mode:0x%x\n",
 			p->comm, order, gfp_mask);
diff -Naur linux-2.6.25.8/net/core/dev.c linux-2.6.25.8-clean/net/core/dev.c
--- linux-2.6.25.8/net/core/dev.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/net/core/dev.c	2009-04-10 13:38:20.000000000 -0400
@@ -1449,8 +1449,10 @@
 
 /* Take action when hardware reception checksum errors are detected. */
 #ifdef CONFIG_BUG
+extern long long em86_netstats[20];
 void netdev_rx_csum_fault(struct net_device *dev)
 {
+	em86_netstats[14]+=1;
 	if (net_ratelimit()) {
 		printk(KERN_ERR "%s: hw csum failure.\n",
 			dev ? dev->name : "<unknown>");
diff -Naur linux-2.6.25.8/net/ipv4/tcp_input.c linux-2.6.25.8-clean/net/ipv4/tcp_input.c
--- linux-2.6.25.8/net/ipv4/tcp_input.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/net/ipv4/tcp_input.c	2009-04-09 15:02:24.000000000 -0400
@@ -72,6 +72,37 @@
 #include <asm/unaligned.h>
 #include <net/netdma.h>
 
+// JFT Tests
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <linux/interrupt.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/emhwlib_dram.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/memcfg.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <linux/interrupt.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/emhwlib_dram.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/hardware.h>
+#else
+#error "Unknown architecture"
+#endif
+
+long long em86_netstats[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static inline unsigned long tangox_getxtal(void)
+{
+	return(gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt));
+}
+
 int sysctl_tcp_timestamps __read_mostly = 1;
 int sysctl_tcp_window_scaling __read_mostly = 1;
 int sysctl_tcp_sack __read_mostly = 1;
@@ -4537,8 +4568,16 @@
 	if (skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_iovec(skb, hlen, tp->ucopy.iov, chunk);
 	else
+	{ // JFT Test
+		unsigned long t1,t2;
+		em86_netstats[0] +=1;
+		t1=tangox_getxtal();
+		//err = skb_copy_datagram_iovec(skb, hlen, tp->ucopy.iov, chunk);
 		err = skb_copy_and_csum_datagram_iovec(skb, hlen,
 						       tp->ucopy.iov);
+		t2=tangox_getxtal();
+		em86_netstats[1]+=(t2-t1);
+	}
 
 	if (!err) {
 		tp->ucopy.len -= chunk;
@@ -4568,8 +4607,16 @@
 static inline int tcp_checksum_complete_user(struct sock *sk,
 					     struct sk_buff *skb)
 {
-	return !skb_csum_unnecessary(skb) &&
+	// JFT Test
+	unsigned long t1,t2;
+	int tmp;
+	em86_netstats[2] +=1;
+	t1=tangox_getxtal();
+	tmp = !skb_csum_unnecessary(skb) &&
 	       __tcp_checksum_complete_user(sk, skb);
+	t2=tangox_getxtal();
+	em86_netstats[3]+=(t2-t1);
+	return tmp;
 }
 
 #ifdef CONFIG_NET_DMA
@@ -4771,6 +4818,7 @@
 					tcp_cleanup_rbuf(sk, skb->len);
 			}
 			if (!eaten) {
+				// Test JFT don't run checksum...
 				if (tcp_checksum_complete_user(sk, skb))
 					goto csum_error;
 
@@ -5410,3 +5458,4 @@
 EXPORT_SYMBOL(tcp_rcv_established);
 EXPORT_SYMBOL(tcp_rcv_state_process);
 EXPORT_SYMBOL(tcp_initialize_rcv_mss);
+EXPORT_SYMBOL(em86_netstats);
diff -Naur linux-2.6.25.8/net/ipv4/tcp_ipv4.c linux-2.6.25.8-clean/net/ipv4/tcp_ipv4.c
--- linux-2.6.25.8/net/ipv4/tcp_ipv4.c	2008-06-22 01:25:26.000000000 -0400
+++ linux-2.6.25.8-clean/net/ipv4/tcp_ipv4.c	2009-04-13 15:15:40.000000000 -0400
@@ -1506,10 +1506,15 @@
 	return sk;
 }
 
+extern long long em86_netstats[];
+
 static __sum16 tcp_v4_checksum_init(struct sk_buff *skb)
 {
 	const struct iphdr *iph = ip_hdr(skb);
 
+    em86_netstats[9]+=1;
+    em86_netstats[11]=skb->ip_summed;
+
 	if (skb->ip_summed == CHECKSUM_COMPLETE) {
 		if (!tcp_v4_check(skb->len, iph->saddr,
 				  iph->daddr, skb->csum)) {
